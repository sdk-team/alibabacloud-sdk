"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const credentials_1 = __importDefault(require("@alicloud/credentials"));
const xml2js_1 = require("xml2js");
const kitx_1 = __importDefault(require("kitx"));
const os_1 = require("os");
const mime_1 = require("mime");
const crypto_1 = require("crypto");
const crc_1 = __importDefault(require("./crc"));
const signature_1 = require("./signature");
function parseXML(body) {
    let parser = new xml2js_1.Parser({ explicitArray: false });
    let result = {};
    // parseString 实际上是一个同步方法
    parser.parseString(body, function (err, output) {
        result.err = err;
        result.output = output;
    });
    if (result.err) {
        throw result.err;
    }
    return result.output;
}
class BaseClient {
    constructor(config) {
        this._protocol = config['protocol'];
        this._endpoint = config['endpoint'];
        this._regionId = config['regionId'] || 'cn-hangzhou';
        this._signatureVersion = 'v1';
        this._isEnableMD5 = config['isEnableMD5'] || false;
        this._isEnableCrc = config['isEnableCrc'] || false;
        this._userAgent = `AlibabaCloud (${os_1.platform()}; ${os_1.arch()}) Node.js/${process.version} Core/1.0.1`;
        this._hostModel = config['hostModel'] || 'domain';
        this._addtionalHeaders = [];
        if (!config['type']) {
            config['type'] = 'access_key';
        }
        this._creadentials = new credentials_1.default({
            accessKeyId: config['accessKeyId'],
            accessKeySecret: config['accessKeySecret'],
            securityToken: config['securityToken'],
            type: config['type'],
        }, {});
    }
    _addAddtionalHeaders(header) {
        this._addtionalHeaders.push(header);
    }
    _setAddtionalHeaders(headers) {
        if (!headers) {
            return;
        }
        this._addtionalHeaders = headers;
    }
    _getAddtionalHeaders() {
        return this._addtionalHeaders;
    }
    _setSignatureVersion(version) {
        if (!version) {
            return;
        }
        this._signatureVersion = version.toLocaleLowerCase();
    }
    _setHostModel(model) {
        if (!model) {
            return;
        }
        this._hostModel = model.toLocaleLowerCase();
    }
    _setRegionId(regionId) {
        this._regionId = regionId || 'cn-hangzhou';
    }
    _getDate() {
        let now = new Date();
        return now.toUTCString();
    }
    _xmlCast(obj, clazz) {
        obj = obj || {};
        let ret = {};
        let clz = clazz;
        let names = clz.names();
        let types = clz.types();
        Object.keys(names).forEach((key) => {
            let originName = names[key];
            let value = obj[originName];
            let type = types[key];
            switch (type) {
                case 'boolean':
                    if (!value) {
                        ret[originName] = false;
                        return;
                    }
                    ret[originName] = value === 'false' ? false : true;
                    return;
                case 'number':
                    if (value != 0 && !value) {
                        ret[originName] = NaN;
                        return;
                    }
                    ret[originName] = +value;
                    return;
                case 'string':
                    if (!value) {
                        ret[originName] = '';
                        return;
                    }
                    ret[originName] = value.toString();
                    return;
                default:
                    if (type.type === 'array') {
                        if (!value) {
                            ret[originName] = [];
                            return;
                        }
                        if (!Array.isArray(value)) {
                            value = [value];
                        }
                        if (typeof type.itemType === 'function') {
                            ret[originName] = value.map((d) => {
                                return this._xmlCast(d, type.itemType);
                            });
                        }
                        else {
                            ret[originName] = value;
                        }
                    }
                    else if (typeof type === 'function') {
                        if (!value) {
                            value = {};
                        }
                        ret[originName] = this._xmlCast(value, type);
                    }
                    else {
                        ret[originName] = value;
                    }
            }
        });
        return ret;
    }
    async _readAsString(response) {
        let bytes = await response.readBytes();
        return bytes.toString();
    }
    _parseXml(body, clazz) {
        let ret = parseXML(body);
        if (typeof clazz !== 'undefined') {
            ret = this._xmlCast(ret, clazz);
        }
        return ret;
    }
    _equal(a, b) {
        return a === b;
    }
    _empty(input) {
        return !input;
    }
    _ifListEmpty(list) {
        return !list || list.length === 0;
    }
    _listToString(list, separator) {
        return list.join(separator);
    }
    _getSignatureV1(request, bucketName, accessKeySecret) {
        let result = signature_1.getSignatureV1(request, bucketName, accessKeySecret);
        return result.signature;
    }
    _getSignatureV2(request, bucketName, accessKeySecret, addtionalHeaders) {
        let result = signature_1.getSignatureV2(request, bucketName, accessKeySecret, addtionalHeaders);
        return result.signature;
    }
    _default(value, defaultVal) {
        if (!value) {
            return defaultVal;
        }
        return value;
    }
    _defaultNumber(number, defaultNum) {
        if (!number) {
            return defaultNum;
        }
        return number;
    }
    _isFail(response) {
        if (!response) {
            return true;
        }
        if (response.statusCode >= 200 && response.statusCode < 300) {
            return false;
        }
        return true;
    }
    _toQuery(query) {
        let ret = {};
        if (!query) {
            return ret;
        }
        for (let [key, value] of Object.entries(query)) {
            if (typeof value === 'undefined' || value == null) {
                ret[key] = '';
                continue;
            }
            ret[key] = value.toString();
        }
        return ret;
    }
    _toMeta(meta, prefix) {
        let ret = {};
        if (!meta) {
            return ret;
        }
        Object.keys(meta).forEach((key) => {
            if (typeof meta[key] === 'undefined' || meta[key] == null) {
                meta[key] = '';
            }
            if (!key.startsWith(prefix)) {
                ret[prefix + key] = meta[key].toString();
                return;
            }
            ret[key] = meta[key].toString();
        });
        return ret;
    }
    _parseMeta(meta, prefix) {
        let ret = {};
        if (!meta) {
            return ret;
        }
        Object.keys(meta).forEach((key) => {
            if (key.startsWith(prefix)) {
                ret[key.replace(prefix, '')] = meta[key];
                return;
            }
            ret[key] = meta[key];
        });
        return ret;
    }
    _getContentMD5(body) {
        return kitx_1.default.md5(body, 'hex');
    }
    _getContentType(name) {
        return mime_1.getType(name) || 'text/plain';
    }
    _isNotCrcMatched(calCrc, respCrc) {
        if (this._isEnableCrc && calCrc.toString() !== respCrc) {
            return true;
        }
        return false;
    }
    _encode(value, type) {
        if (!value) {
            return '';
        }
        let strs = value.split('/');
        let str = strs[strs.length - 1];
        switch (type) {
            case 'UrlEncode':
                str = encodeURIComponent(str);
                strs[strs.length - 1] = str;
                return strs.join('/');
            case 'Base64':
                str = Buffer.from(str).toString('base64');
                strs[strs.length - 1] = str;
                return strs.join('/');
        }
    }
    _base64Decode(value) {
        if (!value) {
            return '';
        }
        const strs = value.split('/');
        const result = Buffer.from(strs[strs.length - 1], 'base64').toString('utf8');
        strs[strs.length - 1] = result;
        return strs.join('/');
    }
    _getCrc(a, b, c, d) {
        throw new Error('the method is un-implemented!');
    }
    _getRespCrc(response, b, c, d) {
        throw new Error('the method is un-implemented!');
    }
    _getUserAgent(userAgent = '') {
        if (userAgent) {
            return this._userAgent + ' ' + userAgent;
        }
        return this._userAgent;
    }
    _isUploadSpeedLimit(body, limit) {
        if (limit == 0) {
            return body;
        }
        //Todo: finish speed limit readstream
        return body;
    }
    _ifRange(header) {
        if (header && header['Range']) {
            return true;
        }
        return false;
    }
    _headerCast(obj, clazz) {
        let ret = {};
        let clz = clazz;
        let names = clz.names();
        Object.keys(names).forEach((key) => {
            let targetName = names[key];
            let value = obj[key];
            if (typeof value === 'undefined' || value == null) {
                ret[targetName] = '';
                return;
            }
            ret[targetName] = value.toString();
        });
        return ret;
    }
    _toHeader(header) {
        let ret = {};
        if (!header) {
            return ret;
        }
        if (header.constructor && typeof header.constructor.names == 'function') {
            return this._headerCast(header, header.constructor);
        }
        for (let [key, value] of Object.entries(header)) {
            if (typeof value === 'undefined' || value == null) {
                ret[key] = '';
                continue;
            }
            ret[key] = value.toString();
        }
        return ret;
    }
    _readAsStream(response) {
        return response.body;
    }
    _getTracker() {
        throw new Error('the method is un-implemented!');
    }
    async _getAccessKeyID() {
        return await this._creadentials.getAccessKeyId();
    }
    async _getAccessKeySecret() {
        return await this._creadentials.getAccessKeySecret();
    }
    async _getSecurityToken() {
        return await this._creadentials.getSecurityToken();
    }
    _getErrMessage(xml) {
        let body = parseXML(xml);
        return body.Error || {};
    }
    _toXML(body) {
        const builder = new xml2js_1.Builder();
        return builder.buildObject(body);
    }
    _notNull(obj) {
        return !!obj;
    }
    _inject(readable, ref) {
        let shasum = crypto_1.createHash('md5');
        let crc64 = new crc_1.default();
        readable.on('data', function (chunk) {
            shasum.update(chunk);
            crc64.update(chunk);
        });
        readable.on('end', function () {
            ref['md5'] = shasum.digest('base64');
            ref['crc'] = crc64.sum();
        });
        readable.pause();
        return readable;
    }
}
exports.default = BaseClient;
//# sourceMappingURL=baseclient.js.map