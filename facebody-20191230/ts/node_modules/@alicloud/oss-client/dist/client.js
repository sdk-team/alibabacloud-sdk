"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
const tea_util_1 = __importDefault(require("@alicloud/tea-util"));
const oss_util_1 = __importDefault(require("@alicloud/oss-util"));
const tea_xml_1 = __importDefault(require("@alicloud/tea-xml"));
const tea_fileform_1 = __importStar(require("@alicloud/tea-fileform")), $FileForm = tea_fileform_1;
const credentials_1 = __importStar(require("@alicloud/credentials")), $Credential = credentials_1;
const $tea = __importStar(require("@alicloud/tea-typescript"));
class Config extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            securityToken: 'securityToken',
            accessKeyId: 'accessKeyId',
            accessKeySecret: 'accessKeySecret',
            endpoint: 'endpoint',
            protocol: 'protocol',
            regionId: 'regionId',
            userAgent: 'userAgent',
            hostModel: 'hostModel',
            signatureVersion: 'signatureVersion',
            isEnableMD5: 'isEnableMD5',
            isEnableCrc: 'isEnableCrc',
            readTimeout: 'readTimeout',
            connectTimeout: 'connectTimeout',
            localAddr: 'localAddr',
            httpProxy: 'httpProxy',
            httpsProxy: 'httpsProxy',
            noProxy: 'noProxy',
            socks5Proxy: 'socks5Proxy',
            socks5NetWork: 'socks5NetWork',
            maxIdleConns: 'maxIdleConns',
            addtionalHeaders: 'addtionalHeaders',
        };
    }
    static types() {
        return {
            type: 'string',
            securityToken: 'string',
            accessKeyId: 'string',
            accessKeySecret: 'string',
            endpoint: 'string',
            protocol: 'string',
            regionId: 'string',
            userAgent: 'string',
            hostModel: 'string',
            signatureVersion: 'string',
            isEnableMD5: 'boolean',
            isEnableCrc: 'boolean',
            readTimeout: 'number',
            connectTimeout: 'number',
            localAddr: 'string',
            httpProxy: 'string',
            httpsProxy: 'string',
            noProxy: 'string',
            socks5Proxy: 'string',
            socks5NetWork: 'string',
            maxIdleConns: 'number',
            addtionalHeaders: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.Config = Config;
class PutBucketLifecycleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketLifecycleRequestBody,
        };
    }
}
exports.PutBucketLifecycleRequest = PutBucketLifecycleRequest;
class PutBucketLifecycleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketLifecycleResponse = PutBucketLifecycleResponse;
class DeleteMultipleObjectsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: DeleteMultipleObjectsRequestBody,
            header: DeleteMultipleObjectsRequestHeader,
        };
    }
}
exports.DeleteMultipleObjectsRequest = DeleteMultipleObjectsRequest;
class DeleteMultipleObjectsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            deleteResult: 'DeleteResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            deleteResult: DeleteMultipleObjectsResponseDeleteResult,
        };
    }
}
exports.DeleteMultipleObjectsResponse = DeleteMultipleObjectsResponse;
class PutBucketRefererRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketRefererRequestBody,
        };
    }
}
exports.PutBucketRefererRequest = PutBucketRefererRequest;
class PutBucketRefererResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketRefererResponse = PutBucketRefererResponse;
class PutBucketWebsiteRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketWebsiteRequestBody,
        };
    }
}
exports.PutBucketWebsiteRequest = PutBucketWebsiteRequest;
class PutBucketWebsiteResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketWebsiteResponse = PutBucketWebsiteResponse;
class CompleteMultipartUploadRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            filter: 'Filter',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            filter: CompleteMultipartUploadRequestFilter,
            body: CompleteMultipartUploadRequestBody,
        };
    }
}
exports.CompleteMultipartUploadRequest = CompleteMultipartUploadRequest;
class CompleteMultipartUploadResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            completeMultipartUploadResult: 'CompleteMultipartUploadResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            completeMultipartUploadResult: CompleteMultipartUploadResponseCompleteMultipartUploadResult,
        };
    }
}
exports.CompleteMultipartUploadResponse = CompleteMultipartUploadResponse;
class PutBucketLoggingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketLoggingRequestBody,
        };
    }
}
exports.PutBucketLoggingRequest = PutBucketLoggingRequest;
class PutBucketLoggingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketLoggingResponse = PutBucketLoggingResponse;
class PutBucketRequestPaymentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketRequestPaymentRequestBody,
        };
    }
}
exports.PutBucketRequestPaymentRequest = PutBucketRequestPaymentRequest;
class PutBucketRequestPaymentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketRequestPaymentResponse = PutBucketRequestPaymentResponse;
class PutBucketEncryptionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketEncryptionRequestBody,
        };
    }
}
exports.PutBucketEncryptionRequest = PutBucketEncryptionRequest;
class PutBucketEncryptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketEncryptionResponse = PutBucketEncryptionResponse;
class PutLiveChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
            body: PutLiveChannelRequestBody,
        };
    }
}
exports.PutLiveChannelRequest = PutLiveChannelRequest;
class PutLiveChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            createLiveChannelResult: 'CreateLiveChannelResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            createLiveChannelResult: PutLiveChannelResponseCreateLiveChannelResult,
        };
    }
}
exports.PutLiveChannelResponse = PutLiveChannelResponse;
class PutBucketTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketTagsRequestBody,
        };
    }
}
exports.PutBucketTagsRequest = PutBucketTagsRequest;
class PutBucketTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketTagsResponse = PutBucketTagsResponse;
class PutObjectTaggingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            body: PutObjectTaggingRequestBody,
        };
    }
}
exports.PutObjectTaggingRequest = PutObjectTaggingRequest;
class PutObjectTaggingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutObjectTaggingResponse = PutObjectTaggingResponse;
class SelectObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            filter: 'Filter',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            filter: SelectObjectRequestFilter,
            body: SelectObjectRequestBody,
        };
    }
}
exports.SelectObjectRequest = SelectObjectRequest;
class SelectObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.SelectObjectResponse = SelectObjectResponse;
class PutBucketCORSRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketCORSRequestBody,
        };
    }
}
exports.PutBucketCORSRequest = PutBucketCORSRequest;
class PutBucketCORSResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketCORSResponse = PutBucketCORSResponse;
class PutBucketRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            body: 'Body',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            body: PutBucketRequestBody,
            header: PutBucketRequestHeader,
        };
    }
}
exports.PutBucketRequest = PutBucketRequest;
class PutBucketResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketResponse = PutBucketResponse;
class ListMultipartUploadsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            filter: ListMultipartUploadsRequestFilter,
        };
    }
}
exports.ListMultipartUploadsRequest = ListMultipartUploadsRequest;
class ListMultipartUploadsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            listMultipartUploadsResult: 'ListMultipartUploadsResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            listMultipartUploadsResult: ListMultipartUploadsResponseListMultipartUploadsResult,
        };
    }
}
exports.ListMultipartUploadsResponse = ListMultipartUploadsResponse;
class GetBucketRequestPaymentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketRequestPaymentRequest = GetBucketRequestPaymentRequest;
class GetBucketRequestPaymentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            requestPaymentConfiguration: 'RequestPaymentConfiguration',
        };
    }
    static types() {
        return {
            requestId: 'string',
            requestPaymentConfiguration: GetBucketRequestPaymentResponseRequestPaymentConfiguration,
        };
    }
}
exports.GetBucketRequestPaymentResponse = GetBucketRequestPaymentResponse;
class GetBucketEncryptionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketEncryptionRequest = GetBucketEncryptionRequest;
class GetBucketEncryptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            serverSideEncryptionRule: 'ServerSideEncryptionRule',
        };
    }
    static types() {
        return {
            requestId: 'string',
            serverSideEncryptionRule: GetBucketEncryptionResponseServerSideEncryptionRule,
        };
    }
}
exports.GetBucketEncryptionResponse = GetBucketEncryptionResponse;
class GetBucketTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketTagsRequest = GetBucketTagsRequest;
class GetBucketTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            tagging: 'Tagging',
        };
    }
    static types() {
        return {
            requestId: 'string',
            tagging: GetBucketTagsResponseTagging,
        };
    }
}
exports.GetBucketTagsResponse = GetBucketTagsResponse;
class GetServiceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filter: 'Filter',
        };
    }
    static types() {
        return {
            filter: GetServiceRequestFilter,
        };
    }
}
exports.GetServiceRequest = GetServiceRequest;
class GetServiceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            listAllMyBucketsResult: 'ListAllMyBucketsResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            listAllMyBucketsResult: GetServiceResponseListAllMyBucketsResult,
        };
    }
}
exports.GetServiceResponse = GetServiceResponse;
class DeleteBucketEncryptionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.DeleteBucketEncryptionRequest = DeleteBucketEncryptionRequest;
class DeleteBucketEncryptionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketEncryptionResponse = DeleteBucketEncryptionResponse;
class DeleteBucketTagsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            filter: DeleteBucketTagsRequestFilter,
        };
    }
}
exports.DeleteBucketTagsRequest = DeleteBucketTagsRequest;
class DeleteBucketTagsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketTagsResponse = DeleteBucketTagsResponse;
class GetBucketWebsiteRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketWebsiteRequest = GetBucketWebsiteRequest;
class GetBucketWebsiteResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            websiteConfiguration: 'WebsiteConfiguration',
        };
    }
    static types() {
        return {
            requestId: 'string',
            websiteConfiguration: GetBucketWebsiteResponseWebsiteConfiguration,
        };
    }
}
exports.GetBucketWebsiteResponse = GetBucketWebsiteResponse;
class DeleteLiveChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
        };
    }
}
exports.DeleteLiveChannelRequest = DeleteLiveChannelRequest;
class DeleteLiveChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteLiveChannelResponse = DeleteLiveChannelResponse;
class GetBucketLocationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketLocationRequest = GetBucketLocationRequest;
class GetBucketLocationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            locationConstraint: 'LocationConstraint',
        };
    }
    static types() {
        return {
            requestId: 'string',
            locationConstraint: 'string',
        };
    }
}
exports.GetBucketLocationResponse = GetBucketLocationResponse;
class ListLiveChannelRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            filter: ListLiveChannelRequestFilter,
        };
    }
}
exports.ListLiveChannelRequest = ListLiveChannelRequest;
class ListLiveChannelResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            listLiveChannelResult: 'ListLiveChannelResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            listLiveChannelResult: ListLiveChannelResponseListLiveChannelResult,
        };
    }
}
exports.ListLiveChannelResponse = ListLiveChannelResponse;
class GetObjectMetaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.GetObjectMetaRequest = GetObjectMetaRequest;
class GetObjectMetaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            eTag: 'etag',
            contentLength: 'content-length',
            lastModified: 'last-modified',
        };
    }
    static types() {
        return {
            requestId: 'string',
            eTag: 'string',
            contentLength: 'string',
            lastModified: 'string',
        };
    }
}
exports.GetObjectMetaResponse = GetObjectMetaResponse;
class GetBucketAclRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketAclRequest = GetBucketAclRequest;
class GetBucketAclResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            accessControlPolicy: 'AccessControlPolicy',
        };
    }
    static types() {
        return {
            requestId: 'string',
            accessControlPolicy: GetBucketAclResponseAccessControlPolicy,
        };
    }
}
exports.GetBucketAclResponse = GetBucketAclResponse;
class ListPartsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            filter: ListPartsRequestFilter,
        };
    }
}
exports.ListPartsRequest = ListPartsRequest;
class ListPartsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            listPartsResult: 'ListPartsResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            listPartsResult: ListPartsResponseListPartsResult,
        };
    }
}
exports.ListPartsResponse = ListPartsResponse;
class GetLiveChannelHistoryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
            filter: GetLiveChannelHistoryRequestFilter,
        };
    }
}
exports.GetLiveChannelHistoryRequest = GetLiveChannelHistoryRequest;
class GetLiveChannelHistoryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            liveChannelHistory: 'LiveChannelHistory',
        };
    }
    static types() {
        return {
            requestId: 'string',
            liveChannelHistory: GetLiveChannelHistoryResponseLiveChannelHistory,
        };
    }
}
exports.GetLiveChannelHistoryResponse = GetLiveChannelHistoryResponse;
class GetBucketRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            filter: GetBucketRequestFilter,
        };
    }
}
exports.GetBucketRequest = GetBucketRequest;
class GetBucketResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            listBucketResult: 'ListBucketResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            listBucketResult: GetBucketResponseListBucketResult,
        };
    }
}
exports.GetBucketResponse = GetBucketResponse;
class GetLiveChannelInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
        };
    }
}
exports.GetLiveChannelInfoRequest = GetLiveChannelInfoRequest;
class GetLiveChannelInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            liveChannelConfiguration: 'LiveChannelConfiguration',
        };
    }
    static types() {
        return {
            requestId: 'string',
            liveChannelConfiguration: GetLiveChannelInfoResponseLiveChannelConfiguration,
        };
    }
}
exports.GetLiveChannelInfoResponse = GetLiveChannelInfoResponse;
class GetLiveChannelStatRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
            filter: GetLiveChannelStatRequestFilter,
        };
    }
}
exports.GetLiveChannelStatRequest = GetLiveChannelStatRequest;
class GetLiveChannelStatResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            liveChannelStat: 'LiveChannelStat',
        };
    }
    static types() {
        return {
            requestId: 'string',
            liveChannelStat: GetLiveChannelStatResponseLiveChannelStat,
        };
    }
}
exports.GetLiveChannelStatResponse = GetLiveChannelStatResponse;
class DeleteObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.DeleteObjectRequest = DeleteObjectRequest;
class DeleteObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteObjectResponse = DeleteObjectResponse;
class AbortMultipartUploadRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            filter: AbortMultipartUploadRequestFilter,
        };
    }
}
exports.AbortMultipartUploadRequest = AbortMultipartUploadRequest;
class AbortMultipartUploadResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.AbortMultipartUploadResponse = AbortMultipartUploadResponse;
class AppendObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            userMeta: 'UserMeta',
            body: 'body',
            filter: 'Filter',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            userMeta: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: 'Readable',
            filter: AppendObjectRequestFilter,
            header: AppendObjectRequestHeader,
        };
    }
}
exports.AppendObjectRequest = AppendObjectRequest;
class AppendObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            nextAppendPosition: 'x-oss-next-append-position',
            hashCrc64ecma: 'x-oss-hash-crc64ecma',
        };
    }
    static types() {
        return {
            requestId: 'string',
            nextAppendPosition: 'string',
            hashCrc64ecma: 'string',
        };
    }
}
exports.AppendObjectResponse = AppendObjectResponse;
class UploadPartCopyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            filter: 'Filter',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            filter: UploadPartCopyRequestFilter,
            header: UploadPartCopyRequestHeader,
        };
    }
}
exports.UploadPartCopyRequest = UploadPartCopyRequest;
class UploadPartCopyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            copyPartResult: 'CopyPartResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            copyPartResult: UploadPartCopyResponseCopyPartResult,
        };
    }
}
exports.UploadPartCopyResponse = UploadPartCopyResponse;
class GetVodPlaylistRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
            filter: GetVodPlaylistRequestFilter,
        };
    }
}
exports.GetVodPlaylistRequest = GetVodPlaylistRequest;
class GetVodPlaylistResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.GetVodPlaylistResponse = GetVodPlaylistResponse;
class DeleteBucketCORSRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.DeleteBucketCORSRequest = DeleteBucketCORSRequest;
class DeleteBucketCORSResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketCORSResponse = DeleteBucketCORSResponse;
class GetObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            header: GetObjectRequestHeader,
        };
    }
}
exports.GetObjectRequest = GetObjectRequest;
class GetObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            objectType: 'x-oss-object-type',
            serverSideEncryption: 'x-oss-server-side-encryption',
            taggingCount: 'x-oss-tagging-count',
            restore: 'x-oss-restore',
            body: 'body',
        };
    }
    static types() {
        return {
            requestId: 'string',
            objectType: 'string',
            serverSideEncryption: 'string',
            taggingCount: 'string',
            restore: 'string',
            body: 'Readable',
        };
    }
}
exports.GetObjectResponse = GetObjectResponse;
class UploadPartRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            body: 'body',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            body: 'Readable',
            filter: UploadPartRequestFilter,
        };
    }
}
exports.UploadPartRequest = UploadPartRequest;
class UploadPartResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.UploadPartResponse = UploadPartResponse;
class GetBucketCORSRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketCORSRequest = GetBucketCORSRequest;
class GetBucketCORSResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            cORSConfiguration: 'CORSConfiguration',
        };
    }
    static types() {
        return {
            requestId: 'string',
            cORSConfiguration: GetBucketCORSResponseCORSConfiguration,
        };
    }
}
exports.GetBucketCORSResponse = GetBucketCORSResponse;
class CopyObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            destObjectName: 'DestObjectName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            destObjectName: 'string',
            header: CopyObjectRequestHeader,
        };
    }
}
exports.CopyObjectRequest = CopyObjectRequest;
class CopyObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            copyObjectResult: 'CopyObjectResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            copyObjectResult: CopyObjectResponseCopyObjectResult,
        };
    }
}
exports.CopyObjectResponse = CopyObjectResponse;
class GetObjectTaggingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.GetObjectTaggingRequest = GetObjectTaggingRequest;
class GetObjectTaggingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            tagging: 'Tagging',
        };
    }
    static types() {
        return {
            requestId: 'string',
            tagging: GetObjectTaggingResponseTagging,
        };
    }
}
exports.GetObjectTaggingResponse = GetObjectTaggingResponse;
class DeleteBucketLifecycleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.DeleteBucketLifecycleRequest = DeleteBucketLifecycleRequest;
class DeleteBucketLifecycleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketLifecycleResponse = DeleteBucketLifecycleResponse;
class DeleteBucketLoggingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.DeleteBucketLoggingRequest = DeleteBucketLoggingRequest;
class DeleteBucketLoggingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketLoggingResponse = DeleteBucketLoggingResponse;
class DeleteBucketWebsiteRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.DeleteBucketWebsiteRequest = DeleteBucketWebsiteRequest;
class DeleteBucketWebsiteResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketWebsiteResponse = DeleteBucketWebsiteResponse;
class GetSymlinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.GetSymlinkRequest = GetSymlinkRequest;
class GetSymlinkResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            symlinkTarget: 'x-oss-symlink-target',
        };
    }
    static types() {
        return {
            requestId: 'string',
            symlinkTarget: 'string',
        };
    }
}
exports.GetSymlinkResponse = GetSymlinkResponse;
class GetBucketLifecycleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketLifecycleRequest = GetBucketLifecycleRequest;
class GetBucketLifecycleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            lifecycleConfiguration: 'LifecycleConfiguration',
        };
    }
    static types() {
        return {
            requestId: 'string',
            lifecycleConfiguration: GetBucketLifecycleResponseLifecycleConfiguration,
        };
    }
}
exports.GetBucketLifecycleResponse = GetBucketLifecycleResponse;
class PutSymlinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            header: PutSymlinkRequestHeader,
        };
    }
}
exports.PutSymlinkRequest = PutSymlinkRequest;
class PutSymlinkResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutSymlinkResponse = PutSymlinkResponse;
class GetBucketRefererRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketRefererRequest = GetBucketRefererRequest;
class GetBucketRefererResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            refererConfiguration: 'RefererConfiguration',
        };
    }
    static types() {
        return {
            requestId: 'string',
            refererConfiguration: GetBucketRefererResponseRefererConfiguration,
        };
    }
}
exports.GetBucketRefererResponse = GetBucketRefererResponse;
class CallbackRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.CallbackRequest = CallbackRequest;
class CallbackResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.CallbackResponse = CallbackResponse;
class GetBucketLoggingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketLoggingRequest = GetBucketLoggingRequest;
class GetBucketLoggingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            bucketLoggingStatus: 'BucketLoggingStatus',
        };
    }
    static types() {
        return {
            requestId: 'string',
            bucketLoggingStatus: GetBucketLoggingResponseBucketLoggingStatus,
        };
    }
}
exports.GetBucketLoggingResponse = GetBucketLoggingResponse;
class PutObjectAclRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            header: PutObjectAclRequestHeader,
        };
    }
}
exports.PutObjectAclRequest = PutObjectAclRequest;
class PutObjectAclResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutObjectAclResponse = PutObjectAclResponse;
class GetBucketInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.GetBucketInfoRequest = GetBucketInfoRequest;
class GetBucketInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            bucketInfo: 'BucketInfo',
        };
    }
    static types() {
        return {
            requestId: 'string',
            bucketInfo: GetBucketInfoResponseBucketInfo,
        };
    }
}
exports.GetBucketInfoResponse = GetBucketInfoResponse;
class PutLiveChannelStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
            filter: PutLiveChannelStatusRequestFilter,
        };
    }
}
exports.PutLiveChannelStatusRequest = PutLiveChannelStatusRequest;
class PutLiveChannelStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutLiveChannelStatusResponse = PutLiveChannelStatusResponse;
class InitiateMultipartUploadRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            filter: 'Filter',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            filter: InitiateMultipartUploadRequestFilter,
            header: InitiateMultipartUploadRequestHeader,
        };
    }
}
exports.InitiateMultipartUploadRequest = InitiateMultipartUploadRequest;
class InitiateMultipartUploadResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            initiateMultipartUploadResult: 'InitiateMultipartUploadResult',
        };
    }
    static types() {
        return {
            requestId: 'string',
            initiateMultipartUploadResult: InitiateMultipartUploadResponseInitiateMultipartUploadResult,
        };
    }
}
exports.InitiateMultipartUploadResponse = InitiateMultipartUploadResponse;
class OptionObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            header: OptionObjectRequestHeader,
        };
    }
}
exports.OptionObjectRequest = OptionObjectRequest;
class OptionObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            accessControlAllowOrigin: 'access-control-allow-origin',
            accessControlAllowMethods: 'access-control-allow-methods',
            accessControlAllowHeaders: 'access-control-allow-headers',
            accessControlExposeHeaders: 'access-control-expose-headers',
            accessControlMaxAge: 'access-control-max-age',
        };
    }
    static types() {
        return {
            requestId: 'string',
            accessControlAllowOrigin: 'string',
            accessControlAllowMethods: 'string',
            accessControlAllowHeaders: 'string',
            accessControlExposeHeaders: 'string',
            accessControlMaxAge: 'string',
        };
    }
}
exports.OptionObjectResponse = OptionObjectResponse;
class PostVodPlaylistRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            channelName: 'ChannelName',
            playlistName: 'PlaylistName',
            filter: 'Filter',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            channelName: 'string',
            playlistName: 'string',
            filter: PostVodPlaylistRequestFilter,
        };
    }
}
exports.PostVodPlaylistRequest = PostVodPlaylistRequest;
class PostVodPlaylistResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PostVodPlaylistResponse = PostVodPlaylistResponse;
class PostObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            header: 'header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            header: PostObjectRequestHeader,
        };
    }
}
exports.PostObjectRequest = PostObjectRequest;
class PostObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            postResponse: 'PostResponse',
        };
    }
    static types() {
        return {
            postResponse: PostObjectResponsePostResponse,
        };
    }
}
exports.PostObjectResponse = PostObjectResponse;
class HeadObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            header: HeadObjectRequestHeader,
        };
    }
}
exports.HeadObjectRequest = HeadObjectRequest;
class HeadObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            userMeta: 'usermeta',
            serverSideEncryption: 'x-oss-server-side-encryption',
            serverSideEncryptionKeyId: 'x-oss-server-side-encryption-key-id',
            storageClass: 'x-oss-storage-class',
            objectType: 'x-oss-object-type',
            nextAppendPosition: 'x-oss-next-append-position',
            hashCrc64ecma: 'x-oss-hash-crc64ecma',
            expiration: 'x-oss-expiration',
            restore: 'x-oss-restore',
            processStatus: 'x-oss-process-status',
            requestCharged: 'x-oss-request-charged',
            contentMd5: 'content-md5',
            lastModified: 'last-modified',
            accessControlAllowOrigin: 'access-control-allow-origin',
            accessControlAllowMethods: 'access-control-allow-methods',
            accessControlMaxAge: 'access-control-max-age',
            accessControlAllowHeaders: 'access-control-allow-headers',
            accessControlExposeHeaders: 'access-control-expose-headers',
            taggingCount: 'x-oss-tagging-count',
        };
    }
    static types() {
        return {
            requestId: 'string',
            userMeta: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serverSideEncryption: 'string',
            serverSideEncryptionKeyId: 'string',
            storageClass: 'string',
            objectType: 'string',
            nextAppendPosition: 'string',
            hashCrc64ecma: 'string',
            expiration: 'string',
            restore: 'string',
            processStatus: 'string',
            requestCharged: 'string',
            contentMd5: 'string',
            lastModified: 'string',
            accessControlAllowOrigin: 'string',
            accessControlAllowMethods: 'string',
            accessControlMaxAge: 'string',
            accessControlAllowHeaders: 'string',
            accessControlExposeHeaders: 'string',
            taggingCount: 'string',
        };
    }
}
exports.HeadObjectResponse = HeadObjectResponse;
class DeleteObjectTaggingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.DeleteObjectTaggingRequest = DeleteObjectTaggingRequest;
class DeleteObjectTaggingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteObjectTaggingResponse = DeleteObjectTaggingResponse;
class RestoreObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.RestoreObjectRequest = RestoreObjectRequest;
class RestoreObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RestoreObjectResponse = RestoreObjectResponse;
class GetObjectAclRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
        };
    }
}
exports.GetObjectAclRequest = GetObjectAclRequest;
class GetObjectAclResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            accessControlPolicy: 'AccessControlPolicy',
        };
    }
    static types() {
        return {
            requestId: 'string',
            accessControlPolicy: GetObjectAclResponseAccessControlPolicy,
        };
    }
}
exports.GetObjectAclResponse = GetObjectAclResponse;
class PutBucketAclRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            header: PutBucketAclRequestHeader,
        };
    }
}
exports.PutBucketAclRequest = PutBucketAclRequest;
class PutBucketAclResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.PutBucketAclResponse = PutBucketAclResponse;
class DeleteBucketRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
        };
    }
    static types() {
        return {
            bucketName: 'string',
        };
    }
}
exports.DeleteBucketRequest = DeleteBucketRequest;
class DeleteBucketResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeleteBucketResponse = DeleteBucketResponse;
class PutObjectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketName: 'BucketName',
            objectName: 'ObjectName',
            userMeta: 'UserMeta',
            body: 'body',
            header: 'Header',
        };
    }
    static types() {
        return {
            bucketName: 'string',
            objectName: 'string',
            userMeta: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            body: 'Readable',
            header: PutObjectRequestHeader,
        };
    }
}
exports.PutObjectRequest = PutObjectRequest;
class PutObjectResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'x-oss-request-id',
            hashCrc64ecma: 'x-oss-hash-crc64ecma',
            serverTime: 'x-oss-server-time',
            bucketVersion: 'x-oss-bucket-version',
        };
    }
    static types() {
        return {
            requestId: 'string',
            hashCrc64ecma: 'string',
            serverTime: 'string',
            bucketVersion: 'string',
        };
    }
}
exports.PutObjectResponse = PutObjectResponse;
class PutBucketLifecycleRequestBodyLifecycleConfigurationRuleExpiration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            days: 'Days',
            createdBeforeDate: 'CreatedBeforeDate',
        };
    }
    static types() {
        return {
            days: 'number',
            createdBeforeDate: 'string',
        };
    }
}
exports.PutBucketLifecycleRequestBodyLifecycleConfigurationRuleExpiration = PutBucketLifecycleRequestBodyLifecycleConfigurationRuleExpiration;
class PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTransition extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            days: 'Days',
            storageClass: 'StorageClass',
        };
    }
    static types() {
        return {
            days: 'number',
            storageClass: 'string',
        };
    }
}
exports.PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTransition = PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTransition;
class PutBucketLifecycleRequestBodyLifecycleConfigurationRuleAbortMultipartUpload extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            days: 'Days',
            createdBeforeDate: 'CreatedBeforeDate',
        };
    }
    static types() {
        return {
            days: 'number',
            createdBeforeDate: 'string',
        };
    }
}
exports.PutBucketLifecycleRequestBodyLifecycleConfigurationRuleAbortMultipartUpload = PutBucketLifecycleRequestBodyLifecycleConfigurationRuleAbortMultipartUpload;
class PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTag = PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTag;
class PutBucketLifecycleRequestBodyLifecycleConfigurationRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expiration: 'Expiration',
            transition: 'Transition',
            abortMultipartUpload: 'AbortMultipartUpload',
            tag: 'Tag',
            iD: 'ID',
            prefix: 'Prefix',
            status: 'Status',
        };
    }
    static types() {
        return {
            expiration: PutBucketLifecycleRequestBodyLifecycleConfigurationRuleExpiration,
            transition: PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTransition,
            abortMultipartUpload: PutBucketLifecycleRequestBodyLifecycleConfigurationRuleAbortMultipartUpload,
            tag: PutBucketLifecycleRequestBodyLifecycleConfigurationRuleTag,
            iD: 'string',
            prefix: 'string',
            status: 'string',
        };
    }
}
exports.PutBucketLifecycleRequestBodyLifecycleConfigurationRule = PutBucketLifecycleRequestBodyLifecycleConfigurationRule;
class PutBucketLifecycleRequestBodyLifecycleConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            rule: 'Rule',
        };
    }
    static types() {
        return {
            rule: { 'type': 'array', 'itemType': PutBucketLifecycleRequestBodyLifecycleConfigurationRule },
        };
    }
}
exports.PutBucketLifecycleRequestBodyLifecycleConfiguration = PutBucketLifecycleRequestBodyLifecycleConfiguration;
class PutBucketLifecycleRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            lifecycleConfiguration: 'LifecycleConfiguration',
        };
    }
    static types() {
        return {
            lifecycleConfiguration: PutBucketLifecycleRequestBodyLifecycleConfiguration,
        };
    }
}
exports.PutBucketLifecycleRequestBody = PutBucketLifecycleRequestBody;
class DeleteMultipleObjectsRequestBodyDeleteObject extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
        };
    }
    static types() {
        return {
            key: 'string',
        };
    }
}
exports.DeleteMultipleObjectsRequestBodyDeleteObject = DeleteMultipleObjectsRequestBodyDeleteObject;
class DeleteMultipleObjectsRequestBodyDelete extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            object: 'Object',
            quiet: 'Quiet',
        };
    }
    static types() {
        return {
            object: { 'type': 'array', 'itemType': DeleteMultipleObjectsRequestBodyDeleteObject },
            quiet: 'string',
        };
    }
}
exports.DeleteMultipleObjectsRequestBodyDelete = DeleteMultipleObjectsRequestBodyDelete;
class DeleteMultipleObjectsRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            delete: 'Delete',
        };
    }
    static types() {
        return {
            delete: DeleteMultipleObjectsRequestBodyDelete,
        };
    }
}
exports.DeleteMultipleObjectsRequestBody = DeleteMultipleObjectsRequestBody;
class DeleteMultipleObjectsRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            encodingType: 'Encoding-type',
            contentLength: 'Content-Length',
            contentMD5: 'Content-MD5',
        };
    }
    static types() {
        return {
            encodingType: 'string',
            contentLength: 'string',
            contentMD5: 'string',
        };
    }
}
exports.DeleteMultipleObjectsRequestHeader = DeleteMultipleObjectsRequestHeader;
class DeleteMultipleObjectsResponseDeleteResultDeleted extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
        };
    }
    static types() {
        return {
            key: 'string',
        };
    }
}
exports.DeleteMultipleObjectsResponseDeleteResultDeleted = DeleteMultipleObjectsResponseDeleteResultDeleted;
class DeleteMultipleObjectsResponseDeleteResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            quiet: 'Quiet',
            encodingType: 'EncodingType',
            deleted: 'Deleted',
        };
    }
    static types() {
        return {
            quiet: 'string',
            encodingType: 'string',
            deleted: { 'type': 'array', 'itemType': DeleteMultipleObjectsResponseDeleteResultDeleted },
        };
    }
}
exports.DeleteMultipleObjectsResponseDeleteResult = DeleteMultipleObjectsResponseDeleteResult;
class PutBucketRefererRequestBodyRefererConfigurationRefererList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            referer: 'Referer',
        };
    }
    static types() {
        return {
            referer: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.PutBucketRefererRequestBodyRefererConfigurationRefererList = PutBucketRefererRequestBodyRefererConfigurationRefererList;
class PutBucketRefererRequestBodyRefererConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            refererList: 'RefererList',
            allowEmptyReferer: 'AllowEmptyReferer',
        };
    }
    static types() {
        return {
            refererList: PutBucketRefererRequestBodyRefererConfigurationRefererList,
            allowEmptyReferer: 'boolean',
        };
    }
}
exports.PutBucketRefererRequestBodyRefererConfiguration = PutBucketRefererRequestBodyRefererConfiguration;
class PutBucketRefererRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            refererConfiguration: 'RefererConfiguration',
        };
    }
    static types() {
        return {
            refererConfiguration: PutBucketRefererRequestBodyRefererConfiguration,
        };
    }
}
exports.PutBucketRefererRequestBody = PutBucketRefererRequestBody;
class PutBucketWebsiteRequestBodyWebsiteConfigurationIndexDocument extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            suffix: 'Suffix',
        };
    }
    static types() {
        return {
            suffix: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationIndexDocument = PutBucketWebsiteRequestBodyWebsiteConfigurationIndexDocument;
class PutBucketWebsiteRequestBodyWebsiteConfigurationErrorDocument extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
        };
    }
    static types() {
        return {
            key: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationErrorDocument = PutBucketWebsiteRequestBodyWebsiteConfigurationErrorDocument;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            equals: 'Equals',
        };
    }
    static types() {
        return {
            key: 'string',
            equals: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleCondition extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            includeHeader: 'IncludeHeader',
            keyPrefixEquals: 'KeyPrefixEquals',
            httpErrorCodeReturnedEquals: 'HttpErrorCodeReturnedEquals',
        };
    }
    static types() {
        return {
            includeHeader: PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader,
            keyPrefixEquals: 'string',
            httpErrorCodeReturnedEquals: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleCondition = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleCondition;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            set: 'Set',
            passAll: 'PassAll',
            pass: 'Pass',
            remove: 'Remove',
        };
    }
    static types() {
        return {
            set: PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet,
            passAll: 'boolean',
            pass: 'string',
            remove: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirect extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mirrorHeaders: 'MirrorHeaders',
            redirectType: 'RedirectType',
            passQueryString: 'PassQueryString',
            mirrorURL: 'MirrorURL',
            mirrorPassQueryString: 'MirrorPassQueryString',
            mirrorFollowRedirect: 'MirrorFollowRedirect',
            mirrorCheckMd5: 'MirrorCheckMd5',
            protocol: 'Protocol',
            hostName: 'HostName',
            httpRedirectCode: 'HttpRedirectCode',
            replaceKeyPrefixWith: 'ReplaceKeyPrefixWith',
            replaceKeyWith: 'ReplaceKeyWith',
        };
    }
    static types() {
        return {
            mirrorHeaders: PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders,
            redirectType: 'string',
            passQueryString: 'boolean',
            mirrorURL: 'string',
            mirrorPassQueryString: 'boolean',
            mirrorFollowRedirect: 'boolean',
            mirrorCheckMd5: 'boolean',
            protocol: 'string',
            hostName: 'string',
            httpRedirectCode: 'string',
            replaceKeyPrefixWith: 'string',
            replaceKeyWith: 'string',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirect = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirect;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            condition: 'Condition',
            redirect: 'Redirect',
            ruleNumber: 'RuleNumber',
        };
    }
    static types() {
        return {
            condition: PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleCondition,
            redirect: PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRuleRedirect,
            ruleNumber: 'number',
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRule = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRule;
class PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            routingRule: 'RoutingRule',
        };
    }
    static types() {
        return {
            routingRule: { 'type': 'array', 'itemType': PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRulesRoutingRule },
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRules = PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRules;
class PutBucketWebsiteRequestBodyWebsiteConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            indexDocument: 'IndexDocument',
            errorDocument: 'ErrorDocument',
            routingRules: 'RoutingRules',
        };
    }
    static types() {
        return {
            indexDocument: PutBucketWebsiteRequestBodyWebsiteConfigurationIndexDocument,
            errorDocument: PutBucketWebsiteRequestBodyWebsiteConfigurationErrorDocument,
            routingRules: PutBucketWebsiteRequestBodyWebsiteConfigurationRoutingRules,
        };
    }
}
exports.PutBucketWebsiteRequestBodyWebsiteConfiguration = PutBucketWebsiteRequestBodyWebsiteConfiguration;
class PutBucketWebsiteRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            websiteConfiguration: 'WebsiteConfiguration',
        };
    }
    static types() {
        return {
            websiteConfiguration: PutBucketWebsiteRequestBodyWebsiteConfiguration,
        };
    }
}
exports.PutBucketWebsiteRequestBody = PutBucketWebsiteRequestBody;
class CompleteMultipartUploadRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            uploadId: 'uploadId',
            encodingType: 'Encoding-type',
        };
    }
    static types() {
        return {
            uploadId: 'string',
            encodingType: 'string',
        };
    }
}
exports.CompleteMultipartUploadRequestFilter = CompleteMultipartUploadRequestFilter;
class CompleteMultipartUploadRequestBodyCompleteMultipartUploadPart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partNumber: 'PartNumber',
            eTag: 'ETag',
        };
    }
    static types() {
        return {
            partNumber: 'string',
            eTag: 'string',
        };
    }
}
exports.CompleteMultipartUploadRequestBodyCompleteMultipartUploadPart = CompleteMultipartUploadRequestBodyCompleteMultipartUploadPart;
class CompleteMultipartUploadRequestBodyCompleteMultipartUpload extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            part: 'Part',
        };
    }
    static types() {
        return {
            part: { 'type': 'array', 'itemType': CompleteMultipartUploadRequestBodyCompleteMultipartUploadPart },
        };
    }
}
exports.CompleteMultipartUploadRequestBodyCompleteMultipartUpload = CompleteMultipartUploadRequestBodyCompleteMultipartUpload;
class CompleteMultipartUploadRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            completeMultipartUpload: 'CompleteMultipartUpload',
        };
    }
    static types() {
        return {
            completeMultipartUpload: CompleteMultipartUploadRequestBodyCompleteMultipartUpload,
        };
    }
}
exports.CompleteMultipartUploadRequestBody = CompleteMultipartUploadRequestBody;
class CompleteMultipartUploadResponseCompleteMultipartUploadResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
            eTag: 'ETag',
            location: 'Location',
            key: 'Key',
            encodingType: 'EncodingType',
        };
    }
    static types() {
        return {
            bucket: 'string',
            eTag: 'string',
            location: 'string',
            key: 'string',
            encodingType: 'string',
        };
    }
}
exports.CompleteMultipartUploadResponseCompleteMultipartUploadResult = CompleteMultipartUploadResponseCompleteMultipartUploadResult;
class PutBucketLoggingRequestBodyBucketLoggingStatusLoggingEnabled extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetBucket: 'TargetBucket',
            targetPrefix: 'TargetPrefix',
        };
    }
    static types() {
        return {
            targetBucket: 'string',
            targetPrefix: 'string',
        };
    }
}
exports.PutBucketLoggingRequestBodyBucketLoggingStatusLoggingEnabled = PutBucketLoggingRequestBodyBucketLoggingStatusLoggingEnabled;
class PutBucketLoggingRequestBodyBucketLoggingStatus extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            loggingEnabled: 'LoggingEnabled',
        };
    }
    static types() {
        return {
            loggingEnabled: PutBucketLoggingRequestBodyBucketLoggingStatusLoggingEnabled,
        };
    }
}
exports.PutBucketLoggingRequestBodyBucketLoggingStatus = PutBucketLoggingRequestBodyBucketLoggingStatus;
class PutBucketLoggingRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucketLoggingStatus: 'BucketLoggingStatus',
        };
    }
    static types() {
        return {
            bucketLoggingStatus: PutBucketLoggingRequestBodyBucketLoggingStatus,
        };
    }
}
exports.PutBucketLoggingRequestBody = PutBucketLoggingRequestBody;
class PutBucketRequestPaymentRequestBodyRequestPaymentConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            payer: 'Payer',
        };
    }
    static types() {
        return {
            payer: 'string',
        };
    }
}
exports.PutBucketRequestPaymentRequestBodyRequestPaymentConfiguration = PutBucketRequestPaymentRequestBodyRequestPaymentConfiguration;
class PutBucketRequestPaymentRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestPaymentConfiguration: 'RequestPaymentConfiguration',
        };
    }
    static types() {
        return {
            requestPaymentConfiguration: PutBucketRequestPaymentRequestBodyRequestPaymentConfiguration,
        };
    }
}
exports.PutBucketRequestPaymentRequestBody = PutBucketRequestPaymentRequestBody;
class PutBucketEncryptionRequestBodyServerSideEncryptionRuleApplyServerSideEncryptionByDefault extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            sSEAlgorithm: 'SSEAlgorithm',
            kMSMasterKeyID: 'KMSMasterKeyID',
        };
    }
    static types() {
        return {
            sSEAlgorithm: 'string',
            kMSMasterKeyID: 'string',
        };
    }
}
exports.PutBucketEncryptionRequestBodyServerSideEncryptionRuleApplyServerSideEncryptionByDefault = PutBucketEncryptionRequestBodyServerSideEncryptionRuleApplyServerSideEncryptionByDefault;
class PutBucketEncryptionRequestBodyServerSideEncryptionRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyServerSideEncryptionByDefault: 'ApplyServerSideEncryptionByDefault',
        };
    }
    static types() {
        return {
            applyServerSideEncryptionByDefault: PutBucketEncryptionRequestBodyServerSideEncryptionRuleApplyServerSideEncryptionByDefault,
        };
    }
}
exports.PutBucketEncryptionRequestBodyServerSideEncryptionRule = PutBucketEncryptionRequestBodyServerSideEncryptionRule;
class PutBucketEncryptionRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            serverSideEncryptionRule: 'ServerSideEncryptionRule',
        };
    }
    static types() {
        return {
            serverSideEncryptionRule: PutBucketEncryptionRequestBodyServerSideEncryptionRule,
        };
    }
}
exports.PutBucketEncryptionRequestBody = PutBucketEncryptionRequestBody;
class PutLiveChannelRequestBodyLiveChannelConfigurationTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'Type',
            fragDuration: 'FragDuration',
            fragCount: 'FragCount',
            playlistName: 'PlaylistName',
        };
    }
    static types() {
        return {
            type: 'string',
            fragDuration: 'string',
            fragCount: 'string',
            playlistName: 'string',
        };
    }
}
exports.PutLiveChannelRequestBodyLiveChannelConfigurationTarget = PutLiveChannelRequestBodyLiveChannelConfigurationTarget;
class PutLiveChannelRequestBodyLiveChannelConfigurationSnapshot extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            roleName: 'RoleName',
            destBucket: 'DestBucket',
            notifyTopic: 'NotifyTopic',
            interval: 'Interval',
        };
    }
    static types() {
        return {
            roleName: 'string',
            destBucket: 'string',
            notifyTopic: 'string',
            interval: 'string',
        };
    }
}
exports.PutLiveChannelRequestBodyLiveChannelConfigurationSnapshot = PutLiveChannelRequestBodyLiveChannelConfigurationSnapshot;
class PutLiveChannelRequestBodyLiveChannelConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            target: 'Target',
            snapshot: 'Snapshot',
            description: 'Description',
            status: 'Status',
        };
    }
    static types() {
        return {
            target: PutLiveChannelRequestBodyLiveChannelConfigurationTarget,
            snapshot: PutLiveChannelRequestBodyLiveChannelConfigurationSnapshot,
            description: 'string',
            status: 'string',
        };
    }
}
exports.PutLiveChannelRequestBodyLiveChannelConfiguration = PutLiveChannelRequestBodyLiveChannelConfiguration;
class PutLiveChannelRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            liveChannelConfiguration: 'LiveChannelConfiguration',
        };
    }
    static types() {
        return {
            liveChannelConfiguration: PutLiveChannelRequestBodyLiveChannelConfiguration,
        };
    }
}
exports.PutLiveChannelRequestBody = PutLiveChannelRequestBody;
class PutLiveChannelResponseCreateLiveChannelResultPublishUrls extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.PutLiveChannelResponseCreateLiveChannelResultPublishUrls = PutLiveChannelResponseCreateLiveChannelResultPublishUrls;
class PutLiveChannelResponseCreateLiveChannelResultPlayUrls extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.PutLiveChannelResponseCreateLiveChannelResultPlayUrls = PutLiveChannelResponseCreateLiveChannelResultPlayUrls;
class PutLiveChannelResponseCreateLiveChannelResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            publishUrls: 'PublishUrls',
            playUrls: 'PlayUrls',
        };
    }
    static types() {
        return {
            publishUrls: PutLiveChannelResponseCreateLiveChannelResultPublishUrls,
            playUrls: PutLiveChannelResponseCreateLiveChannelResultPlayUrls,
        };
    }
}
exports.PutLiveChannelResponseCreateLiveChannelResult = PutLiveChannelResponseCreateLiveChannelResult;
class PutBucketTagsRequestBodyTaggingTagSetTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.PutBucketTagsRequestBodyTaggingTagSetTag = PutBucketTagsRequestBodyTaggingTagSetTag;
class PutBucketTagsRequestBodyTaggingTagSet extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': PutBucketTagsRequestBodyTaggingTagSetTag },
        };
    }
}
exports.PutBucketTagsRequestBodyTaggingTagSet = PutBucketTagsRequestBodyTaggingTagSet;
class PutBucketTagsRequestBodyTagging extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagSet: 'TagSet',
        };
    }
    static types() {
        return {
            tagSet: PutBucketTagsRequestBodyTaggingTagSet,
        };
    }
}
exports.PutBucketTagsRequestBodyTagging = PutBucketTagsRequestBodyTagging;
class PutBucketTagsRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagging: 'Tagging',
        };
    }
    static types() {
        return {
            tagging: PutBucketTagsRequestBodyTagging,
        };
    }
}
exports.PutBucketTagsRequestBody = PutBucketTagsRequestBody;
class PutObjectTaggingRequestBodyTaggingTagSetTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.PutObjectTaggingRequestBodyTaggingTagSetTag = PutObjectTaggingRequestBodyTaggingTagSetTag;
class PutObjectTaggingRequestBodyTaggingTagSet extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': PutObjectTaggingRequestBodyTaggingTagSetTag },
        };
    }
}
exports.PutObjectTaggingRequestBodyTaggingTagSet = PutObjectTaggingRequestBodyTaggingTagSet;
class PutObjectTaggingRequestBodyTagging extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagSet: 'TagSet',
        };
    }
    static types() {
        return {
            tagSet: PutObjectTaggingRequestBodyTaggingTagSet,
        };
    }
}
exports.PutObjectTaggingRequestBodyTagging = PutObjectTaggingRequestBodyTagging;
class PutObjectTaggingRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagging: 'Tagging',
        };
    }
    static types() {
        return {
            tagging: PutObjectTaggingRequestBodyTagging,
        };
    }
}
exports.PutObjectTaggingRequestBody = PutObjectTaggingRequestBody;
class SelectObjectRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            porcess: 'x-oss-process',
        };
    }
    static types() {
        return {
            porcess: 'string',
        };
    }
}
exports.SelectObjectRequestFilter = SelectObjectRequestFilter;
class SelectObjectRequestBodySelectRequestInputSerializationCSV extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileHeaderInfo: 'FileHeaderInfo',
            recordDelimiter: 'RecordDelimiter',
            fieldDelimiter: 'FieldDelimiter',
            quoteCharacter: 'QuoteCharacter',
            commentCharacter: 'CommentCharacter',
            range: 'Range',
        };
    }
    static types() {
        return {
            fileHeaderInfo: 'string',
            recordDelimiter: 'string',
            fieldDelimiter: 'string',
            quoteCharacter: 'string',
            commentCharacter: 'string',
            range: 'string',
        };
    }
}
exports.SelectObjectRequestBodySelectRequestInputSerializationCSV = SelectObjectRequestBodySelectRequestInputSerializationCSV;
class SelectObjectRequestBodySelectRequestInputSerialization extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cSV: 'CSV',
            compressionType: 'CompressionType',
        };
    }
    static types() {
        return {
            cSV: SelectObjectRequestBodySelectRequestInputSerializationCSV,
            compressionType: 'string',
        };
    }
}
exports.SelectObjectRequestBodySelectRequestInputSerialization = SelectObjectRequestBodySelectRequestInputSerialization;
class SelectObjectRequestBodySelectRequestOutputSerializationCSV extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recordDelimiter: 'RecordDelimiter',
            fieldDelimiter: 'FieldDelimiter',
        };
    }
    static types() {
        return {
            recordDelimiter: 'string',
            fieldDelimiter: 'string',
        };
    }
}
exports.SelectObjectRequestBodySelectRequestOutputSerializationCSV = SelectObjectRequestBodySelectRequestOutputSerializationCSV;
class SelectObjectRequestBodySelectRequestOutputSerialization extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cSV: 'CSV',
            keepAllColumns: 'KeepAllColumns',
            outputRawData: 'OutputRawData',
            enablePayloadCrc: 'EnablePayloadCrc',
            outputHeader: 'OutputHeader',
        };
    }
    static types() {
        return {
            cSV: SelectObjectRequestBodySelectRequestOutputSerializationCSV,
            keepAllColumns: 'string',
            outputRawData: 'string',
            enablePayloadCrc: 'string',
            outputHeader: 'string',
        };
    }
}
exports.SelectObjectRequestBodySelectRequestOutputSerialization = SelectObjectRequestBodySelectRequestOutputSerialization;
class SelectObjectRequestBodySelectRequestOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            skipPartialDataRecord: 'SkipPartialDataRecord',
            maxSkippedRecordsAllowed: 'MaxSkippedRecordsAllowed',
        };
    }
    static types() {
        return {
            skipPartialDataRecord: 'string',
            maxSkippedRecordsAllowed: 'string',
        };
    }
}
exports.SelectObjectRequestBodySelectRequestOptions = SelectObjectRequestBodySelectRequestOptions;
class SelectObjectRequestBodySelectRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            inputSerialization: 'InputSerialization',
            outputSerialization: 'OutputSerialization',
            options: 'Options',
            expression: 'Expression',
        };
    }
    static types() {
        return {
            inputSerialization: SelectObjectRequestBodySelectRequestInputSerialization,
            outputSerialization: SelectObjectRequestBodySelectRequestOutputSerialization,
            options: SelectObjectRequestBodySelectRequestOptions,
            expression: 'string',
        };
    }
}
exports.SelectObjectRequestBodySelectRequest = SelectObjectRequestBodySelectRequest;
class SelectObjectRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            selectRequest: 'SelectRequest',
        };
    }
    static types() {
        return {
            selectRequest: SelectObjectRequestBodySelectRequest,
        };
    }
}
exports.SelectObjectRequestBody = SelectObjectRequestBody;
class PutBucketCORSRequestBodyCORSConfigurationCORSRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allowedOrigin: 'AllowedOrigin',
            allowedMethod: 'AllowedMethod',
            allowedHeader: 'AllowedHeader',
            exposeHeader: 'ExposeHeader',
            maxAgeSeconds: 'MaxAgeSeconds',
        };
    }
    static types() {
        return {
            allowedOrigin: { 'type': 'array', 'itemType': 'string' },
            allowedMethod: { 'type': 'array', 'itemType': 'string' },
            allowedHeader: { 'type': 'array', 'itemType': 'string' },
            exposeHeader: { 'type': 'array', 'itemType': 'string' },
            maxAgeSeconds: 'string',
        };
    }
}
exports.PutBucketCORSRequestBodyCORSConfigurationCORSRule = PutBucketCORSRequestBodyCORSConfigurationCORSRule;
class PutBucketCORSRequestBodyCORSConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cORSRule: 'CORSRule',
        };
    }
    static types() {
        return {
            cORSRule: { 'type': 'array', 'itemType': PutBucketCORSRequestBodyCORSConfigurationCORSRule },
        };
    }
}
exports.PutBucketCORSRequestBodyCORSConfiguration = PutBucketCORSRequestBodyCORSConfiguration;
class PutBucketCORSRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cORSConfiguration: 'CORSConfiguration',
        };
    }
    static types() {
        return {
            cORSConfiguration: PutBucketCORSRequestBodyCORSConfiguration,
        };
    }
}
exports.PutBucketCORSRequestBody = PutBucketCORSRequestBody;
class PutBucketRequestBodyCreateBucketConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            storageClass: 'StorageClass',
            dataRedundancyType: 'DataRedundancyType',
        };
    }
    static types() {
        return {
            storageClass: 'string',
            dataRedundancyType: 'string',
        };
    }
}
exports.PutBucketRequestBodyCreateBucketConfiguration = PutBucketRequestBodyCreateBucketConfiguration;
class PutBucketRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createBucketConfiguration: 'CreateBucketConfiguration',
        };
    }
    static types() {
        return {
            createBucketConfiguration: PutBucketRequestBodyCreateBucketConfiguration,
        };
    }
}
exports.PutBucketRequestBody = PutBucketRequestBody;
class PutBucketRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acl: 'x-oss-acl',
        };
    }
    static types() {
        return {
            acl: 'string',
        };
    }
}
exports.PutBucketRequestHeader = PutBucketRequestHeader;
class ListMultipartUploadsRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            delimiter: 'delimiter',
            maxUploads: 'max-uploads',
            keyMarker: 'key-marker',
            prefix: 'prefix',
            uploadIdMarker: 'upload-id-marker',
            encodingType: 'encoding-type',
        };
    }
    static types() {
        return {
            delimiter: 'string',
            maxUploads: 'string',
            keyMarker: 'string',
            prefix: 'string',
            uploadIdMarker: 'string',
            encodingType: 'string',
        };
    }
}
exports.ListMultipartUploadsRequestFilter = ListMultipartUploadsRequestFilter;
class ListMultipartUploadsResponseListMultipartUploadsResultUpload extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            uploadId: 'UploadId',
            initiated: 'Initiated',
        };
    }
    static types() {
        return {
            key: 'string',
            uploadId: 'string',
            initiated: 'string',
        };
    }
}
exports.ListMultipartUploadsResponseListMultipartUploadsResultUpload = ListMultipartUploadsResponseListMultipartUploadsResultUpload;
class ListMultipartUploadsResponseListMultipartUploadsResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
            encodingType: 'EncodingType',
            keyMarker: 'KeyMarker',
            uploadIdMarker: 'UploadIdMarker',
            nextKeyMarker: 'NextKeyMarker',
            nextUploadIdMarker: 'NextUploadIdMarker',
            delimiter: 'Delimiter',
            maxUploads: 'MaxUploads',
            isTruncated: 'IsTruncated',
            upload: 'Upload',
        };
    }
    static types() {
        return {
            bucket: 'string',
            encodingType: 'string',
            keyMarker: 'string',
            uploadIdMarker: 'string',
            nextKeyMarker: 'string',
            nextUploadIdMarker: 'string',
            delimiter: 'string',
            maxUploads: 'string',
            isTruncated: 'string',
            upload: { 'type': 'array', 'itemType': ListMultipartUploadsResponseListMultipartUploadsResultUpload },
        };
    }
}
exports.ListMultipartUploadsResponseListMultipartUploadsResult = ListMultipartUploadsResponseListMultipartUploadsResult;
class GetBucketRequestPaymentResponseRequestPaymentConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            payer: 'Payer',
        };
    }
    static types() {
        return {
            payer: 'string',
        };
    }
}
exports.GetBucketRequestPaymentResponseRequestPaymentConfiguration = GetBucketRequestPaymentResponseRequestPaymentConfiguration;
class GetBucketEncryptionResponseServerSideEncryptionRuleApplyServerSideEncryptionByDefault extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            sSEAlgorithm: 'SSEAlgorithm',
            kMSMasterKeyID: 'KMSMasterKeyID',
        };
    }
    static types() {
        return {
            sSEAlgorithm: 'string',
            kMSMasterKeyID: 'string',
        };
    }
}
exports.GetBucketEncryptionResponseServerSideEncryptionRuleApplyServerSideEncryptionByDefault = GetBucketEncryptionResponseServerSideEncryptionRuleApplyServerSideEncryptionByDefault;
class GetBucketEncryptionResponseServerSideEncryptionRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            applyServerSideEncryptionByDefault: 'ApplyServerSideEncryptionByDefault',
        };
    }
    static types() {
        return {
            applyServerSideEncryptionByDefault: GetBucketEncryptionResponseServerSideEncryptionRuleApplyServerSideEncryptionByDefault,
        };
    }
}
exports.GetBucketEncryptionResponseServerSideEncryptionRule = GetBucketEncryptionResponseServerSideEncryptionRule;
class GetBucketTagsResponseTaggingTagSetTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.GetBucketTagsResponseTaggingTagSetTag = GetBucketTagsResponseTaggingTagSetTag;
class GetBucketTagsResponseTaggingTagSet extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': GetBucketTagsResponseTaggingTagSetTag },
        };
    }
}
exports.GetBucketTagsResponseTaggingTagSet = GetBucketTagsResponseTaggingTagSet;
class GetBucketTagsResponseTagging extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagSet: 'TagSet',
        };
    }
    static types() {
        return {
            tagSet: GetBucketTagsResponseTaggingTagSet,
        };
    }
}
exports.GetBucketTagsResponseTagging = GetBucketTagsResponseTagging;
class GetServiceRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            prefix: 'prefix',
            marker: 'marker',
            maxKeys: 'max-keys',
        };
    }
    static types() {
        return {
            prefix: 'string',
            marker: 'string',
            maxKeys: 'string',
        };
    }
}
exports.GetServiceRequestFilter = GetServiceRequestFilter;
class GetServiceResponseListAllMyBucketsResultOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iD: 'ID',
            displayName: 'DisplayName',
        };
    }
    static types() {
        return {
            iD: 'string',
            displayName: 'string',
        };
    }
}
exports.GetServiceResponseListAllMyBucketsResultOwner = GetServiceResponseListAllMyBucketsResultOwner;
class GetServiceResponseListAllMyBucketsResultBucketsBucket extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            createDate: 'CreateDate',
            location: 'Location',
            extranetEndpoint: 'ExtranetEndpoint',
            intranetEndpoint: 'IntranetEndpoint',
            storageClass: 'StorageClass',
        };
    }
    static types() {
        return {
            name: 'string',
            createDate: 'string',
            location: 'string',
            extranetEndpoint: 'string',
            intranetEndpoint: 'string',
            storageClass: 'string',
        };
    }
}
exports.GetServiceResponseListAllMyBucketsResultBucketsBucket = GetServiceResponseListAllMyBucketsResultBucketsBucket;
class GetServiceResponseListAllMyBucketsResultBuckets extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
        };
    }
    static types() {
        return {
            bucket: { 'type': 'array', 'itemType': GetServiceResponseListAllMyBucketsResultBucketsBucket },
        };
    }
}
exports.GetServiceResponseListAllMyBucketsResultBuckets = GetServiceResponseListAllMyBucketsResultBuckets;
class GetServiceResponseListAllMyBucketsResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            prefix: 'Prefix',
            marker: 'Marker',
            maxKeys: 'MaxKeys',
            isTruncated: 'IsTruncated',
            nextMarker: 'NextMarker',
            owner: 'Owner',
            buckets: 'Buckets',
        };
    }
    static types() {
        return {
            prefix: 'string',
            marker: 'string',
            maxKeys: 'string',
            isTruncated: 'string',
            nextMarker: 'string',
            owner: GetServiceResponseListAllMyBucketsResultOwner,
            buckets: GetServiceResponseListAllMyBucketsResultBuckets,
        };
    }
}
exports.GetServiceResponseListAllMyBucketsResult = GetServiceResponseListAllMyBucketsResult;
class DeleteBucketTagsRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagging: 'tagging',
        };
    }
    static types() {
        return {
            tagging: 'string',
        };
    }
}
exports.DeleteBucketTagsRequestFilter = DeleteBucketTagsRequestFilter;
class GetBucketWebsiteResponseWebsiteConfigurationIndexDocument extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            suffix: 'Suffix',
        };
    }
    static types() {
        return {
            suffix: 'string',
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationIndexDocument = GetBucketWebsiteResponseWebsiteConfigurationIndexDocument;
class GetBucketWebsiteResponseWebsiteConfigurationErrorDocument extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
        };
    }
    static types() {
        return {
            key: 'string',
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationErrorDocument = GetBucketWebsiteResponseWebsiteConfigurationErrorDocument;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            equals: 'Equals',
        };
    }
    static types() {
        return {
            key: 'string',
            equals: 'string',
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader = GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleCondition extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            keyPrefixEquals: 'KeyPrefixEquals',
            httpErrorCodeReturnedEquals: 'HttpErrorCodeReturnedEquals',
            includeHeader: 'IncludeHeader',
        };
    }
    static types() {
        return {
            keyPrefixEquals: 'string',
            httpErrorCodeReturnedEquals: 'string',
            includeHeader: GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleConditionIncludeHeader,
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleCondition = GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleCondition;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet = GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            passAll: 'PassAll',
            pass: 'Pass',
            remove: 'Remove',
            set: 'Set',
        };
    }
    static types() {
        return {
            passAll: 'boolean',
            pass: 'string',
            remove: 'string',
            set: GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeadersSet,
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders = GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirect extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            redirectType: 'RedirectType',
            passQueryString: 'PassQueryString',
            mirrorURL: 'MirrorURL',
            mirrorPassQueryString: 'MirrorPassQueryString',
            mirrorFollowRedirect: 'MirrorFollowRedirect',
            mirrorCheckMd5: 'MirrorCheckMd5',
            protocol: 'Protocol',
            hostName: 'HostName',
            httpRedirectCode: 'HttpRedirectCode',
            replaceKeyPrefixWith: 'ReplaceKeyPrefixWith',
            replaceKeyWith: 'ReplaceKeyWith',
            mirrorHeaders: 'MirrorHeaders',
        };
    }
    static types() {
        return {
            redirectType: 'string',
            passQueryString: 'boolean',
            mirrorURL: 'string',
            mirrorPassQueryString: 'boolean',
            mirrorFollowRedirect: 'boolean',
            mirrorCheckMd5: 'boolean',
            protocol: 'string',
            hostName: 'string',
            httpRedirectCode: 'string',
            replaceKeyPrefixWith: 'string',
            replaceKeyWith: 'string',
            mirrorHeaders: GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirectMirrorHeaders,
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirect = GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirect;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ruleNumber: 'RuleNumber',
            condition: 'Condition',
            redirect: 'Redirect',
        };
    }
    static types() {
        return {
            ruleNumber: 'number',
            condition: GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleCondition,
            redirect: GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRuleRedirect,
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRule = GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRule;
class GetBucketWebsiteResponseWebsiteConfigurationRoutingRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            routingRule: 'RoutingRule',
        };
    }
    static types() {
        return {
            routingRule: { 'type': 'array', 'itemType': GetBucketWebsiteResponseWebsiteConfigurationRoutingRulesRoutingRule },
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfigurationRoutingRules = GetBucketWebsiteResponseWebsiteConfigurationRoutingRules;
class GetBucketWebsiteResponseWebsiteConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            indexDocument: 'IndexDocument',
            errorDocument: 'ErrorDocument',
            routingRules: 'RoutingRules',
        };
    }
    static types() {
        return {
            indexDocument: GetBucketWebsiteResponseWebsiteConfigurationIndexDocument,
            errorDocument: GetBucketWebsiteResponseWebsiteConfigurationErrorDocument,
            routingRules: GetBucketWebsiteResponseWebsiteConfigurationRoutingRules,
        };
    }
}
exports.GetBucketWebsiteResponseWebsiteConfiguration = GetBucketWebsiteResponseWebsiteConfiguration;
class ListLiveChannelRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            marker: 'marker',
            maxKeys: 'max-keys',
            prefix: 'prefix',
        };
    }
    static types() {
        return {
            marker: 'string',
            maxKeys: 'string',
            prefix: 'string',
        };
    }
}
exports.ListLiveChannelRequestFilter = ListLiveChannelRequestFilter;
class ListLiveChannelResponseListLiveChannelResultLiveChannelPublishUrls extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.ListLiveChannelResponseListLiveChannelResultLiveChannelPublishUrls = ListLiveChannelResponseListLiveChannelResultLiveChannelPublishUrls;
class ListLiveChannelResponseListLiveChannelResultLiveChannelPlayUrls extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            url: 'Url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
}
exports.ListLiveChannelResponseListLiveChannelResultLiveChannelPlayUrls = ListLiveChannelResponseListLiveChannelResultLiveChannelPlayUrls;
class ListLiveChannelResponseListLiveChannelResultLiveChannel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            description: 'Description',
            status: 'Status',
            lastModified: 'LastModified',
            publishUrls: 'PublishUrls',
            playUrls: 'PlayUrls',
        };
    }
    static types() {
        return {
            name: 'string',
            description: 'string',
            status: 'string',
            lastModified: 'string',
            publishUrls: ListLiveChannelResponseListLiveChannelResultLiveChannelPublishUrls,
            playUrls: ListLiveChannelResponseListLiveChannelResultLiveChannelPlayUrls,
        };
    }
}
exports.ListLiveChannelResponseListLiveChannelResultLiveChannel = ListLiveChannelResponseListLiveChannelResultLiveChannel;
class ListLiveChannelResponseListLiveChannelResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            prefix: 'Prefix',
            marker: 'Marker',
            maxKeys: 'MaxKeys',
            isTruncated: 'IsTruncated',
            nextMarker: 'NextMarker',
            liveChannel: 'LiveChannel',
        };
    }
    static types() {
        return {
            prefix: 'string',
            marker: 'string',
            maxKeys: 'string',
            isTruncated: 'string',
            nextMarker: 'string',
            liveChannel: ListLiveChannelResponseListLiveChannelResultLiveChannel,
        };
    }
}
exports.ListLiveChannelResponseListLiveChannelResult = ListLiveChannelResponseListLiveChannelResult;
class GetBucketAclResponseAccessControlPolicyOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iD: 'ID',
            displayName: 'DisplayName',
        };
    }
    static types() {
        return {
            iD: 'string',
            displayName: 'string',
        };
    }
}
exports.GetBucketAclResponseAccessControlPolicyOwner = GetBucketAclResponseAccessControlPolicyOwner;
class GetBucketAclResponseAccessControlPolicyAccessControlList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            grant: 'Grant',
        };
    }
    static types() {
        return {
            grant: 'string',
        };
    }
}
exports.GetBucketAclResponseAccessControlPolicyAccessControlList = GetBucketAclResponseAccessControlPolicyAccessControlList;
class GetBucketAclResponseAccessControlPolicy extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            owner: 'Owner',
            accessControlList: 'AccessControlList',
        };
    }
    static types() {
        return {
            owner: GetBucketAclResponseAccessControlPolicyOwner,
            accessControlList: GetBucketAclResponseAccessControlPolicyAccessControlList,
        };
    }
}
exports.GetBucketAclResponseAccessControlPolicy = GetBucketAclResponseAccessControlPolicy;
class ListPartsRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            uploadId: 'uploadId',
            maxParts: 'max-parts',
            partNumberMarker: 'part-number-marker',
            encodingType: 'Encoding-type',
        };
    }
    static types() {
        return {
            uploadId: 'string',
            maxParts: 'number',
            partNumberMarker: 'number',
            encodingType: 'string',
        };
    }
}
exports.ListPartsRequestFilter = ListPartsRequestFilter;
class ListPartsResponseListPartsResultPart extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partNumber: 'PartNumber',
            lastModified: 'LastModified',
            eTag: 'ETag',
            size: 'Size',
        };
    }
    static types() {
        return {
            partNumber: 'string',
            lastModified: 'string',
            eTag: 'string',
            size: 'string',
        };
    }
}
exports.ListPartsResponseListPartsResultPart = ListPartsResponseListPartsResultPart;
class ListPartsResponseListPartsResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
            encodingType: 'EncodingType',
            key: 'Key',
            uploadId: 'UploadId',
            partNumberMarker: 'PartNumberMarker',
            nextPartNumberMarker: 'NextPartNumberMarker',
            maxParts: 'MaxParts',
            isTruncated: 'IsTruncated',
            part: 'Part',
        };
    }
    static types() {
        return {
            bucket: 'string',
            encodingType: 'string',
            key: 'string',
            uploadId: 'string',
            partNumberMarker: 'string',
            nextPartNumberMarker: 'string',
            maxParts: 'string',
            isTruncated: 'string',
            part: { 'type': 'array', 'itemType': ListPartsResponseListPartsResultPart },
        };
    }
}
exports.ListPartsResponseListPartsResult = ListPartsResponseListPartsResult;
class GetLiveChannelHistoryRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            comp: 'comp',
        };
    }
    static types() {
        return {
            comp: 'string',
        };
    }
}
exports.GetLiveChannelHistoryRequestFilter = GetLiveChannelHistoryRequestFilter;
class GetLiveChannelHistoryResponseLiveChannelHistoryLiveRecord extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            startTime: 'StartTime',
            endTime: 'EndTime',
            remoteAddr: 'RemoteAddr',
        };
    }
    static types() {
        return {
            startTime: 'string',
            endTime: 'string',
            remoteAddr: 'string',
        };
    }
}
exports.GetLiveChannelHistoryResponseLiveChannelHistoryLiveRecord = GetLiveChannelHistoryResponseLiveChannelHistoryLiveRecord;
class GetLiveChannelHistoryResponseLiveChannelHistory extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            liveRecord: 'LiveRecord',
        };
    }
    static types() {
        return {
            liveRecord: { 'type': 'array', 'itemType': GetLiveChannelHistoryResponseLiveChannelHistoryLiveRecord },
        };
    }
}
exports.GetLiveChannelHistoryResponseLiveChannelHistory = GetLiveChannelHistoryResponseLiveChannelHistory;
class GetBucketRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            delimiter: 'delimiter',
            marker: 'marker',
            maxKeys: 'max-keys',
            prefix: 'prefix',
            encodingType: 'encoding-type',
        };
    }
    static types() {
        return {
            delimiter: 'string',
            marker: 'string',
            maxKeys: 'string',
            prefix: 'string',
            encodingType: 'string',
        };
    }
}
exports.GetBucketRequestFilter = GetBucketRequestFilter;
class GetBucketResponseListBucketResultContentsOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iD: 'ID',
            displayName: 'DisplayName',
        };
    }
    static types() {
        return {
            iD: 'string',
            displayName: 'string',
        };
    }
}
exports.GetBucketResponseListBucketResultContentsOwner = GetBucketResponseListBucketResultContentsOwner;
class GetBucketResponseListBucketResultContents extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            eTag: 'ETag',
            lastModified: 'LastModified',
            size: 'Size',
            storageClass: 'StorageClass',
            owner: 'Owner',
        };
    }
    static types() {
        return {
            key: 'string',
            eTag: 'string',
            lastModified: 'string',
            size: 'string',
            storageClass: 'string',
            owner: GetBucketResponseListBucketResultContentsOwner,
        };
    }
}
exports.GetBucketResponseListBucketResultContents = GetBucketResponseListBucketResultContents;
class GetBucketResponseListBucketResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'Name',
            prefix: 'Prefix',
            marker: 'Marker',
            maxKeys: 'MaxKeys',
            delimiter: 'Delimiter',
            isTruncated: 'IsTruncated',
            encodingType: 'EncodingType',
            commonPrefixes: 'CommonPrefixes',
            contents: 'Contents',
        };
    }
    static types() {
        return {
            name: 'string',
            prefix: 'string',
            marker: 'string',
            maxKeys: 'string',
            delimiter: 'string',
            isTruncated: 'string',
            encodingType: 'string',
            commonPrefixes: 'string',
            contents: { 'type': 'array', 'itemType': GetBucketResponseListBucketResultContents },
        };
    }
}
exports.GetBucketResponseListBucketResult = GetBucketResponseListBucketResult;
class GetLiveChannelInfoResponseLiveChannelConfigurationTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'Type',
            fragDuration: 'FragDuration',
            fragCount: 'FragCount',
            playlistName: 'PlaylistName',
        };
    }
    static types() {
        return {
            type: 'string',
            fragDuration: 'string',
            fragCount: 'string',
            playlistName: 'string',
        };
    }
}
exports.GetLiveChannelInfoResponseLiveChannelConfigurationTarget = GetLiveChannelInfoResponseLiveChannelConfigurationTarget;
class GetLiveChannelInfoResponseLiveChannelConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'Description',
            status: 'Status',
            target: 'Target',
        };
    }
    static types() {
        return {
            description: 'string',
            status: 'string',
            target: GetLiveChannelInfoResponseLiveChannelConfigurationTarget,
        };
    }
}
exports.GetLiveChannelInfoResponseLiveChannelConfiguration = GetLiveChannelInfoResponseLiveChannelConfiguration;
class GetLiveChannelStatRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            comp: 'comp',
        };
    }
    static types() {
        return {
            comp: 'string',
        };
    }
}
exports.GetLiveChannelStatRequestFilter = GetLiveChannelStatRequestFilter;
class GetLiveChannelStatResponseLiveChannelStatVideo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            width: 'Width',
            height: 'Height',
            frameRate: 'FrameRate',
            bandwidth: 'Bandwidth',
            codec: 'Codec',
        };
    }
    static types() {
        return {
            width: 'string',
            height: 'string',
            frameRate: 'string',
            bandwidth: 'string',
            codec: 'string',
        };
    }
}
exports.GetLiveChannelStatResponseLiveChannelStatVideo = GetLiveChannelStatResponseLiveChannelStatVideo;
class GetLiveChannelStatResponseLiveChannelStatAudio extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bandwidth: 'Bandwidth',
            sampleRate: 'SampleRate',
            codec: 'Codec',
        };
    }
    static types() {
        return {
            bandwidth: 'string',
            sampleRate: 'string',
            codec: 'string',
        };
    }
}
exports.GetLiveChannelStatResponseLiveChannelStatAudio = GetLiveChannelStatResponseLiveChannelStatAudio;
class GetLiveChannelStatResponseLiveChannelStat extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'Status',
            connectedTime: 'ConnectedTime',
            remoteAddr: 'RemoteAddr',
            video: 'Video',
            audio: 'Audio',
        };
    }
    static types() {
        return {
            status: 'string',
            connectedTime: 'string',
            remoteAddr: 'string',
            video: GetLiveChannelStatResponseLiveChannelStatVideo,
            audio: GetLiveChannelStatResponseLiveChannelStatAudio,
        };
    }
}
exports.GetLiveChannelStatResponseLiveChannelStat = GetLiveChannelStatResponseLiveChannelStat;
class AbortMultipartUploadRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            uploadId: 'uploadId',
        };
    }
    static types() {
        return {
            uploadId: 'string',
        };
    }
}
exports.AbortMultipartUploadRequestFilter = AbortMultipartUploadRequestFilter;
class AppendObjectRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            position: 'position',
        };
    }
    static types() {
        return {
            position: 'string',
        };
    }
}
exports.AppendObjectRequestFilter = AppendObjectRequestFilter;
class AppendObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cacheControl: 'Cache-Control',
            contentDisposition: 'Content-Disposition',
            contentEncoding: 'Content-Encoding',
            contentMD5: 'Content-MD5',
            expires: 'Expires',
            serverSideEncryption: 'x-oss-server-side-encryption',
            objectAcl: 'x-oss-object-acl',
            storageClass: 'x-oss-storage-class',
            contentType: 'content-type',
        };
    }
    static types() {
        return {
            cacheControl: 'string',
            contentDisposition: 'string',
            contentEncoding: 'string',
            contentMD5: 'string',
            expires: 'string',
            serverSideEncryption: 'string',
            objectAcl: 'string',
            storageClass: 'string',
            contentType: 'string',
        };
    }
}
exports.AppendObjectRequestHeader = AppendObjectRequestHeader;
class UploadPartCopyRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partNumber: 'partNumber',
            uploadId: 'uploadId',
        };
    }
    static types() {
        return {
            partNumber: 'string',
            uploadId: 'string',
        };
    }
}
exports.UploadPartCopyRequestFilter = UploadPartCopyRequestFilter;
class UploadPartCopyRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            copySource: 'x-oss-copy-source',
            copySourceRange: 'x-oss-copy-source-range',
            copySourceIfMatch: 'x-oss-copy-source-if-match',
            copySourceIfNoneMatch: 'x-oss-copy-source-if-none-match',
            copySourceIfUnmodifiedSince: 'x-oss-copy-source-if-unmodified-since',
            copySourceIfModifiedSince: 'x-oss-copy-source-if-modified-since',
        };
    }
    static types() {
        return {
            copySource: 'string',
            copySourceRange: 'string',
            copySourceIfMatch: 'string',
            copySourceIfNoneMatch: 'string',
            copySourceIfUnmodifiedSince: 'string',
            copySourceIfModifiedSince: 'string',
        };
    }
}
exports.UploadPartCopyRequestHeader = UploadPartCopyRequestHeader;
class UploadPartCopyResponseCopyPartResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            lastModified: 'LastModified',
            eTag: 'ETag',
        };
    }
    static types() {
        return {
            lastModified: 'string',
            eTag: 'string',
        };
    }
}
exports.UploadPartCopyResponseCopyPartResult = UploadPartCopyResponseCopyPartResult;
class GetVodPlaylistRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            endTime: 'string',
            startTime: 'string',
        };
    }
}
exports.GetVodPlaylistRequestFilter = GetVodPlaylistRequestFilter;
class GetObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            responseContentType: 'response-content-type',
            responseContentLanguage: 'response-content-language',
            responseExpires: 'response-expires',
            responseCacheControl: 'response-cache-control',
            responseContentDisposition: 'response-content-disposition',
            responseContentEncoding: 'response-content-encoding',
            range: 'Range',
            ifModifiedSince: 'If-Modified-Since',
            ifUnmodifiedSince: 'If-Unmodified-Since',
            ifMatch: 'If-Match',
            ifNoneMatch: 'If-None-Match',
            acceptEncoding: 'Accept-Encoding',
        };
    }
    static types() {
        return {
            responseContentType: 'string',
            responseContentLanguage: 'string',
            responseExpires: 'string',
            responseCacheControl: 'string',
            responseContentDisposition: 'string',
            responseContentEncoding: 'string',
            range: 'string',
            ifModifiedSince: 'string',
            ifUnmodifiedSince: 'string',
            ifMatch: 'string',
            ifNoneMatch: 'string',
            acceptEncoding: 'string',
        };
    }
}
exports.GetObjectRequestHeader = GetObjectRequestHeader;
class UploadPartRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partNumber: 'partNumber',
            uploadId: 'uploadId',
        };
    }
    static types() {
        return {
            partNumber: 'string',
            uploadId: 'string',
        };
    }
}
exports.UploadPartRequestFilter = UploadPartRequestFilter;
class GetBucketCORSResponseCORSConfigurationCORSRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxAgeSeconds: 'MaxAgeSeconds',
        };
    }
    static types() {
        return {
            maxAgeSeconds: 'string',
        };
    }
}
exports.GetBucketCORSResponseCORSConfigurationCORSRule = GetBucketCORSResponseCORSConfigurationCORSRule;
class GetBucketCORSResponseCORSConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cORSRule: 'CORSRule',
        };
    }
    static types() {
        return {
            cORSRule: { 'type': 'array', 'itemType': GetBucketCORSResponseCORSConfigurationCORSRule },
        };
    }
}
exports.GetBucketCORSResponseCORSConfiguration = GetBucketCORSResponseCORSConfiguration;
class CopyObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            copySource: 'x-oss-copy-source',
            copySourceIfMatch: 'x-oss-copy-source-if-match',
            copySourceIfNoneMatch: 'x-oss-copy-source-if-none-match',
            copySourceIfUnmodifiedSince: 'x-oss-copy-source-if-unmodified-since',
            copySourceIfModifiedSince: 'x-oss-copy-source-if-modified-since',
            metadataDirective: 'x-oss-metadata-directive',
            serverSideEncryption: 'x-oss-server-side-encryption',
            serverSideEncryptionKeyId: 'x-oss-server-side-encryption-key-id',
            objectAcl: 'x-oss-object-acl',
            storageClass: 'x-oss-storage-class',
            tagging: 'x-oss-tagging',
            taggingDirective: 'x-oss-tagging-directive',
        };
    }
    static types() {
        return {
            copySource: 'string',
            copySourceIfMatch: 'string',
            copySourceIfNoneMatch: 'string',
            copySourceIfUnmodifiedSince: 'string',
            copySourceIfModifiedSince: 'string',
            metadataDirective: 'string',
            serverSideEncryption: 'string',
            serverSideEncryptionKeyId: 'string',
            objectAcl: 'string',
            storageClass: 'string',
            tagging: 'string',
            taggingDirective: 'string',
        };
    }
}
exports.CopyObjectRequestHeader = CopyObjectRequestHeader;
class CopyObjectResponseCopyObjectResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            lastModified: 'LastModified',
            eTag: 'ETag',
        };
    }
    static types() {
        return {
            lastModified: 'string',
            eTag: 'string',
        };
    }
}
exports.CopyObjectResponseCopyObjectResult = CopyObjectResponseCopyObjectResult;
class GetObjectTaggingResponseTaggingTagSetTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.GetObjectTaggingResponseTaggingTagSetTag = GetObjectTaggingResponseTaggingTagSetTag;
class GetObjectTaggingResponseTaggingTagSet extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tag: 'Tag',
        };
    }
    static types() {
        return {
            tag: { 'type': 'array', 'itemType': GetObjectTaggingResponseTaggingTagSetTag },
        };
    }
}
exports.GetObjectTaggingResponseTaggingTagSet = GetObjectTaggingResponseTaggingTagSet;
class GetObjectTaggingResponseTagging extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tagSet: 'TagSet',
        };
    }
    static types() {
        return {
            tagSet: GetObjectTaggingResponseTaggingTagSet,
        };
    }
}
exports.GetObjectTaggingResponseTagging = GetObjectTaggingResponseTagging;
class GetBucketLifecycleResponseLifecycleConfigurationRuleExpiration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            days: 'Days',
            createdBeforeDate: 'CreatedBeforeDate',
        };
    }
    static types() {
        return {
            days: 'number',
            createdBeforeDate: 'string',
        };
    }
}
exports.GetBucketLifecycleResponseLifecycleConfigurationRuleExpiration = GetBucketLifecycleResponseLifecycleConfigurationRuleExpiration;
class GetBucketLifecycleResponseLifecycleConfigurationRuleTransition extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            days: 'Days',
            storageClass: 'StorageClass',
        };
    }
    static types() {
        return {
            days: 'number',
            storageClass: 'string',
        };
    }
}
exports.GetBucketLifecycleResponseLifecycleConfigurationRuleTransition = GetBucketLifecycleResponseLifecycleConfigurationRuleTransition;
class GetBucketLifecycleResponseLifecycleConfigurationRuleAbortMultipartUpload extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            days: 'Days',
            createdBeforeDate: 'CreatedBeforeDate',
        };
    }
    static types() {
        return {
            days: 'number',
            createdBeforeDate: 'string',
        };
    }
}
exports.GetBucketLifecycleResponseLifecycleConfigurationRuleAbortMultipartUpload = GetBucketLifecycleResponseLifecycleConfigurationRuleAbortMultipartUpload;
class GetBucketLifecycleResponseLifecycleConfigurationRuleTag extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'Key',
            value: 'Value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.GetBucketLifecycleResponseLifecycleConfigurationRuleTag = GetBucketLifecycleResponseLifecycleConfigurationRuleTag;
class GetBucketLifecycleResponseLifecycleConfigurationRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iD: 'ID',
            prefix: 'Prefix',
            status: 'Status',
            expiration: 'Expiration',
            transition: 'Transition',
            abortMultipartUpload: 'AbortMultipartUpload',
            tag: 'Tag',
        };
    }
    static types() {
        return {
            iD: 'string',
            prefix: 'string',
            status: 'string',
            expiration: GetBucketLifecycleResponseLifecycleConfigurationRuleExpiration,
            transition: GetBucketLifecycleResponseLifecycleConfigurationRuleTransition,
            abortMultipartUpload: GetBucketLifecycleResponseLifecycleConfigurationRuleAbortMultipartUpload,
            tag: GetBucketLifecycleResponseLifecycleConfigurationRuleTag,
        };
    }
}
exports.GetBucketLifecycleResponseLifecycleConfigurationRule = GetBucketLifecycleResponseLifecycleConfigurationRule;
class GetBucketLifecycleResponseLifecycleConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            rule: 'Rule',
        };
    }
    static types() {
        return {
            rule: { 'type': 'array', 'itemType': GetBucketLifecycleResponseLifecycleConfigurationRule },
        };
    }
}
exports.GetBucketLifecycleResponseLifecycleConfiguration = GetBucketLifecycleResponseLifecycleConfiguration;
class PutSymlinkRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            symlinkTarget: 'x-oss-symlink-target',
            storageClass: 'x-oss-storage-class',
        };
    }
    static types() {
        return {
            symlinkTarget: 'string',
            storageClass: 'string',
        };
    }
}
exports.PutSymlinkRequestHeader = PutSymlinkRequestHeader;
class GetBucketRefererResponseRefererConfigurationRefererList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            referer: 'Referer',
        };
    }
    static types() {
        return {
            referer: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetBucketRefererResponseRefererConfigurationRefererList = GetBucketRefererResponseRefererConfigurationRefererList;
class GetBucketRefererResponseRefererConfiguration extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allowEmptyReferer: 'AllowEmptyReferer',
            refererList: 'RefererList',
        };
    }
    static types() {
        return {
            allowEmptyReferer: 'boolean',
            refererList: GetBucketRefererResponseRefererConfigurationRefererList,
        };
    }
}
exports.GetBucketRefererResponseRefererConfiguration = GetBucketRefererResponseRefererConfiguration;
class GetBucketLoggingResponseBucketLoggingStatusLoggingEnabled extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetBucket: 'TargetBucket',
            targetPrefix: 'TargetPrefix',
        };
    }
    static types() {
        return {
            targetBucket: 'string',
            targetPrefix: 'string',
        };
    }
}
exports.GetBucketLoggingResponseBucketLoggingStatusLoggingEnabled = GetBucketLoggingResponseBucketLoggingStatusLoggingEnabled;
class GetBucketLoggingResponseBucketLoggingStatus extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            loggingEnabled: 'LoggingEnabled',
        };
    }
    static types() {
        return {
            loggingEnabled: GetBucketLoggingResponseBucketLoggingStatusLoggingEnabled,
        };
    }
}
exports.GetBucketLoggingResponseBucketLoggingStatus = GetBucketLoggingResponseBucketLoggingStatus;
class PutObjectAclRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            objectAcl: 'x-oss-object-acl',
        };
    }
    static types() {
        return {
            objectAcl: 'string',
        };
    }
}
exports.PutObjectAclRequestHeader = PutObjectAclRequestHeader;
class GetBucketInfoResponseBucketInfoBucketOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iD: 'ID',
            displayName: 'DisplayName',
        };
    }
    static types() {
        return {
            iD: 'string',
            displayName: 'string',
        };
    }
}
exports.GetBucketInfoResponseBucketInfoBucketOwner = GetBucketInfoResponseBucketInfoBucketOwner;
class GetBucketInfoResponseBucketInfoBucketAccessControlList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            grant: 'Grant',
        };
    }
    static types() {
        return {
            grant: 'string',
        };
    }
}
exports.GetBucketInfoResponseBucketInfoBucketAccessControlList = GetBucketInfoResponseBucketInfoBucketAccessControlList;
class GetBucketInfoResponseBucketInfoBucket extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creationDate: 'CreationDate',
            extranetEndpoint: 'ExtranetEndpoint',
            intranetEndpoint: 'IntranetEndpoint',
            location: 'Location',
            name: 'Name',
            dataRedundancyType: 'DataRedundancyType',
            storageClass: 'StorageClass',
            comment: 'Comment',
            owner: 'Owner',
            accessControlList: 'AccessControlList',
        };
    }
    static types() {
        return {
            creationDate: 'string',
            extranetEndpoint: 'string',
            intranetEndpoint: 'string',
            location: 'string',
            name: 'string',
            dataRedundancyType: 'string',
            storageClass: 'string',
            comment: 'string',
            owner: GetBucketInfoResponseBucketInfoBucketOwner,
            accessControlList: GetBucketInfoResponseBucketInfoBucketAccessControlList,
        };
    }
}
exports.GetBucketInfoResponseBucketInfoBucket = GetBucketInfoResponseBucketInfoBucket;
class GetBucketInfoResponseBucketInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
        };
    }
    static types() {
        return {
            bucket: GetBucketInfoResponseBucketInfoBucket,
        };
    }
}
exports.GetBucketInfoResponseBucketInfo = GetBucketInfoResponseBucketInfo;
class PutLiveChannelStatusRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
}
exports.PutLiveChannelStatusRequestFilter = PutLiveChannelStatusRequestFilter;
class InitiateMultipartUploadRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            encodingType: 'encoding-type',
        };
    }
    static types() {
        return {
            encodingType: 'string',
        };
    }
}
exports.InitiateMultipartUploadRequestFilter = InitiateMultipartUploadRequestFilter;
class InitiateMultipartUploadRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cacheControl: 'Cache-Control',
            contentDisposition: 'Content-Disposition',
            contentEncoding: 'Content-Encoding',
            expires: 'Expires',
            serverSideEncryption: 'x-oss-server-side-encryption',
            serverSideEncryptionKeyId: 'x-oss-server-side-encryption-key-id',
            storageClass: 'x-oss-storage-class',
            tagging: 'x-oss-tagging',
            contentType: 'content-type',
        };
    }
    static types() {
        return {
            cacheControl: 'string',
            contentDisposition: 'string',
            contentEncoding: 'string',
            expires: 'string',
            serverSideEncryption: 'string',
            serverSideEncryptionKeyId: 'string',
            storageClass: 'string',
            tagging: 'string',
            contentType: 'string',
        };
    }
}
exports.InitiateMultipartUploadRequestHeader = InitiateMultipartUploadRequestHeader;
class InitiateMultipartUploadResponseInitiateMultipartUploadResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
            key: 'Key',
            uploadId: 'UploadId',
        };
    }
    static types() {
        return {
            bucket: 'string',
            key: 'string',
            uploadId: 'string',
        };
    }
}
exports.InitiateMultipartUploadResponseInitiateMultipartUploadResult = InitiateMultipartUploadResponseInitiateMultipartUploadResult;
class OptionObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            origin: 'Origin',
            accessControlRequestMethod: 'Access-Control-Request-Method',
            accessControlRequestHeaders: 'Access-Control-Request-Headers',
        };
    }
    static types() {
        return {
            origin: 'string',
            accessControlRequestMethod: 'string',
            accessControlRequestHeaders: 'string',
        };
    }
}
exports.OptionObjectRequestHeader = OptionObjectRequestHeader;
class PostVodPlaylistRequestFilter extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            endTime: 'string',
            startTime: 'string',
        };
    }
}
exports.PostVodPlaylistRequestFilter = PostVodPlaylistRequestFilter;
class PostObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accessKeyId: 'OSSAccessKeyId',
            policy: 'policy',
            signature: 'Signature',
            successActionStatus: 'success_action_status',
            file: 'file',
            key: 'key',
            userMeta: 'UserMeta',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            policy: 'string',
            signature: 'string',
            successActionStatus: 'string',
            file: $FileForm.FileField,
            key: 'string',
            userMeta: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.PostObjectRequestHeader = PostObjectRequestHeader;
class PostObjectResponsePostResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bucket: 'Bucket',
            eTag: 'ETag',
            location: 'Location',
        };
    }
    static types() {
        return {
            bucket: 'string',
            eTag: 'string',
            location: 'string',
        };
    }
}
exports.PostObjectResponsePostResponse = PostObjectResponsePostResponse;
class HeadObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ifModifiedSince: 'If-Modified-Since',
            ifUnmodifiedSince: 'If-Unmodified-Since',
            ifMatch: 'If-Match',
            ifNoneMatch: 'If-None-Match',
        };
    }
    static types() {
        return {
            ifModifiedSince: 'string',
            ifUnmodifiedSince: 'string',
            ifMatch: 'string',
            ifNoneMatch: 'string',
        };
    }
}
exports.HeadObjectRequestHeader = HeadObjectRequestHeader;
class GetObjectAclResponseAccessControlPolicyOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iD: 'ID',
            displayName: 'DisplayName',
        };
    }
    static types() {
        return {
            iD: 'string',
            displayName: 'string',
        };
    }
}
exports.GetObjectAclResponseAccessControlPolicyOwner = GetObjectAclResponseAccessControlPolicyOwner;
class GetObjectAclResponseAccessControlPolicyAccessControlList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            grant: 'Grant',
        };
    }
    static types() {
        return {
            grant: 'string',
        };
    }
}
exports.GetObjectAclResponseAccessControlPolicyAccessControlList = GetObjectAclResponseAccessControlPolicyAccessControlList;
class GetObjectAclResponseAccessControlPolicy extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            owner: 'Owner',
            accessControlList: 'AccessControlList',
        };
    }
    static types() {
        return {
            owner: GetObjectAclResponseAccessControlPolicyOwner,
            accessControlList: GetObjectAclResponseAccessControlPolicyAccessControlList,
        };
    }
}
exports.GetObjectAclResponseAccessControlPolicy = GetObjectAclResponseAccessControlPolicy;
class PutBucketAclRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            acl: 'x-oss-acl',
        };
    }
    static types() {
        return {
            acl: 'string',
        };
    }
}
exports.PutBucketAclRequestHeader = PutBucketAclRequestHeader;
class PutObjectRequestHeader extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorization: 'Authorization',
            cacheControl: 'Cache-Control',
            contentDisposition: 'Content-Disposition',
            contentEncoding: 'Content-Encoding',
            contentMD5: 'Content-MD5',
            contentLength: 'Content-Length',
            eTag: 'CETag',
            expires: 'Expires',
            serverSideEncryption: 'x-oss-server-side-encryption',
            serverSideEncryptionKeyId: 'x-oss-server-side-encryption-key-id',
            objectAcl: 'x-oss-object-acl',
            storageClass: 'x-oss-storage-class',
            tagging: 'x-oss-tagging',
            contentType: 'content-type',
        };
    }
    static types() {
        return {
            authorization: 'string',
            cacheControl: 'string',
            contentDisposition: 'string',
            contentEncoding: 'string',
            contentMD5: 'string',
            contentLength: 'string',
            eTag: 'string',
            expires: 'string',
            serverSideEncryption: 'string',
            serverSideEncryptionKeyId: 'string',
            objectAcl: 'string',
            storageClass: 'string',
            tagging: 'string',
            contentType: 'string',
        };
    }
}
exports.PutObjectRequestHeader = PutObjectRequestHeader;
class Client {
    constructor(config) {
        if (tea_util_1.default.isUnset($tea.toMap(config))) {
            throw $tea.newError({
                name: "ParameterMissing",
                message: "'config' can not be unset",
            });
        }
        if (tea_util_1.default.empty(config.type)) {
            config.type = "access_key";
        }
        let credentialConfig = new $Credential.Config({
            accessKeyId: config.accessKeyId,
            type: config.type,
            accessKeySecret: config.accessKeySecret,
            securityToken: config.securityToken,
        });
        this._credential = new credentials_1.default(credentialConfig);
        if (tea_util_1.default.isUnset(config.isEnableMD5)) {
            config.isEnableMD5 = false;
        }
        if (tea_util_1.default.isUnset(config.isEnableCrc)) {
            config.isEnableCrc = false;
        }
        this._endpoint = config.endpoint;
        this._protocol = config.protocol;
        this._regionId = config.regionId;
        this._userAgent = config.userAgent;
        this._readTimeout = config.readTimeout;
        this._connectTimeout = config.connectTimeout;
        this._localAddr = config.localAddr;
        this._httpProxy = config.httpProxy;
        this._httpsProxy = config.httpsProxy;
        this._noProxy = config.noProxy;
        this._socks5Proxy = config.socks5Proxy;
        this._socks5NetWork = config.socks5NetWork;
        this._maxIdleConns = config.maxIdleConns;
        this._signatureVersion = config.signatureVersion;
        this._addtionalHeaders = config.addtionalHeaders;
        this._hostModel = config.hostModel;
        this._isEnableMD5 = config.isEnableMD5;
        this._isEnableCrc = config.isEnableCrc;
    }
    async putBucketLifecycle(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?lifecycle`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketLifecycleResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteMultipleObjects(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/?delete`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                if (!tea_util_1.default.isUnset($tea.toMap(request.header)) && !tea_util_1.default.empty(request.header.contentMD5)) {
                    request_.headers["content-md5"] = request.header.contentMD5;
                }
                else {
                    request_.headers["content-md5"] = oss_util_1.default.getContentMD5(reqBody, this._isEnableMD5);
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, DeleteMultipleObjectsResponse);
                return $tea.cast(Object.assign({ DeleteResult: respMap["DeleteResult"] }, response_.headers), new DeleteMultipleObjectsResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketReferer(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?referer`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketRefererResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketWebsite(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?website`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketWebsiteResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async completeMultipartUpload(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/${request.objectName}`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, CompleteMultipartUploadResponse);
                return $tea.cast(Object.assign({ CompleteMultipartUploadResult: respMap["CompleteMultipartUploadResult"] }, response_.headers), new CompleteMultipartUploadResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketLogging(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?logging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketLoggingResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketRequestPayment(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?requestPayment`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketRequestPaymentResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketEncryption(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?encryption`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketEncryptionResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putLiveChannel(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.channelName}?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, PutLiveChannelResponse);
                return $tea.cast(Object.assign({ CreateLiveChannelResult: respMap["CreateLiveChannelResult"] }, response_.headers), new PutLiveChannelResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketTags(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?tagging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketTagsResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putObjectTagging(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.objectName}?tagging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutObjectTaggingResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async selectObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/${request.objectName}`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new SelectObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketCORS(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?cors`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketCORSResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucket(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                let reqBody = tea_xml_1.default.toXML($tea.toMap(request.body));
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = new $tea.BytesReadable(reqBody);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async listMultipartUploads(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?uploads`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, ListMultipartUploadsResponse);
                return $tea.cast(Object.assign({ ListMultipartUploadsResult: respMap["ListMultipartUploadsResult"] }, response_.headers), new ListMultipartUploadsResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketRequestPayment(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?requestPayment`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketRequestPaymentResponse);
                return $tea.cast(Object.assign({ RequestPaymentConfiguration: respMap["RequestPaymentConfiguration"] }, response_.headers), new GetBucketRequestPaymentResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketEncryption(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?encryption`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketEncryptionResponse);
                return $tea.cast(Object.assign({ ServerSideEncryptionRule: respMap["ServerSideEncryptionRule"] }, response_.headers), new GetBucketEncryptionResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketTags(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?tagging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketTagsResponse);
                return $tea.cast(Object.assign({ Tagging: respMap["Tagging"] }, response_.headers), new GetBucketTagsResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getService(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/`;
                request_.headers = {
                    host: oss_util_1.default.getHost("", this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, "", accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetServiceResponse);
                return $tea.cast(Object.assign({ ListAllMyBucketsResult: respMap["ListAllMyBucketsResult"] }, response_.headers), new GetServiceResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucketEncryption(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/?encryption`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketEncryptionResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucketTags(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketTagsResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketWebsite(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?website`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketWebsiteResponse);
                return $tea.cast(Object.assign({ WebsiteConfiguration: respMap["WebsiteConfiguration"] }, response_.headers), new GetBucketWebsiteResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteLiveChannel(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/${request.channelName}?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteLiveChannelResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketLocation(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?location`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketLocationResponse);
                return $tea.cast(Object.assign({ LocationConstraint: respMap["LocationConstraint"] }, response_.headers), new GetBucketLocationResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async listLiveChannel(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, ListLiveChannelResponse);
                return $tea.cast(Object.assign({ ListLiveChannelResult: respMap["ListLiveChannelResult"] }, response_.headers), new ListLiveChannelResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getObjectMeta(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "HEAD";
                request_.pathname = `/${request.objectName}?objectMeta`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new GetObjectMetaResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketAcl(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?acl`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketAclResponse);
                return $tea.cast(Object.assign({ AccessControlPolicy: respMap["AccessControlPolicy"] }, response_.headers), new GetBucketAclResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async listParts(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.objectName}`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, ListPartsResponse);
                return $tea.cast(Object.assign({ ListPartsResult: respMap["ListPartsResult"] }, response_.headers), new ListPartsResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getLiveChannelHistory(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.channelName}?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetLiveChannelHistoryResponse);
                return $tea.cast(Object.assign({ LiveChannelHistory: respMap["LiveChannelHistory"] }, response_.headers), new GetLiveChannelHistoryResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucket(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketResponse);
                return $tea.cast(Object.assign({ ListBucketResult: respMap["ListBucketResult"] }, response_.headers), new GetBucketResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getLiveChannelInfo(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.channelName}?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetLiveChannelInfoResponse);
                return $tea.cast(Object.assign({ LiveChannelConfiguration: respMap["LiveChannelConfiguration"] }, response_.headers), new GetLiveChannelInfoResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getLiveChannelStat(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.channelName}?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetLiveChannelStatResponse);
                return $tea.cast(Object.assign({ LiveChannelStat: respMap["LiveChannelStat"] }, response_.headers), new GetLiveChannelStatResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/${request.objectName}`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async abortMultipartUpload(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/${request.objectName}`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new AbortMultipartUploadResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async appendObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let ctx = {};
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/${request.objectName}?append`;
                request_.headers = Object.assign(Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header))), oss_util_1.default.parseMeta(request.userMeta, "x-oss-meta-"));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.body = oss_util_1.default.inject(request.body, ctx);
                if (!tea_util_1.default.isUnset($tea.toMap(request.header)) && !tea_util_1.default.empty(request.header.contentType)) {
                    request_.headers["content-type"] = request.header.contentType;
                }
                else {
                    request_.headers["content-type"] = oss_util_1.default.getContentType(request.objectName);
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                if (this._isEnableCrc && !tea_util_1.default.equalString(ctx["crc"], response_.headers["x-oss-hash-crc64ecma"])) {
                    throw $tea.newError({
                        code: "CrcNotMatched",
                        data: {
                            clientCrc: ctx["crc"],
                            serverCrc: response_.headers["x-oss-hash-crc64ecma"],
                        },
                    });
                }
                if (this._isEnableMD5 && !tea_util_1.default.equalString(ctx["md5"], response_.headers["content-md5"])) {
                    throw $tea.newError({
                        code: "MD5NotMatched",
                        data: {
                            clientMD5: ctx["md5"],
                            serverMD5: response_.headers["content-md5"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new AppendObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async uploadPartCopy(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.objectName}`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, UploadPartCopyResponse);
                return $tea.cast(Object.assign({ CopyPartResult: respMap["CopyPartResult"] }, response_.headers), new UploadPartCopyResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getVodPlaylist(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.channelName}?vod`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new GetVodPlaylistResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucketCORS(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/?cors`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketCORSResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.objectName}`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({ body: response_.body }, response_.headers), new GetObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async uploadPart(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let ctx = {};
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.objectName}`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.body = oss_util_1.default.inject(request.body, ctx);
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                if (this._isEnableCrc && !tea_util_1.default.equalString(ctx["crc"], response_.headers["x-oss-hash-crc64ecma"])) {
                    throw $tea.newError({
                        code: "CrcNotMatched",
                        data: {
                            clientCrc: ctx["crc"],
                            serverCrc: response_.headers["x-oss-hash-crc64ecma"],
                        },
                    });
                }
                if (this._isEnableMD5 && !tea_util_1.default.equalString(ctx["md5"], response_.headers["content-md5"])) {
                    throw $tea.newError({
                        code: "MD5NotMatched",
                        data: {
                            clientMD5: ctx["md5"],
                            serverMD5: response_.headers["content-md5"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new UploadPartResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketCORS(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?cors`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketCORSResponse);
                return $tea.cast(Object.assign({ CORSConfiguration: respMap["CORSConfiguration"] }, response_.headers), new GetBucketCORSResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async copyObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.destObjectName}`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["x-oss-copy-source"] = oss_util_1.default.encode(request_.headers["x-oss-copy-source"], "UrlEncode");
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, CopyObjectResponse);
                return $tea.cast(Object.assign({ CopyObjectResult: respMap["CopyObjectResult"] }, response_.headers), new CopyObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getObjectTagging(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.objectName}?tagging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetObjectTaggingResponse);
                return $tea.cast(Object.assign({ Tagging: respMap["Tagging"] }, response_.headers), new GetObjectTaggingResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucketLifecycle(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/?lifecycle`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketLifecycleResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucketLogging(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/?logging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketLoggingResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucketWebsite(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/?website`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketWebsiteResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getSymlink(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.objectName}?symlink`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new GetSymlinkResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketLifecycle(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?lifecycle`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketLifecycleResponse);
                return $tea.cast(Object.assign({ LifecycleConfiguration: respMap["LifecycleConfiguration"] }, response_.headers), new GetBucketLifecycleResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putSymlink(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.objectName}?symlink`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutSymlinkResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketReferer(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?referer`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketRefererResponse);
                return $tea.cast(Object.assign({ RefererConfiguration: respMap["RefererConfiguration"] }, response_.headers), new GetBucketRefererResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async callback(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new CallbackResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketLogging(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?logging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketLoggingResponse);
                return $tea.cast(Object.assign({ BucketLoggingStatus: respMap["BucketLoggingStatus"] }, response_.headers), new GetBucketLoggingResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putObjectAcl(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.objectName}?acl`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutObjectAclResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getBucketInfo(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/?bucketInfo`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetBucketInfoResponse);
                return $tea.cast(Object.assign({ BucketInfo: respMap["BucketInfo"] }, response_.headers), new GetBucketInfoResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putLiveChannelStatus(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.channelName}?live`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutLiveChannelStatusResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async initiateMultipartUpload(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/${request.objectName}?uploads`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                if (!tea_util_1.default.isUnset($tea.toMap(request.header)) && !tea_util_1.default.empty(request.header.contentType)) {
                    request_.headers["content-type"] = request.header.contentType;
                }
                else {
                    request_.headers["content-type"] = oss_util_1.default.getContentType(request.objectName);
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, InitiateMultipartUploadResponse);
                return $tea.cast(Object.assign({ InitiateMultipartUploadResult: respMap["InitiateMultipartUploadResult"] }, response_.headers), new InitiateMultipartUploadResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async optionObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "OPTIONS";
                request_.pathname = `/${request.objectName}`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new OptionObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async postVodPlaylist(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/${request.channelName}/${request.playlistName}?vod`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.query = tea_util_1.default.stringifyMapValue($tea.toMap(request.filter));
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PostVodPlaylistResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async postObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let boundary = tea_fileform_1.default.getBoundary();
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                request_.headers["content-type"] = `multipart/form-data; boundary=${boundary}`;
                let form = Object.assign({ OSSAccessKeyId: request.header.accessKeyId, policy: request.header.policy, Signature: request.header.signature, key: request.header.key, success_action_status: request.header.successActionStatus, file: request.header.file }, oss_util_1.default.toMeta(request.header.userMeta, "x-oss-meta-"));
                request_.body = tea_fileform_1.default.toFileForm(form, boundary);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = await tea_util_1.default.readAsString(response_.body);
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                respMap = tea_xml_1.default.parseXml(bodyStr, PostObjectResponse);
                return $tea.cast(Object.assign({}, respMap), new PostObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async headObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "HEAD";
                request_.pathname = `/${request.objectName}`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({ usermeta: oss_util_1.default.toMeta(response_.headers, "x-oss-meta-") }, response_.headers), new HeadObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteObjectTagging(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/${request.objectName}?tagging`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteObjectTaggingResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async restoreObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "POST";
                request_.pathname = `/${request.objectName}?restore`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new RestoreObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async getObjectAcl(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "GET";
                request_.pathname = `/${request.objectName}?acl`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                bodyStr = await tea_util_1.default.readAsString(response_.body);
                respMap = tea_xml_1.default.parseXml(bodyStr, GetObjectAclResponse);
                return $tea.cast(Object.assign({ AccessControlPolicy: respMap["AccessControlPolicy"] }, response_.headers), new GetObjectAclResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putBucketAcl(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/?acl`;
                request_.headers = Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header)));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutBucketAclResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async deleteBucket(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "DELETE";
                request_.pathname = `/`;
                request_.headers = {
                    host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel),
                    date: tea_util_1.default.getDateUTCString(),
                    'user-agent': this.getUserAgent(),
                };
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new DeleteBucketResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    async putObject(request, runtime) {
        let _runtime = {
            timeouted: "retry",
            readTimeout: tea_util_1.default.defaultNumber(runtime.readTimeout, this._readTimeout),
            connectTimeout: tea_util_1.default.defaultNumber(runtime.connectTimeout, this._connectTimeout),
            localAddr: tea_util_1.default.defaultString(runtime.localAddr, this._localAddr),
            httpProxy: tea_util_1.default.defaultString(runtime.httpProxy, this._httpProxy),
            httpsProxy: tea_util_1.default.defaultString(runtime.httpsProxy, this._httpsProxy),
            noProxy: tea_util_1.default.defaultString(runtime.noProxy, this._noProxy),
            socks5Proxy: tea_util_1.default.defaultString(runtime.socks5Proxy, this._socks5Proxy),
            socks5NetWork: tea_util_1.default.defaultString(runtime.socks5NetWork, this._socks5NetWork),
            maxIdleConns: tea_util_1.default.defaultNumber(runtime.maxIdleConns, this._maxIdleConns),
            retry: {
                retryable: runtime.autoretry,
                maxAttempts: tea_util_1.default.defaultNumber(runtime.maxAttempts, 3),
            },
            backoff: {
                policy: tea_util_1.default.defaultString(runtime.backoffPolicy, "no"),
                period: tea_util_1.default.defaultNumber(runtime.backoffPeriod, 1),
            },
            ignoreSSL: runtime.ignoreSSL,
        };
        let _lastRequest = null;
        let _now = Date.now();
        let _retryTimes = 0;
        while ($tea.allowRetry(_runtime['retry'], _retryTimes, _now)) {
            if (_retryTimes > 0) {
                let _backoffTime = $tea.getBackoffTime(_runtime['backoff'], _retryTimes);
                if (_backoffTime > 0) {
                    await $tea.sleep(_backoffTime);
                }
            }
            _retryTimes = _retryTimes + 1;
            try {
                let request_ = new $tea.Request();
                let ctx = {};
                let accessKeyId = await this._credential.getAccessKeyId();
                let accessKeySecret = await this._credential.getAccessKeySecret();
                let token = await this._credential.getSecurityToken();
                request_.protocol = this._protocol;
                request_.method = "PUT";
                request_.pathname = `/${request.objectName}`;
                request_.headers = Object.assign(Object.assign({ host: oss_util_1.default.getHost(request.bucketName, this._regionId, this._endpoint, this._hostModel), date: tea_util_1.default.getDateUTCString(), 'user-agent': this.getUserAgent() }, tea_util_1.default.stringifyMapValue($tea.toMap(request.header))), oss_util_1.default.parseMeta(request.userMeta, "x-oss-meta-"));
                if (!tea_util_1.default.empty(token)) {
                    request_.headers["x-oss-security-token"] = token;
                }
                request_.body = oss_util_1.default.inject(request.body, ctx);
                if (!tea_util_1.default.isUnset($tea.toMap(request.header)) && !tea_util_1.default.empty(request.header.contentType)) {
                    request_.headers["content-type"] = request.header.contentType;
                }
                else {
                    request_.headers["content-type"] = oss_util_1.default.getContentType(request.objectName);
                }
                request_.headers["authorization"] = oss_util_1.default.getSignature(request_, request.bucketName, accessKeyId, accessKeySecret, this._signatureVersion, this._addtionalHeaders);
                _lastRequest = request_;
                let response_ = await $tea.doAction(request_, _runtime);
                let respMap = null;
                let bodyStr = null;
                if (tea_util_1.default.is4xx(response_.statusCode) || tea_util_1.default.is5xx(response_.statusCode)) {
                    bodyStr = await tea_util_1.default.readAsString(response_.body);
                    respMap = oss_util_1.default.getErrMessage(bodyStr);
                    throw $tea.newError({
                        code: respMap["Code"],
                        message: respMap["Message"],
                        data: {
                            httpCode: response_.statusCode,
                            requestId: respMap["RequestId"],
                            hostId: respMap["HostId"],
                        },
                    });
                }
                if (this._isEnableCrc && !tea_util_1.default.equalString(ctx["crc"], response_.headers["x-oss-hash-crc64ecma"])) {
                    throw $tea.newError({
                        code: "CrcNotMatched",
                        data: {
                            clientCrc: ctx["crc"],
                            serverCrc: response_.headers["x-oss-hash-crc64ecma"],
                        },
                    });
                }
                if (this._isEnableMD5 && !tea_util_1.default.equalString(ctx["md5"], response_.headers["content-md5"])) {
                    throw $tea.newError({
                        code: "MD5NotMatched",
                        data: {
                            clientMD5: ctx["md5"],
                            serverMD5: response_.headers["content-md5"],
                        },
                    });
                }
                return $tea.cast(Object.assign({}, response_.headers), new PutObjectResponse({}));
            }
            catch (ex) {
                if ($tea.isRetryable(ex)) {
                    continue;
                }
                throw ex;
            }
        }
        throw $tea.newUnretryableError(_lastRequest);
    }
    setUserAgent(userAgent) {
        this._userAgent = userAgent;
    }
    appendUserAgent(userAgent) {
        this._userAgent = `${this._userAgent} ${userAgent}`;
    }
    getUserAgent() {
        let userAgent = tea_util_1.default.getUserAgent(this._userAgent);
        return userAgent;
    }
    async getAccessKeyId() {
        if (tea_util_1.default.isUnset(this._credential)) {
            return "";
        }
        let accessKeyId = await this._credential.getAccessKeyId();
        return accessKeyId;
    }
    async getAccessKeySecret() {
        if (tea_util_1.default.isUnset(this._credential)) {
            return "";
        }
        let secret = await this._credential.getAccessKeySecret();
        return secret;
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map