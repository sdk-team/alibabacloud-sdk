import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'vod.cn-shanghai.aliyuncs.com',
    cn-hangzhou = 'vod.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'vod.cn-shanghai.aliyuncs.com',
    ap-northeast-2-pop = 'vod.ap-northeast-1.aliyuncs.com',
    ap-southeast-2 = 'vod.ap-northeast-1.aliyuncs.com',
    ap-southeast-3 = 'vod.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'vod.aliyuncs.com',
    cn-beijing-finance-pop = 'vod.aliyuncs.com',
    cn-beijing-gov-1 = 'vod.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vod.aliyuncs.com',
    cn-chengdu = 'vod.aliyuncs.com',
    cn-edge-1 = 'vod.aliyuncs.com',
    cn-fujian = 'vod.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vod.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vod.aliyuncs.com',
    cn-hangzhou-finance = 'vod.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vod.aliyuncs.com',
    cn-hangzhou-test-306 = 'vod.aliyuncs.com',
    cn-hongkong-finance-pop = 'vod.aliyuncs.com',
    cn-huhehaote = 'vod.aliyuncs.com',
    cn-qingdao = 'vod.aliyuncs.com',
    cn-qingdao-nebula = 'vod.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vod.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vod.aliyuncs.com',
    cn-shanghai-finance-1 = 'vod.aliyuncs.com',
    cn-shanghai-inner = 'vod.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vod.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vod.aliyuncs.com',
    cn-shenzhen-inner = 'vod.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vod.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vod.aliyuncs.com',
    cn-wuhan = 'vod.aliyuncs.com',
    cn-yushanfang = 'vod.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vod.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vod.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vod.aliyuncs.com',
    eu-west-1-oxs = 'vod.ap-northeast-1.aliyuncs.com',
    me-east-1 = 'vod.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'vod.ap-northeast-1.aliyuncs.com',
    us-east-1 = 'vod.ap-northeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint(@productId, @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model GetMediaAuditAudioResultDetailRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  pageNo?: integer(name='PageNo', description='pageNo'),
}

model GetMediaAuditAudioResultDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditAudioResultDetail: {
    total: integer(name='Total', description='total'),
    pageTotal: integer(name='PageTotal', description='pageTotal'),
    list: [
      {
        startTime: long(name='StartTime', description='startTime'),
        endTime: long(name='EndTime', description='endTime'),
        text: string(name='Text', description='text'),
        label: string(name='Label', description='label'),
      }
    ](name='List', description='list'),
  }(name='MediaAuditAudioResultDetail', description='data.resultDTO'),
}

async function getMediaAuditAudioResultDetailWithOptions(request: GetMediaAuditAudioResultDetailRequest, runtime: Util.RuntimeOptions): GetMediaAuditAudioResultDetailResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditAudioResultDetail', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMediaAuditAudioResultDetail(request: GetMediaAuditAudioResultDetailRequest): GetMediaAuditAudioResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditAudioResultDetailWithOptions(request, runtime);
}

model SubmitDynamicImageJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  dynamicImageTemplateId: string(name='DynamicImageTemplateId', description='dynamicImageTemplateId'),
  overrideParams?: string(name='OverrideParams', description='overrideParams'),
}

model SubmitDynamicImageJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  dynamicImageJob: {
    jobId: string(name='JobId', description='jobId'),
  }(name='DynamicImageJob', description='data.submitDynamicJobDTO'),
}

async function submitDynamicImageJobWithOptions(request: SubmitDynamicImageJobRequest, runtime: Util.RuntimeOptions): SubmitDynamicImageJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitDynamicImageJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitDynamicImageJob(request: SubmitDynamicImageJobRequest): SubmitDynamicImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDynamicImageJobWithOptions(request, runtime);
}

model SubmitWorkflowJobRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  workflowId: string(name='WorkflowId', description='workflowId'),
  mediaId?: string(name='MediaId', description='mediaId'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
}

model SubmitWorkflowJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function submitWorkflowJobWithOptions(request: SubmitWorkflowJobRequest, runtime: Util.RuntimeOptions): SubmitWorkflowJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitWorkflowJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitWorkflowJob(request: SubmitWorkflowJobRequest): SubmitWorkflowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitWorkflowJobWithOptions(request, runtime);
}

model GetAIVideoTagResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model GetAIVideoTagResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoTagResult: {
    category: [
      {
        tag: string(name='Tag', description='tag'),
      }
    ](name='Category', description='category'),
    person: [
      {
        faceUrl: string(name='FaceUrl', description='faceUrl'),
        tag: string(name='Tag', description='tag'),
        times: [ string ](name='Times', description='times'),
      }
    ](name='Person', description='person'),
    time: [
      {
        tag: string(name='Tag', description='tag'),
        times: [ string ](name='Times', description='times'),
      }
    ](name='Time', description='time'),
    location: [
      {
        tag: string(name='Tag', description='tag'),
        times: [ string ](name='Times', description='times'),
      }
    ](name='Location', description='location'),
    keyword: [
      {
        tag: string(name='Tag', description='tag'),
        times: [ string ](name='Times', description='times'),
      }
    ](name='Keyword', description='keyword'),
  }(name='VideoTagResult', description='data.resultDTO'),
}

async function getAIVideoTagResultWithOptions(request: GetAIVideoTagResultRequest, runtime: Util.RuntimeOptions): GetAIVideoTagResultResponse {
  Util.validateModel(request);
  return doRequest('GetAIVideoTagResult', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getAIVideoTagResult(request: GetAIVideoTagResultRequest): GetAIVideoTagResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAIVideoTagResultWithOptions(request, runtime);
}

model GetUploadDetailsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  mediaIds: string(name='MediaIds', description='mediaIds'),
  mediaType?: string(name='MediaType', description='mediaType'),
}

model GetUploadDetailsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadDetails: [
    {
      mediaId: string(name='MediaId', description='mediaId'),
      title: string(name='Title', description='title'),
      fileSize: long(name='FileSize', description='fileSize'),
      status: string(name='Status', description='status'),
      uploadStatus: string(name='UploadStatus', description='uploadStatus'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modificationTime: string(name='ModificationTime', description='modificationTime'),
      completionTime: string(name='CompletionTime', description='completionTime'),
      uploadSize: long(name='UploadSize', description='uploadSize'),
      uploadRatio: float(name='UploadRatio', description='uploadRatio'),
      uploadIP: string(name='UploadIP', description='uploadIp'),
      uploadSource: string(name='UploadSource', description='uploadSource'),
      deviceModel: string(name='DeviceModel', description='deviceModel'),
    }
  ](name='UploadDetails', description='data.uploadDetails'),
  nonExistMediaIds: [ string ] (name='NonExistMediaIds', description='data.nonExistMediaIds'),
  forbiddenMediaIds: [ string ] (name='ForbiddenMediaIds', description='data.forbiddenMediaIds'),
}

async function getUploadDetailsWithOptions(request: GetUploadDetailsRequest, runtime: Util.RuntimeOptions): GetUploadDetailsResponse {
  Util.validateModel(request);
  return doRequest('GetUploadDetails', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getUploadDetails(request: GetUploadDetailsRequest): GetUploadDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUploadDetailsWithOptions(request, runtime);
}

model DescribeVodStorageDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  region?: string(name='Region', description='region'),
  storageType?: string(name='StorageType', description='storageType'),
  storage?: string(name='Storage', description='storageName'),
}

model DescribeVodStorageDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  storageData: {
    storageDataItem: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        storageUtilization: string(name='StorageUtilization', description='storage_utilization'),
        networkOut: string(name='NetworkOut', description='network_out'),
      }
    ](name='StorageDataItem', description='StorageDataItem'),
  }(name='StorageData', description='data.content.data'),
}

async function describeVodStorageDataWithOptions(request: DescribeVodStorageDataRequest, runtime: Util.RuntimeOptions): DescribeVodStorageDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodStorageData', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodStorageData(request: DescribeVodStorageDataRequest): DescribeVodStorageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodStorageDataWithOptions(request, runtime);
}

model DescribeVodAIDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  region?: string(name='Region', description='region'),
  AIType?: string(name='AIType', description='aiType'),
}

model DescribeVodAIDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  AIData: {
    AIDataItem: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        data: {
          dataItem: [
            {
              name: string(name='Name', description='name'),
              value: string(name='Value', description='value'),
            }
          ](name='DataItem', description='DataItem'),
        }(name='Data', description='data'),
      }
    ](name='AIDataItem', description='AIDataItem'),
  }(name='AIData', description='data.content.data'),
}

async function describeVodAIDataWithOptions(request: DescribeVodAIDataRequest, runtime: Util.RuntimeOptions): DescribeVodAIDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodAIData', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodAIData(request: DescribeVodAIDataRequest): DescribeVodAIDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodAIDataWithOptions(request, runtime);
}

model DescribeVodTranscodeDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  region?: string(name='Region', description='region'),
  interval?: string(name='Interval', description='interval'),
  storage?: string(name='Storage', description='inputBucket'),
  specification?: string(name='Specification', description='saasSpecification'),
}

model DescribeVodTranscodeDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  transcodeData: {
    transcodeDataItem: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        data: {
          dataItem: [
            {
              name: string(name='Name', description='name'),
              value: string(name='Value', description='value'),
            }
          ](name='DataItem', description='DataItem'),
        }(name='Data', description='data'),
      }
    ](name='TranscodeDataItem', description='TranscodeDataItem'),
  }(name='TranscodeData', description='data.content.data'),
}

async function describeVodTranscodeDataWithOptions(request: DescribeVodTranscodeDataRequest, runtime: Util.RuntimeOptions): DescribeVodTranscodeDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodTranscodeData', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodTranscodeData(request: DescribeVodTranscodeDataRequest): DescribeVodTranscodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodTranscodeDataWithOptions(request, runtime);
}

model DeleteMultipartUploadRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  mediaType: string(name='MediaType', description='mediaType'),
}

model DeleteMultipartUploadResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMultipartUploadWithOptions(request: DeleteMultipartUploadRequest, runtime: Util.RuntimeOptions): DeleteMultipartUploadResponse {
  Util.validateModel(request);
  return doRequest('DeleteMultipartUpload', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteMultipartUpload(request: DeleteMultipartUploadRequest): DeleteMultipartUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMultipartUploadWithOptions(request, runtime);
}

model GetAttachedMediaInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaIds: string(name='MediaIds', description='mediaIds'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  outputType?: string(name='OutputType', description='outputType'),
}

model GetAttachedMediaInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  attachedMediaList: [
    {
      mediaId: string(name='MediaId', description='mediaId'),
      title: string(name='Title', description='title'),
      type: string(name='Type', description='type'),
      tags: string(name='Tags', description='tags'),
      URL: string(name='URL', description='url'),
      description: string(name='Description', description='description'),
      fileSize: long(name='FileSize', description='fileSize'),
      storageLocation: string(name='StorageLocation', description='storageLocation'),
      creationTime: string(name='CreationTime', description='utcCreate'),
      modificationTime: string(name='ModificationTime', description='utcModified'),
      appId: string(name='AppId', description='appId'),
      status: string(name='Status', description='status'),
      onlineStatus: string(name='OnlineStatus', description='onlineStatus'),
      icon: string(name='Icon', description='icon'),
      regionId: string(name='RegionId', description='regionId'),
      categories: [
        {
          cateId: long(name='CateId', description='cateId'),
          cateName: string(name='CateName', description='cateName'),
          level: long(name='Level', description='level'),
          parentId: long(name='ParentId', description='parentId'),
        }
      ](name='Categories', description='categories'),
    }
  ](name='AttachedMediaList', description='data.attachedMediaList'),
  nonExistMediaIds: [ string ] (name='NonExistMediaIds', description='data.nonExistMediaIds'),
}

async function getAttachedMediaInfoWithOptions(request: GetAttachedMediaInfoRequest, runtime: Util.RuntimeOptions): GetAttachedMediaInfoResponse {
  Util.validateModel(request);
  return doRequest('GetAttachedMediaInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getAttachedMediaInfo(request: GetAttachedMediaInfoRequest): GetAttachedMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAttachedMediaInfoWithOptions(request, runtime);
}

model DeleteAttachedMediaRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaIds?: string(name='MediaIds', description='mediaIds'),
}

model DeleteAttachedMediaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistMediaIds: [ string ] (name='NonExistMediaIds', description='data.nonExistIds'),
}

async function deleteAttachedMediaWithOptions(request: DeleteAttachedMediaRequest, runtime: Util.RuntimeOptions): DeleteAttachedMediaResponse {
  Util.validateModel(request);
  return doRequest('DeleteAttachedMedia', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteAttachedMedia(request: DeleteAttachedMediaRequest): DeleteAttachedMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAttachedMediaWithOptions(request, runtime);
}

model UpdateAttachedMediaInfosRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  updateContent: string(name='UpdateContent', description='updateContent'),
}

model UpdateAttachedMediaInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistMediaIds: [ string ] (name='NonExistMediaIds', description='data.nonExistMediaIds'),
}

async function updateAttachedMediaInfosWithOptions(request: UpdateAttachedMediaInfosRequest, runtime: Util.RuntimeOptions): UpdateAttachedMediaInfosResponse {
  Util.validateModel(request);
  return doRequest('UpdateAttachedMediaInfos', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateAttachedMediaInfos(request: UpdateAttachedMediaInfosRequest): UpdateAttachedMediaInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAttachedMediaInfosWithOptions(request, runtime);
}

model AttachAppPolicyToIdentityRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  identityType: string(name='IdentityType', description='identityType'),
  identityName: string(name='IdentityName', description='identityName'),
  appId?: string(name='AppId', description='appId'),
  policyNames: string(name='PolicyNames', description='policyNames'),
}

model AttachAppPolicyToIdentityResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistPolicyNames: [ string ] (name='NonExistPolicyNames', description='data.nonExistPolicyNames'),
  failedPolicyNames: [ string ] (name='FailedPolicyNames', description='data.failedPolicyNames'),
}

async function attachAppPolicyToIdentityWithOptions(request: AttachAppPolicyToIdentityRequest, runtime: Util.RuntimeOptions): AttachAppPolicyToIdentityResponse {
  Util.validateModel(request);
  return doRequest('AttachAppPolicyToIdentity', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function attachAppPolicyToIdentity(request: AttachAppPolicyToIdentityRequest): AttachAppPolicyToIdentityResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachAppPolicyToIdentityWithOptions(request, runtime);
}

model DetachAppPolicyFromIdentityRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  identityType: string(name='IdentityType', description='identityType'),
  identityName: string(name='IdentityName', description='identityName'),
  appId?: string(name='AppId', description='appId'),
  policyNames: string(name='PolicyNames', description='policyNames'),
}

model DetachAppPolicyFromIdentityResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistPolicyNames: [ string ] (name='NonExistPolicyNames', description='data.nonExistPolicyNames'),
  failedPolicyNames: [ string ] (name='FailedPolicyNames', description='data.failedPolicyNames'),
}

async function detachAppPolicyFromIdentityWithOptions(request: DetachAppPolicyFromIdentityRequest, runtime: Util.RuntimeOptions): DetachAppPolicyFromIdentityResponse {
  Util.validateModel(request);
  return doRequest('DetachAppPolicyFromIdentity', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function detachAppPolicyFromIdentity(request: DetachAppPolicyFromIdentityRequest): DetachAppPolicyFromIdentityResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachAppPolicyFromIdentityWithOptions(request, runtime);
}

model ListAppPoliciesForIdentityRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  identityType?: string(name='IdentityType', description='identityType'),
  identityName?: string(name='IdentityName', description='identityName'),
  appId?: string(name='AppId', description='appId'),
}

model ListAppPoliciesForIdentityResponse = {
  requestId: string(name='RequestId', description='requestId'),
  appPolicyList: [
    {
      appId: string(name='AppId', description='appId'),
      creationTime: string(name='CreationTime', description='utcCreate'),
      policyName: string(name='PolicyName', description='policyName'),
      policyType: string(name='PolicyType', description='policyType'),
      policyValue: string(name='PolicyValue', description='policyValue'),
      description: string(name='Description', description='description'),
      modificationTime: string(name='ModificationTime', description='utcModified'),
    }
  ](name='AppPolicyList', description='data.appPolicyDTOS'),
}

async function listAppPoliciesForIdentityWithOptions(request: ListAppPoliciesForIdentityRequest, runtime: Util.RuntimeOptions): ListAppPoliciesForIdentityResponse {
  Util.validateModel(request);
  return doRequest('ListAppPoliciesForIdentity', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listAppPoliciesForIdentity(request: ListAppPoliciesForIdentityRequest): ListAppPoliciesForIdentityResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppPoliciesForIdentityWithOptions(request, runtime);
}

model CreateAppInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  appName?: string(name='AppName', description='AppName'),
  description?: string(name='Description', description='Description'),
}

model CreateAppInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  appId: string(name='AppId', description='data.appId'),
}

async function createAppInfoWithOptions(request: CreateAppInfoRequest, runtime: Util.RuntimeOptions): CreateAppInfoResponse {
  Util.validateModel(request);
  return doRequest('CreateAppInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function createAppInfo(request: CreateAppInfoRequest): CreateAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppInfoWithOptions(request, runtime);
}

model GetAppInfosRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  appIds: string(name='AppIds', description='appIds'),
}

model GetAppInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  appInfoList: [
    {
      appId: string(name='AppId', description='appId'),
      appName: string(name='AppName', description='appName'),
      type: string(name='Type', description='type'),
      description: string(name='Description', description='description'),
      status: string(name='Status', description='status'),
      creationTime: string(name='CreationTime', description='utcCreate'),
      modificationTime: string(name='ModificationTime', description='utcModified'),
    }
  ](name='AppInfoList', description='data.appInfoList'),
  nonExistAppIds: [ string ] (name='NonExistAppIds', description='data.nonExists'),
}

async function getAppInfosWithOptions(request: GetAppInfosRequest, runtime: Util.RuntimeOptions): GetAppInfosResponse {
  Util.validateModel(request);
  return doRequest('GetAppInfos', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getAppInfos(request: GetAppInfosRequest): GetAppInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppInfosWithOptions(request, runtime);
}

model UpdateAppInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  appId?: string(name='AppId', description='appId'),
  appName?: string(name='AppName', description='appName'),
  description?: string(name='Description', description='description'),
  status?: string(name='Status', description='status'),
}

model UpdateAppInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateAppInfoWithOptions(request: UpdateAppInfoRequest, runtime: Util.RuntimeOptions): UpdateAppInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateAppInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateAppInfo(request: UpdateAppInfoRequest): UpdateAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppInfoWithOptions(request, runtime);
}

model DeleteAppInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  appId?: string(name='AppId', description='appId'),
}

model DeleteAppInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteAppInfoWithOptions(request: DeleteAppInfoRequest, runtime: Util.RuntimeOptions): DeleteAppInfoResponse {
  Util.validateModel(request);
  return doRequest('DeleteAppInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteAppInfo(request: DeleteAppInfoRequest): DeleteAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppInfoWithOptions(request, runtime);
}

model ListAppInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  status?: string(name='Status', description='status'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model ListAppInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  appInfoList: [
    {
      appId: string(name='AppId', description='appId'),
      appName: string(name='AppName', description='appName'),
      type: string(name='Type', description='type'),
      description: string(name='Description', description='description'),
      status: string(name='Status', description='status'),
      creationTime: string(name='CreationTime', description='utcCreate'),
      modificationTime: string(name='ModificationTime', description='utcModified'),
    }
  ](name='AppInfoList', description='data.appInfoList'),
}

async function listAppInfoWithOptions(request: ListAppInfoRequest, runtime: Util.RuntimeOptions): ListAppInfoResponse {
  Util.validateModel(request);
  return doRequest('ListAppInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listAppInfo(request: ListAppInfoRequest): ListAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppInfoWithOptions(request, runtime);
}

model MoveAppResourceRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  targetAppId: string(name='TargetAppId', description='targetAppId'),
  resourceType: string(name='ResourceType', description='resourceType'),
  resourceIds: string(name='ResourceIds', description='resourceIds'),
}

model MoveAppResourceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistResourceIds: [ string ] (name='NonExistResourceIds', description='data.nonExistIds'),
  failedResourceIds: [ string ] (name='FailedResourceIds', description='data.failedIds'),
}

async function moveAppResourceWithOptions(request: MoveAppResourceRequest, runtime: Util.RuntimeOptions): MoveAppResourceResponse {
  Util.validateModel(request);
  return doRequest('MoveAppResource', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function moveAppResource(request: MoveAppResourceRequest): MoveAppResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveAppResourceWithOptions(request, runtime);
}

model DeleteMessageCallbackRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  appId?: string(name='AppId', description='appId'),
}

model DeleteMessageCallbackResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMessageCallbackWithOptions(request: DeleteMessageCallbackRequest, runtime: Util.RuntimeOptions): DeleteMessageCallbackResponse {
  Util.validateModel(request);
  return doRequest('DeleteMessageCallback', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteMessageCallback(request: DeleteMessageCallbackRequest): DeleteMessageCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMessageCallbackWithOptions(request, runtime);
}

model GetTranscodeSummaryRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='videoIds'),
}

model GetTranscodeSummaryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeSummaryList: [
    {
      videoId: string(name='VideoId', description='videoId'),
      transcodeStatus: string(name='TranscodeStatus', description='transcodeProcessState'),
      creationTime: string(name='CreationTime', description='creationTime'),
      completeTime: string(name='CompleteTime', description='modifyTime'),
      trigger: string(name='Trigger', description='trigger'),
      transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
      transcodeJobInfoSummaryList: [
        {
          transcodeTemplateId: string(name='TranscodeTemplateId', description='transcodeTemplateId'),
          transcodeJobStatus: string(name='TranscodeJobStatus', description='transcodeJobState'),
          creationTime: string(name='CreationTime', description='startTime'),
          completeTime: string(name='CompleteTime', description='finishTime'),
          transcodeProgress: long(name='TranscodeProgress', description='transcodeProgress'),
          errorCode: string(name='ErrorCode', description='errorCode'),
          errorMessage: string(name='ErrorMessage', description='errorMessage'),
          definition: string(name='Definition', description='definition'),
          encryption: string(name='Encryption', description='encryption'),
          width: string(name='Width', description='width'),
          height: string(name='Height', description='height'),
          bitrate: string(name='Bitrate', description='bitrate'),
          fps: string(name='Fps', description='fps'),
          format: string(name='Format', description='format'),
          duration: string(name='Duration', description='duration'),
          filesize: long(name='Filesize', description='filesize'),
          watermarkIdList: [ string ](name='WatermarkIdList', description='watermarkIdList'),
        }
      ](name='TranscodeJobInfoSummaryList', description='transcodeJobInfoList'),
    }
  ](name='TranscodeSummaryList', description='data.transcodeSummaryList'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIdList'),
}

async function getTranscodeSummaryWithOptions(request: GetTranscodeSummaryRequest, runtime: Util.RuntimeOptions): GetTranscodeSummaryResponse {
  Util.validateModel(request);
  return doRequest('GetTranscodeSummary', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getTranscodeSummary(request: GetTranscodeSummaryRequest): GetTranscodeSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTranscodeSummaryWithOptions(request, runtime);
}

model ListTranscodeTaskRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNo?: integer(name='PageNo', description='pageNo'),
}

model ListTranscodeTaskResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTaskList: [
    {
      transcodeTaskId: string(name='TranscodeTaskId', description='transcodeProcessId'),
      videoId: string(name='VideoId', description='videoId'),
      taskStatus: string(name='TaskStatus', description='transcodeProcessState'),
      transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
      creationTime: string(name='CreationTime', description='creationTime'),
      completeTime: string(name='CompleteTime', description='modifyTime'),
      trigger: string(name='Trigger', description='trigger'),
    }
  ](name='TranscodeTaskList', description='data.transcodeJobProcessList'),
}

async function listTranscodeTaskWithOptions(request: ListTranscodeTaskRequest, runtime: Util.RuntimeOptions): ListTranscodeTaskResponse {
  Util.validateModel(request);
  return doRequest('ListTranscodeTask', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listTranscodeTask(request: ListTranscodeTaskRequest): ListTranscodeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTranscodeTaskWithOptions(request, runtime);
}

model GetTranscodeTaskRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  transcodeTaskId: string(name='TranscodeTaskId', description='transcodeProcessId'),
}

model GetTranscodeTaskResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTask: {
    transcodeTaskId: string(name='TranscodeTaskId', description='transcodeProcessId'),
    videoId: string(name='VideoId', description='videoId'),
    taskStatus: string(name='TaskStatus', description='transcodeProcessState'),
    creationTime: string(name='CreationTime', description='creationTime'),
    completeTime: string(name='CompleteTime', description='modifyTime'),
    trigger: string(name='Trigger', description='trigger'),
    transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
    transcodeJobInfoList: [
      {
        transcodeJobId: string(name='TranscodeJobId', description='transcodeJobId'),
        transcodeTemplateId: string(name='TranscodeTemplateId', description='transcodeTemplateId'),
        transcodeJobStatus: string(name='TranscodeJobStatus', description='transcodeJobState'),
        creationTime: string(name='CreationTime', description='startTime'),
        completeTime: string(name='CompleteTime', description='finishTime'),
        transcodeProgress: long(name='TranscodeProgress', description='transcodeProgress'),
        inputFileUrl: string(name='InputFileUrl', description='inputFileUrl'),
        priority: string(name='Priority', description='priority'),
        errorCode: string(name='ErrorCode', description='errorCode'),
        errorMessage: string(name='ErrorMessage', description='errorMessage'),
        definition: string(name='Definition', description='definition'),
        outputFile: {
          width: string(name='Width', description='width'),
          height: string(name='Height', description='height'),
          bitrate: string(name='Bitrate', description='bitrate'),
          fps: string(name='Fps', description='fps'),
          format: string(name='Format', description='format'),
          duration: string(name='Duration', description='duration'),
          filesize: long(name='Filesize', description='filesize'),
          encryption: string(name='Encryption', description='encryption'),
          audioStreamList: string(name='AudioStreamList', description='audioStreamList'),
          videoStreamList: string(name='VideoStreamList', description='videoStreamList'),
          subtitleStreamList: string(name='SubtitleStreamList', description='subtitleStreamList'),
          outputFileUrl: string(name='OutputFileUrl', description='outputFileUrl'),
          watermarkIdList: [ string ](name='WatermarkIdList', description='watermarkIdList'),
        }(name='OutputFile', description='outputFile'),
      }
    ](name='TranscodeJobInfoList', description='transcodeJobInfoList'),
  }(name='TranscodeTask', description='data.transcodeJobProcess'),
}

async function getTranscodeTaskWithOptions(request: GetTranscodeTaskRequest, runtime: Util.RuntimeOptions): GetTranscodeTaskResponse {
  Util.validateModel(request);
  return doRequest('GetTranscodeTask', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getTranscodeTask(request: GetTranscodeTaskRequest): GetTranscodeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTranscodeTaskWithOptions(request, runtime);
}

model GetURLUploadInfosRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  jobIds?: string(name='JobIds', description='jobIds'),
  uploadURLs?: string(name='UploadURLs', description='uploadUrls'),
}

model GetURLUploadInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  URLUploadInfoList: [
    {
      jobId: string(name='JobId', description='jobId'),
      uploadURL: string(name='UploadURL', description='uploadUrl'),
      mediaId: string(name='MediaId', description='mediaId'),
      fileSize: string(name='FileSize', description='fileSize'),
      status: string(name='Status', description='status'),
      userData: string(name='UserData', description='userData'),
      errorCode: string(name='ErrorCode', description='errorCode'),
      errorMessage: string(name='ErrorMessage', description='errorMessage'),
      creationTime: string(name='CreationTime', description='creationTime'),
      completeTime: string(name='CompleteTime', description='completeTime'),
    }
  ](name='URLUploadInfoList', description='data.urlUploadInfoList'),
  nonExists: [ string ] (name='NonExists', description='data.nonExists'),
}

async function getURLUploadInfosWithOptions(request: GetURLUploadInfosRequest, runtime: Util.RuntimeOptions): GetURLUploadInfosResponse {
  Util.validateModel(request);
  return doRequest('GetURLUploadInfos', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getURLUploadInfos(request: GetURLUploadInfosRequest): GetURLUploadInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return getURLUploadInfosWithOptions(request, runtime);
}

model UpdateTranscodeTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name?: string(name='Name', description='name'),
  transcodeTemplateList?: string(name='TranscodeTemplateList', description='transcodeTemplateList'),
  locked?: string(name='Locked', description='locked'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
}

model UpdateTranscodeTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='data.transcodeTemplateGroupId'),
}

async function updateTranscodeTemplateGroupWithOptions(request: UpdateTranscodeTemplateGroupRequest, runtime: Util.RuntimeOptions): UpdateTranscodeTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateTranscodeTemplateGroup', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateTranscodeTemplateGroup(request: UpdateTranscodeTemplateGroupRequest): UpdateTranscodeTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTranscodeTemplateGroupWithOptions(request, runtime);
}

model AddTranscodeTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name?: string(name='Name', description='name'),
  transcodeTemplateList?: string(name='TranscodeTemplateList', description='transcodeTemplateList'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
  appId?: string(name='AppId', description='appId'),
}

model AddTranscodeTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='data.transcodeTemplateGroupId'),
}

async function addTranscodeTemplateGroupWithOptions(request: AddTranscodeTemplateGroupRequest, runtime: Util.RuntimeOptions): AddTranscodeTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('AddTranscodeTemplateGroup', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addTranscodeTemplateGroup(request: AddTranscodeTemplateGroupRequest): AddTranscodeTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTranscodeTemplateGroupWithOptions(request, runtime);
}

model DeleteTranscodeTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
  transcodeTemplateIds?: string(name='TranscodeTemplateIds', description='transcodeTemplateIdList'),
  forceDelGroup?: string(name='ForceDelGroup', description='forceDelGroup'),
}

model DeleteTranscodeTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistTranscodeTemplateIds: [ string ] (name='NonExistTranscodeTemplateIds', description='data.nonExistTranscodeTemplateIds'),
}

async function deleteTranscodeTemplateGroupWithOptions(request: DeleteTranscodeTemplateGroupRequest, runtime: Util.RuntimeOptions): DeleteTranscodeTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteTranscodeTemplateGroup', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteTranscodeTemplateGroup(request: DeleteTranscodeTemplateGroupRequest): DeleteTranscodeTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTranscodeTemplateGroupWithOptions(request, runtime);
}

model GetTranscodeTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
}

model GetTranscodeTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTemplateGroup: {
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
    name: string(name='Name', description='name'),
    isDefault: string(name='IsDefault', description='isDefault'),
    locked: string(name='Locked', description='locked'),
    transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
    appId: string(name='AppId', description='appId'),
    transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
    transcodeTemplateList: [
      {
        transcodeTemplateId: string(name='TranscodeTemplateId', description='transcodeStreamId'),
        video: string(name='Video', description='video'),
        audio: string(name='Audio', description='audio'),
        container: string(name='Container', description='container'),
        muxConfig: string(name='MuxConfig', description='muxConfig'),
        transConfig: string(name='TransConfig', description='transConfig'),
        definition: string(name='Definition', description='definition'),
        encryptSetting: string(name='EncryptSetting', description='encryptSetting'),
        packageSetting: string(name='PackageSetting', description='packageSetting'),
        subtitleList: string(name='SubtitleList', description='subtitleList'),
        openingList: string(name='OpeningList', description='openingList'),
        tailSlateList: string(name='TailSlateList', description='tailSlateList'),
        templateName: string(name='TemplateName', description='templateName'),
        transcodeFileRegular: string(name='TranscodeFileRegular', description='transcodeFileRegular'),
        clip: string(name='Clip', description='clip'),
        rotate: string(name='Rotate', description='rotate'),
        type: string(name='Type', description='type'),
        userData: string(name='UserData', description='userData'),
        watermarkIds: [ string ](name='WatermarkIds', description='watermarkIds'),
      }
    ](name='TranscodeTemplateList', description='transcodeTemplateList'),
  }(name='TranscodeTemplateGroup', description='data.transcodeTemplateGroup'),
}

async function getTranscodeTemplateGroupWithOptions(request: GetTranscodeTemplateGroupRequest, runtime: Util.RuntimeOptions): GetTranscodeTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('GetTranscodeTemplateGroup', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getTranscodeTemplateGroup(request: GetTranscodeTemplateGroupRequest): GetTranscodeTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTranscodeTemplateGroupWithOptions(request, runtime);
}

model SetDefaultTranscodeTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
}

model SetDefaultTranscodeTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setDefaultTranscodeTemplateGroupWithOptions(request: SetDefaultTranscodeTemplateGroupRequest, runtime: Util.RuntimeOptions): SetDefaultTranscodeTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultTranscodeTemplateGroup', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setDefaultTranscodeTemplateGroup(request: SetDefaultTranscodeTemplateGroupRequest): SetDefaultTranscodeTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultTranscodeTemplateGroupWithOptions(request, runtime);
}

model ListTranscodeTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  appId?: string(name='AppId', description='appId'),
}

model ListTranscodeTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTemplateGroupList: [
    {
      creationTime: string(name='CreationTime', description='creationTime'),
      modifyTime: string(name='ModifyTime', description='modifyTime'),
      name: string(name='Name', description='name'),
      isDefault: string(name='IsDefault', description='isDefault'),
      locked: string(name='Locked', description='locked'),
      transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='transcodeTemplateGroupId'),
      transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
      appId: string(name='AppId', description='appId'),
    }
  ](name='TranscodeTemplateGroupList', description='data.transcodeTemplateGroupList'),
}

async function listTranscodeTemplateGroupWithOptions(request: ListTranscodeTemplateGroupRequest, runtime: Util.RuntimeOptions): ListTranscodeTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('ListTranscodeTemplateGroup', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listTranscodeTemplateGroup(request: ListTranscodeTemplateGroupRequest): ListTranscodeTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTranscodeTemplateGroupWithOptions(request, runtime);
}

model GetAIMediaAuditJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  jobId: string(name='JobId', description='jobId'),
}

model GetAIMediaAuditJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    type: string(name='Type', description='type'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    completeTime: string(name='CompleteTime', description='completeTime'),
    data: {
      suggestion: string(name='Suggestion', description='suggestion'),
      abnormalModules: string(name='AbnormalModules', description='abnormalContent'),
      label: string(name='Label', description='label'),
      imageResult: [
        {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          type: string(name='Type', description='type'),
          url: string(name='Url', description='url'),
          result: [
            {
              suggestion: string(name='Suggestion', description='suggestion'),
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              scene: string(name='Scene', description='scene'),
            }
          ](name='Result', description='result'),
        }
      ](name='ImageResult', description='imageResult'),
      textResult: [
        {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          score: string(name='Score', description='score'),
          scene: string(name='Scene', description='scene'),
          type: string(name='Type', description='type'),
          content: string(name='Content', description='content'),
        }
      ](name='TextResult', description='textResult'),
      videoResult: {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        terrorismResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='TerrorismResult', description='terrorismResult'),
        pornResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='PornResult', description='pornResult'),
        adResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='AdResult', description='adResult'),
        liveResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='LiveResult', description='liveResult'),
        logoResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='LogoResult', description='logoResult'),
      }(name='VideoResult', description='videoResult'),
    }(name='Data', description='data'),
  }(name='MediaAuditJob', description='data.resultDTO'),
}

async function getAIMediaAuditJobWithOptions(request: GetAIMediaAuditJobRequest, runtime: Util.RuntimeOptions): GetAIMediaAuditJobResponse {
  Util.validateModel(request);
  return doRequest('GetAIMediaAuditJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getAIMediaAuditJob(request: GetAIMediaAuditJobRequest): GetAIMediaAuditJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAIMediaAuditJobWithOptions(request, runtime);
}

model SubmitAIMediaAuditJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  templateId?: string(name='TemplateId', description='templateId'),
  userData?: string(name='UserData', description='userData'),
  mediaType?: string(name='MediaType', description='mediaType'),
}

model SubmitAIMediaAuditJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
  jobId: string(name='JobId', description='data.jobId'),
}

async function submitAIMediaAuditJobWithOptions(request: SubmitAIMediaAuditJobRequest, runtime: Util.RuntimeOptions): SubmitAIMediaAuditJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIMediaAuditJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitAIMediaAuditJob(request: SubmitAIMediaAuditJobRequest): SubmitAIMediaAuditJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIMediaAuditJobWithOptions(request, runtime);
}

model GetMediaAuditResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetMediaAuditResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditResult: {
    abnormalModules: string(name='AbnormalModules', description='abnormalContent'),
    label: string(name='Label', description='label'),
    suggestion: string(name='Suggestion', description='suggestion'),
    imageResult: [
      {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        type: string(name='Type', description='type'),
        url: string(name='Url', description='url'),
        result: [
          {
            suggestion: string(name='Suggestion', description='suggestion'),
            label: string(name='Label', description='label'),
            score: string(name='Score', description='score'),
            scene: string(name='Scene', description='scene'),
          }
        ](name='Result', description='result'),
      }
    ](name='ImageResult', description='imageResult'),
    textResult: [
      {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        scene: string(name='Scene', description='scene'),
        type: string(name='Type', description='type'),
        content: string(name='Content', description='content'),
      }
    ](name='TextResult', description='textResult'),
    audioResult: [
      {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        scene: string(name='Scene', description='Scene'),
      }
    ](name='AudioResult', description='audioResult'),
    videoResult: {
      suggestion: string(name='Suggestion', description='suggestion'),
      label: string(name='Label', description='label'),
      terrorismResult: {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        maxScore: string(name='MaxScore', description='maxScore'),
        averageScore: string(name='AverageScore', description='averageScore'),
        counterList: [
          {
            label: string(name='Label', description='label'),
            count: integer(name='Count', description='count'),
          }
        ](name='CounterList', description='counterList'),
        topList: [
          {
            label: string(name='Label', description='label'),
            score: string(name='Score', description='score'),
            timestamp: string(name='Timestamp', description='timestamp'),
            url: string(name='Url', description='url'),
          }
        ](name='TopList', description='topList'),
      }(name='TerrorismResult', description='terrorismResult'),
      pornResult: {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        maxScore: string(name='MaxScore', description='maxScore'),
        averageScore: string(name='AverageScore', description='averageScore'),
        counterList: [
          {
            label: string(name='Label', description='label'),
            count: integer(name='Count', description='count'),
          }
        ](name='CounterList', description='counterList'),
        topList: [
          {
            label: string(name='Label', description='label'),
            score: string(name='Score', description='score'),
            timestamp: string(name='Timestamp', description='timestamp'),
            url: string(name='Url', description='url'),
          }
        ](name='TopList', description='topList'),
      }(name='PornResult', description='pornResult'),
    }(name='VideoResult', description='videoResult'),
  }(name='MediaAuditResult', description='data.resultDTO'),
}

async function getMediaAuditResultWithOptions(request: GetMediaAuditResultRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditResult', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMediaAuditResult(request: GetMediaAuditResultRequest): GetMediaAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultWithOptions(request, runtime);
}

model GetMediaAuditResultDetailRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  pageNo: integer(name='PageNo', description='pageNo'),
}

model GetMediaAuditResultDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditResultDetail: {
    total: integer(name='Total', description='total'),
    list: [
      {
        pornLabel: string(name='PornLabel', description='pornLabel'),
        pornScore: string(name='PornScore', description='pornScore'),
        terrorismLabel: string(name='TerrorismLabel', description='terrorismLabel'),
        terrorismScore: string(name='TerrorismScore', description='terrorismScore'),
        timestamp: string(name='Timestamp', description='timestamp'),
        url: string(name='Url', description='url'),
        adLabel: string(name='AdLabel', description='adLabel'),
        adScore: string(name='AdScore', description='adScore'),
        liveLabel: string(name='LiveLabel', description='liveLabel'),
        liveScore: string(name='LiveScore', description='liveScore'),
        logoLabel: string(name='LogoLabel', description='logoLabel'),
        logoScore: string(name='LogoScore', description='logoScore'),
      }
    ](name='List', description='list'),
  }(name='MediaAuditResultDetail', description='data.resultDTO'),
}

async function getMediaAuditResultDetailWithOptions(request: GetMediaAuditResultDetailRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultDetailResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditResultDetail', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMediaAuditResultDetail(request: GetMediaAuditResultDetailRequest): GetMediaAuditResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultDetailWithOptions(request, runtime);
}

model GetMediaAuditResultTimelineRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model GetMediaAuditResultTimelineResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditResultTimeline: {
    porn: [
      {
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        timestamp: string(name='Timestamp', description='timestamp'),
      }
    ](name='Porn', description='porn'),
    terrorism: [
      {
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        timestamp: string(name='Timestamp', description='timestamp'),
      }
    ](name='Terrorism', description='terrorism'),
  }(name='MediaAuditResultTimeline', description='data.resultDTO'),
}

async function getMediaAuditResultTimelineWithOptions(request: GetMediaAuditResultTimelineRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultTimelineResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditResultTimeline', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMediaAuditResultTimeline(request: GetMediaAuditResultTimelineRequest): GetMediaAuditResultTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultTimelineWithOptions(request, runtime);
}

model AddAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateName: string(name='TemplateName', description='templateName'),
  templateType: string(name='TemplateType', description='templateType'),
  templateConfig: string(name='TemplateConfig', description='templateConfig'),
}

model AddAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function addAITemplateWithOptions(request: AddAITemplateRequest, runtime: Util.RuntimeOptions): AddAITemplateResponse {
  Util.validateModel(request);
  return doRequest('AddAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addAITemplate(request: AddAITemplateRequest): AddAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAITemplateWithOptions(request, runtime);
}

model DeleteAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model DeleteAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function deleteAITemplateWithOptions(request: DeleteAITemplateRequest, runtime: Util.RuntimeOptions): DeleteAITemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteAITemplate(request: DeleteAITemplateRequest): DeleteAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAITemplateWithOptions(request, runtime);
}

model UpdateAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
  templateName: string(name='TemplateName', description='templateName'),
  templateConfig: string(name='TemplateConfig', description='templateConfig'),
}

model UpdateAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function updateAITemplateWithOptions(request: UpdateAITemplateRequest, runtime: Util.RuntimeOptions): UpdateAITemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateAITemplate(request: UpdateAITemplateRequest): UpdateAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAITemplateWithOptions(request, runtime);
}

model GetAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model GetAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateInfo: {
    templateId: string(name='TemplateId', description='templateId'),
    templateType: string(name='TemplateType', description='templateType'),
    templateName: string(name='TemplateName', description='templateName'),
    templateConfig: string(name='TemplateConfig', description='templateConfig'),
    source: string(name='Source', description='source'),
    isDefault: string(name='IsDefault', description='isDefault'),
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
  }(name='TemplateInfo', description='data.templateInfo'),
}

async function getAITemplateWithOptions(request: GetAITemplateRequest, runtime: Util.RuntimeOptions): GetAITemplateResponse {
  Util.validateModel(request);
  return doRequest('GetAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getAITemplate(request: GetAITemplateRequest): GetAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAITemplateWithOptions(request, runtime);
}

model ListAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateType: string(name='TemplateType', description='templateType'),
}

model ListAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateInfoList: [
    {
      templateId: string(name='TemplateId', description='templateId'),
      templateType: string(name='TemplateType', description='templateType'),
      templateName: string(name='TemplateName', description='templateName'),
      templateConfig: string(name='TemplateConfig', description='templateConfig'),
      source: string(name='Source', description='source'),
      isDefault: string(name='IsDefault', description='isDefault'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modifyTime: string(name='ModifyTime', description='modifyTime'),
    }
  ](name='TemplateInfoList', description='data.templateInfoList'),
}

async function listAITemplateWithOptions(request: ListAITemplateRequest, runtime: Util.RuntimeOptions): ListAITemplateResponse {
  Util.validateModel(request);
  return doRequest('ListAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listAITemplate(request: ListAITemplateRequest): ListAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAITemplateWithOptions(request, runtime);
}

model GetDefaultAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateType: string(name='TemplateType', description='templateType'),
}

model GetDefaultAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateInfo: {
    templateId: string(name='TemplateId', description='templateId'),
    templateType: string(name='TemplateType', description='templateType'),
    templateName: string(name='TemplateName', description='templateName'),
    templateConfig: string(name='TemplateConfig', description='templateConfig'),
    source: string(name='Source', description='source'),
    isDefault: string(name='IsDefault', description='isDefault'),
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
  }(name='TemplateInfo', description='data.templateInfo'),
}

async function getDefaultAITemplateWithOptions(request: GetDefaultAITemplateRequest, runtime: Util.RuntimeOptions): GetDefaultAITemplateResponse {
  Util.validateModel(request);
  return doRequest('GetDefaultAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getDefaultAITemplate(request: GetDefaultAITemplateRequest): GetDefaultAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultAITemplateWithOptions(request, runtime);
}

model SetDefaultAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model SetDefaultAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function setDefaultAITemplateWithOptions(request: SetDefaultAITemplateRequest, runtime: Util.RuntimeOptions): SetDefaultAITemplateResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultAITemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setDefaultAITemplate(request: SetDefaultAITemplateRequest): SetDefaultAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultAITemplateWithOptions(request, runtime);
}

model DescribeVodDomainLogRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  pageSize?: long(name='PageSize', description='pageSize'),
  pageNumber?: long(name='PageNumber', description='pageIndex'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainLogResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainLogDetails: {
    domainLogDetail: [
      {
        domainName: string(name='DomainName', description='domainName'),
        logCount: long(name='LogCount', description='logCount'),
        logInfos: {
          logInfoDetail: [
            {
              logName: string(name='LogName', description='logName'),
              logPath: string(name='LogPath', description='logPath'),
              logSize: long(name='LogSize', description='logSize'),
              startTime: string(name='StartTime', description='logDate'),
              endTime: string(name='EndTime', description='logEndDate'),
            }
          ](name='LogInfoDetail', description='LogInfoDetail'),
        }(name='LogInfos', description='logInfo'),
        pageInfos: {
          pageNumber: long(name='PageNumber', description='pageIndex'),
          pageSize: long(name='PageSize', description='pageSize'),
          total: long(name='Total', description='total'),
        }(name='PageInfos', description='pageInfo'),
      }
    ](name='DomainLogDetail', description='DomainLogDetail'),
  }(name='DomainLogDetails', description='data.content'),
}

async function describeVodDomainLogWithOptions(request: DescribeVodDomainLogRequest, runtime: Util.RuntimeOptions): DescribeVodDomainLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainLog', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodDomainLog(request: DescribeVodDomainLogRequest): DescribeVodDomainLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainLogWithOptions(request, runtime);
}

model DescribeVodDomainCertificateInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domain'),
}

model DescribeVodDomainCertificateInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  certInfos: {
    certInfo: [
      {
        domainName: string(name='DomainName', description='domain'),
        certName: string(name='CertName', description='cert_name'),
        certDomainName: string(name='CertDomainName', description='cert_domain'),
        certExpireTime: string(name='CertExpireTime', description='cert_expire_time'),
        certLife: string(name='CertLife', description='cert_life'),
        certOrg: string(name='CertOrg', description='cert_org'),
        certType: string(name='CertType', description='cert_type'),
        serverCertificateStatus: string(name='ServerCertificateStatus', description='https'),
        status: string(name='Status', description='status'),
      }
    ](name='CertInfo', description='CertInfo'),
  }(name='CertInfos', description='data.content'),
}

async function describeVodDomainCertificateInfoWithOptions(request: DescribeVodDomainCertificateInfoRequest, runtime: Util.RuntimeOptions): DescribeVodDomainCertificateInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainCertificateInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodDomainCertificateInfo(request: DescribeVodDomainCertificateInfoRequest): DescribeVodDomainCertificateInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainCertificateInfoWithOptions(request, runtime);
}

model DescribeVodDomainTrafficDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainTrafficDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  trafficDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_vod_all_all_all_traf'),
        domesticValue: string(name='DomesticValue', description='l1_vod_all_inner_all_traf'),
        overseasValue: string(name='OverseasValue', description='l1_vod_all_out_all_traf'),
        httpsValue: string(name='HttpsValue', description='l1_vod_all_all_https_traf'),
        httpsDomesticValue: string(name='HttpsDomesticValue', description='l1_vod_all_inner_https_traf'),
        httpsOverseasValue: string(name='HttpsOverseasValue', description='l1_vod_all_out_https_traf'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='TrafficDataPerInterval', description='data.content.data'),
}

async function describeVodDomainTrafficDataWithOptions(request: DescribeVodDomainTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainTrafficData', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodDomainTrafficData(request: DescribeVodDomainTrafficDataRequest): DescribeVodDomainTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainTrafficDataWithOptions(request, runtime);
}

model DescribeVodDomainBpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainBpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  locationNameEn: string(name='LocationNameEn', description='data.locName'),
  ispNameEn: string(name='IspNameEn', description='data.ispName'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  bpsDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_vod_all_all_all_bps'),
        domesticValue: string(name='DomesticValue', description='l1_vod_all_inner_all_bps'),
        overseasValue: string(name='OverseasValue', description='l1_vod_all_out_all_bps'),
        httpsValue: string(name='HttpsValue', description='l1_vod_all_all_https_bps'),
        httpsDomesticValue: string(name='HttpsDomesticValue', description='l1_vod_all_inner_https_bps'),
        httpsOverseasValue: string(name='HttpsOverseasValue', description='l1_vod_all_out_https_bps'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='BpsDataPerInterval', description='data.content.data'),
}

async function describeVodDomainBpsDataWithOptions(request: DescribeVodDomainBpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainBpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainBpsData', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodDomainBpsData(request: DescribeVodDomainBpsDataRequest): DescribeVodDomainBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainBpsDataWithOptions(request, runtime);
}

model DescribeVodDomainUsageDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  type?: string(name='Type', description='type'),
  area?: string(name='Area', description='area'),
  field: string(name='Field', description='field'),
}

model DescribeVodDomainUsageDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  type: string(name='Type', description='data.field'),
  area: string(name='Area', description='data.area'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  usageDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='value'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='UsageDataPerInterval', description='data.content.data'),
}

async function describeVodDomainUsageDataWithOptions(request: DescribeVodDomainUsageDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainUsageDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainUsageData', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describeVodDomainUsageData(request: DescribeVodDomainUsageDataRequest): DescribeVodDomainUsageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainUsageDataWithOptions(request, runtime);
}

model DescribeVodCertificateListRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName?: string(name='DomainName', description='domainName'),
}

model DescribeVodCertificateListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  certificateListModel: {
    count: integer(name='Count', description='count'),
    certList: {
      cert: [
        {
          certName: string(name='CertName', description='name'),
          certId: long(name='CertId', description='id'),
          fingerprint: string(name='Fingerprint', description='fingerprint'),
          common: string(name='Common', description='common'),
          issuer: string(name='Issuer', description='issuer'),
          lastTime: long(name='LastTime', description='lastTime'),
        }
      ](name='Cert', description='Cert'),
    }(name='CertList', description='certList'),
  }(name='CertificateListModel', description='data'),
}

async function describeVodCertificateListWithOptions(request: DescribeVodCertificateListRequest, runtime: Util.RuntimeOptions): DescribeVodCertificateListResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodCertificateList', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function describeVodCertificateList(request: DescribeVodCertificateListRequest): DescribeVodCertificateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodCertificateListWithOptions(request, runtime);
}

model BatchStopVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainNames: string(name='DomainNames', description='domainNames'),
}

model BatchStopVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function batchStopVodDomainWithOptions(request: BatchStopVodDomainRequest, runtime: Util.RuntimeOptions): BatchStopVodDomainResponse {
  Util.validateModel(request);
  return doRequest('BatchStopVodDomain', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function batchStopVodDomain(request: BatchStopVodDomainRequest): BatchStopVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStopVodDomainWithOptions(request, runtime);
}

model DeleteVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
}

model DeleteVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteVodDomainWithOptions(request: DeleteVodDomainRequest, runtime: Util.RuntimeOptions): DeleteVodDomainResponse {
  Util.validateModel(request);
  return doRequest('DeleteVodDomain', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteVodDomain(request: DeleteVodDomainRequest): DeleteVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVodDomainWithOptions(request, runtime);
}

model SetVodDomainCertificateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  certName?: string(name='CertName', description='certName'),
  SSLProtocol: string(name='SSLProtocol', description='sslProtocol'),
  SSLPub?: string(name='SSLPub', description='sslPub'),
  SSLPri?: string(name='SSLPri', description='sslPri'),
  region?: string(name='Region', description='region'),
}

model SetVodDomainCertificateResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setVodDomainCertificateWithOptions(request: SetVodDomainCertificateRequest, runtime: Util.RuntimeOptions): SetVodDomainCertificateResponse {
  Util.validateModel(request);
  return doRequest('SetVodDomainCertificate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setVodDomainCertificate(request: SetVodDomainCertificateRequest): SetVodDomainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setVodDomainCertificateWithOptions(request, runtime);
}

model DeleteVodSpecificConfigRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  configId: string(name='ConfigId', description='configId'),
}

model DeleteVodSpecificConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteVodSpecificConfigWithOptions(request: DeleteVodSpecificConfigRequest, runtime: Util.RuntimeOptions): DeleteVodSpecificConfigResponse {
  Util.validateModel(request);
  return doRequest('DeleteVodSpecificConfig', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteVodSpecificConfig(request: DeleteVodSpecificConfigRequest): DeleteVodSpecificConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVodSpecificConfigWithOptions(request, runtime);
}

model BatchSetVodDomainConfigsRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainNames: string(name='DomainNames', description='domainNames'),
  functions: string(name='Functions', description='functions'),
}

model BatchSetVodDomainConfigsResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function batchSetVodDomainConfigsWithOptions(request: BatchSetVodDomainConfigsRequest, runtime: Util.RuntimeOptions): BatchSetVodDomainConfigsResponse {
  Util.validateModel(request);
  return doRequest('BatchSetVodDomainConfigs', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function batchSetVodDomainConfigs(request: BatchSetVodDomainConfigsRequest): BatchSetVodDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetVodDomainConfigsWithOptions(request, runtime);
}

model AddVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  sources: string(name='Sources', description='sources'),
  checkUrl?: string(name='CheckUrl', description='checkUrl'),
  scope?: string(name='Scope', description='scope'),
}

model AddVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addVodDomainWithOptions(request: AddVodDomainRequest, runtime: Util.RuntimeOptions): AddVodDomainResponse {
  Util.validateModel(request);
  return doRequest('AddVodDomain', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addVodDomain(request: AddVodDomainRequest): AddVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVodDomainWithOptions(request, runtime);
}

model DescribeVodRefreshQuotaRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
}

model DescribeVodRefreshQuotaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  urlQuota: string(name='UrlQuota', description='data.urlQuota'),
  dirQuota: string(name='DirQuota', description='data.dirQuota'),
  urlRemain: string(name='UrlRemain', description='data.urlRemain'),
  dirRemain: string(name='DirRemain', description='data.dirRemain'),
  preloadQuota: string(name='PreloadQuota', description='data.preloadQuota'),
  blockQuota: string(name='BlockQuota', description='data.blockQuota'),
  preloadRemain: string(name='PreloadRemain', description='data.preloadRemain'),
  blockRemain: string(name='blockRemain', description='data.blockRemain'),
}

async function describeVodRefreshQuotaWithOptions(request: DescribeVodRefreshQuotaRequest, runtime: Util.RuntimeOptions): DescribeVodRefreshQuotaResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodRefreshQuota', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function describeVodRefreshQuota(request: DescribeVodRefreshQuotaRequest): DescribeVodRefreshQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodRefreshQuotaWithOptions(request, runtime);
}

model DescribeVodRefreshTasksRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  taskId?: string(name='TaskId', description='taskId'),
  objectPath?: string(name='ObjectPath', description='content'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  objectType?: string(name='ObjectType', description='taskType'),
  domainName?: string(name='DomainName', description='domainName'),
  status?: string(name='Status', description='taskStatusStr'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  resourceGroupId?: string(name='ResourceGroupId', description='resourceGroupId'),
}

model DescribeVodRefreshTasksResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: long(name='PageNumber', description='data.pageNumber'),
  pageSize: long(name='PageSize', description='data.pageSize'),
  totalCount: long(name='TotalCount', description='data.totalCount'),
  tasks: {
    task: [
      {
        taskId: string(name='TaskId', description='taskIdStr'),
        objectPath: string(name='ObjectPath', description='model.content'),
        process: string(name='Process', description='model.process'),
        status: string(name='Status', description='statusStr'),
        creationTime: string(name='CreationTime', description='model.gmtCreatedStr'),
        description: string(name='Description', description='model.description'),
        objectType: string(name='ObjectType', description='model.taskType'),
      }
    ](name='Task', description='Task'),
  }(name='Tasks', description='data.data'),
}

async function describeVodRefreshTasksWithOptions(request: DescribeVodRefreshTasksRequest, runtime: Util.RuntimeOptions): DescribeVodRefreshTasksResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodRefreshTasks', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function describeVodRefreshTasks(request: DescribeVodRefreshTasksRequest): DescribeVodRefreshTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodRefreshTasksWithOptions(request, runtime);
}

model DescribeVodDomainConfigsRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  functionNames: string(name='FunctionNames', description='functionNames'),
}

model DescribeVodDomainConfigsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainConfigs: {
    domainConfig: [
      {
        functionName: string(name='FunctionName', description='functionName'),
        configId: string(name='ConfigId', description='configId'),
        status: string(name='Status', description='status'),
        functionArgs: {
          functionArg: [
            {
              argName: string(name='ArgName', description='argName'),
              argValue: string(name='ArgValue', description='argValue'),
            }
          ](name='FunctionArg', description='FunctionArg'),
        }(name='FunctionArgs', description='functionArgs'),
      }
    ](name='DomainConfig', description='DomainConfig'),
  }(name='DomainConfigs', description='data'),
}

async function describeVodDomainConfigsWithOptions(request: DescribeVodDomainConfigsRequest, runtime: Util.RuntimeOptions): DescribeVodDomainConfigsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainConfigs', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function describeVodDomainConfigs(request: DescribeVodDomainConfigsRequest): DescribeVodDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainConfigsWithOptions(request, runtime);
}

model DescribeVodUserDomainsRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  domainName?: string(name='DomainName', description='domainName'),
  domainStatus?: string(name='DomainStatus', description='domainStatus'),
  domainSearchType?: string(name='DomainSearchType', description='domainSearchType'),
  cdnType?: string(name='CdnType', description='webSiteType'),
  checkDomainShow?: boolean(name='CheckDomainShow', description='checkDomainShow'),
  funcId?: string(name='FuncId', description='funcId'),
  funcFilter?: string(name='FuncFilter', description='funcFilter'),
}

model DescribeVodUserDomainsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: long(name='PageNumber', description='data.pageNumber'),
  pageSize: long(name='PageSize', description='data.pageSize'),
  totalCount: long(name='TotalCount', description='data.totalCount'),
  domains: {
    pageData: [
      {
        domainName: string(name='DomainName', description='model.domainNameReal'),
        cname: string(name='Cname', description='model.cname'),
        cdnType: string(name='CdnType', description='websiteTypeStr'),
        domainStatus: string(name='DomainStatus', description='domainStatusStr'),
        gmtCreated: string(name='GmtCreated', description='gmtCreatedStr'),
        gmtModified: string(name='GmtModified', description='gmtModifiedStr'),
        description: string(name='Description', description='model.remark'),
        sslProtocol: string(name='SslProtocol', description='sslProtocol'),
        weight: string(name='Weight', description='weight'),
        sandbox: string(name='Sandbox', description='model.sandbox'),
        sources: {
          source: [
            {
              type: string(name='Type', description='type'),
              content: string(name='Content', description='content'),
              port: integer(name='Port', description='port'),
              priority: string(name='Priority', description='priority'),
            }
          ](name='Source', description='Source'),
        }(name='Sources', description='sources'),
      }
    ](name='PageData', description='PageData'),
  }(name='Domains', description='data.data'),
}

async function describeVodUserDomainsWithOptions(request: DescribeVodUserDomainsRequest, runtime: Util.RuntimeOptions): DescribeVodUserDomainsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodUserDomains', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function describeVodUserDomains(request: DescribeVodUserDomainsRequest): DescribeVodUserDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodUserDomainsWithOptions(request, runtime);
}

model UpdateVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  sources?: string(name='Sources', description='sources'),
  topLevelDomain?: string(name='TopLevelDomain', description='topLevelDomain'),
}

model UpdateVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateVodDomainWithOptions(request: UpdateVodDomainRequest, runtime: Util.RuntimeOptions): UpdateVodDomainResponse {
  Util.validateModel(request);
  return doRequest('UpdateVodDomain', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateVodDomain(request: UpdateVodDomainRequest): UpdateVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVodDomainWithOptions(request, runtime);
}

model RefreshVodObjectCachesRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  objectPath: string(name='ObjectPath', description='objectPath'),
  objectType?: string(name='ObjectType', description='objectType'),
}

model RefreshVodObjectCachesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  refreshTaskId: string(name='RefreshTaskId', description='data'),
}

async function refreshVodObjectCachesWithOptions(request: RefreshVodObjectCachesRequest, runtime: Util.RuntimeOptions): RefreshVodObjectCachesResponse {
  Util.validateModel(request);
  return doRequest('RefreshVodObjectCaches', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function refreshVodObjectCaches(request: RefreshVodObjectCachesRequest): RefreshVodObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshVodObjectCachesWithOptions(request, runtime);
}

model PreloadVodObjectCachesRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  objectPath: string(name='ObjectPath', description='objectPath'),
}

model PreloadVodObjectCachesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  preloadTaskId: string(name='PreloadTaskId', description='data'),
}

async function preloadVodObjectCachesWithOptions(request: PreloadVodObjectCachesRequest, runtime: Util.RuntimeOptions): PreloadVodObjectCachesResponse {
  Util.validateModel(request);
  return doRequest('PreloadVodObjectCaches', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function preloadVodObjectCaches(request: PreloadVodObjectCachesRequest): PreloadVodObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return preloadVodObjectCachesWithOptions(request, runtime);
}

model BatchStartVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainNames: string(name='DomainNames', description='domainNames'),
}

model BatchStartVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function batchStartVodDomainWithOptions(request: BatchStartVodDomainRequest, runtime: Util.RuntimeOptions): BatchStartVodDomainResponse {
  Util.validateModel(request);
  return doRequest('BatchStartVodDomain', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function batchStartVodDomain(request: BatchStartVodDomainRequest): BatchStartVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchStartVodDomainWithOptions(request, runtime);
}

model DescribeVodDomainDetailRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
}

model DescribeVodDomainDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainDetail: {
    gmtCreated: string(name='GmtCreated', description='gmtCreated'),
    gmtModified: string(name='GmtModified', description='gmtModified'),
    domainStatus: string(name='DomainStatus', description='domainStatus'),
    cname: string(name='Cname', description='cname'),
    domainName: string(name='DomainName', description='domainName'),
    description: string(name='Description', description='remark'),
    SSLProtocol: string(name='SSLProtocol', description='sslProtocol'),
    SSLPub: string(name='SSLPub', description='sslPub'),
    scope: string(name='Scope', description='scope'),
    certName: string(name='CertName', description='certName'),
    weight: string(name='Weight', description='weight'),
    sources: {
      source: [
        {
          content: string(name='Content', description='content'),
          type: string(name='Type', description='type'),
          port: integer(name='Port', description='port'),
          enabled: string(name='Enabled', description='enabled'),
          priority: string(name='Priority', description='priority'),
        }
      ](name='Source', description='Source'),
    }(name='Sources', description='sources'),
  }(name='DomainDetail', description='data'),
}

async function describeVodDomainDetailWithOptions(request: DescribeVodDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeVodDomainDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainDetail', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function describeVodDomainDetail(request: DescribeVodDomainDetailRequest): DescribeVodDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainDetailWithOptions(request, runtime);
}

model DeleteVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
}

model DeleteVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function deleteVodTemplateWithOptions(request: DeleteVodTemplateRequest, runtime: Util.RuntimeOptions): DeleteVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteVodTemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteVodTemplate(request: DeleteVodTemplateRequest): DeleteVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVodTemplateWithOptions(request, runtime);
}

model GetVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
}

model GetVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateInfo: {
    name: string(name='Name', description='name'),
    vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
    templateType: string(name='TemplateType', description='templateType'),
    subTemplateType: string(name='SubTemplateType', description='subTemplateType'),
    source: string(name='Source', description='source'),
    isDefault: string(name='IsDefault', description='isDefault'),
    templateConfig: string(name='TemplateConfig', description='templateConfig'),
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
  }(name='VodTemplateInfo', description='data.vodTemplateInfo'),
}

async function getVodTemplateWithOptions(request: GetVodTemplateRequest, runtime: Util.RuntimeOptions): GetVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('GetVodTemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getVodTemplate(request: GetVodTemplateRequest): GetVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVodTemplateWithOptions(request, runtime);
}

model ListVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateType: string(name='TemplateType', description='templateType'),
  appId?: string(name='AppId', description='appId'),
}

model ListVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateInfoList: [
    {
      name: string(name='Name', description='name'),
      vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
      templateType: string(name='TemplateType', description='templateType'),
      subTemplateType: string(name='SubTemplateType', description='subTemplateType'),
      source: string(name='Source', description='source'),
      isDefault: string(name='IsDefault', description='isDefault'),
      templateConfig: string(name='TemplateConfig', description='templateConfig'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modifyTime: string(name='ModifyTime', description='modifyTime'),
      appId: string(name='AppId', description='appId'),
    }
  ](name='VodTemplateInfoList', description='data.vodTemplateInfoList'),
}

async function listVodTemplateWithOptions(request: ListVodTemplateRequest, runtime: Util.RuntimeOptions): ListVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('ListVodTemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listVodTemplate(request: ListVodTemplateRequest): ListVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVodTemplateWithOptions(request, runtime);
}

model UpdateVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
  name?: string(name='Name', description='name'),
  templateConfig?: string(name='TemplateConfig', description='templateConfig'),
}

model UpdateVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function updateVodTemplateWithOptions(request: UpdateVodTemplateRequest, runtime: Util.RuntimeOptions): UpdateVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateVodTemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateVodTemplate(request: UpdateVodTemplateRequest): UpdateVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVodTemplateWithOptions(request, runtime);
}

model AddVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name: string(name='Name', description='name'),
  templateType: string(name='TemplateType', description='templateType'),
  subTemplateType?: string(name='SubTemplateType', description='subTemplateType'),
  templateConfig: string(name='TemplateConfig', description='templateConfig'),
  appId?: string(name='AppId', description='appId'),
}

model AddVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function addVodTemplateWithOptions(request: AddVodTemplateRequest, runtime: Util.RuntimeOptions): AddVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('AddVodTemplate', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addVodTemplate(request: AddVodTemplateRequest): AddVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVodTemplateWithOptions(request, runtime);
}

model CreateUploadAttachedMediaRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  title?: string(name='Title', description='title'),
  businessType: string(name='BusinessType', description='mediaType'),
  mediaExt?: string(name='MediaExt', description='mediaExt'),
  fileName?: string(name='FileName', description='originalFileName'),
  fileSize?: string(name='FileSize', description='fileSize'),
  tags?: string(name='Tags', description='tags'),
  cateId?: long(name='CateId', description='cateId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  description?: string(name='Description', description='description'),
  userData?: string(name='UserData', description='userData'),
  cateIds?: string(name='CateIds', description='cateIds'),
  appId?: string(name='AppId', description='appId'),
  icon?: string(name='Icon', description='icon'),
}

model CreateUploadAttachedMediaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
  mediaURL: string(name='MediaURL', description='data.mediaUrl'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
  fileURL: string(name='FileURL', description='data.fileUrl'),
}

async function createUploadAttachedMediaWithOptions(request: CreateUploadAttachedMediaRequest, runtime: Util.RuntimeOptions): CreateUploadAttachedMediaResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadAttachedMedia', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function createUploadAttachedMedia(request: CreateUploadAttachedMediaRequest): CreateUploadAttachedMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadAttachedMediaWithOptions(request, runtime);
}

model RegisterMediaRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  registerMetadatas: string(name='RegisterMetadatas', description='registerMetadatas'),
  templateGroupId?: string(name='TemplateGroupId', description='templateGroupId'),
  userData?: string(name='UserData', description='userData'),
  workflowId?: string(name='WorkflowId', description='workflowId'),
}

model RegisterMediaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  registeredMediaList: [
    {
      mediaId: string(name='MediaId', description='mediaId'),
      fileURL: string(name='FileURL', description='fileURL'),
      newRegister: boolean(name='NewRegister', description='newRegister'),
    }
  ](name='RegisteredMediaList', description='data.registeredMediaList'),
  failedFileURLs: [ string ] (name='FailedFileURLs', description='data.failedFileURLs'),
}

async function registerMediaWithOptions(request: RegisterMediaRequest, runtime: Util.RuntimeOptions): RegisterMediaResponse {
  Util.validateModel(request);
  return doRequest('RegisterMedia', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function registerMedia(request: RegisterMediaRequest): RegisterMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaWithOptions(request, runtime);
}

model DeleteWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
}

model DeleteWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteWatermarkWithOptions(request: DeleteWatermarkRequest, runtime: Util.RuntimeOptions): DeleteWatermarkResponse {
  Util.validateModel(request);
  return doRequest('DeleteWatermark', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteWatermark(request: DeleteWatermarkRequest): DeleteWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatermarkWithOptions(request, runtime);
}

model GetWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
}

model GetWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarkInfo: {
    creationTime: string(name='CreationTime', description='creationTime'),
    type: string(name='Type', description='type'),
    isDefault: string(name='IsDefault', description='isDefault'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    name: string(name='Name', description='name'),
    fileUrl: string(name='FileUrl', description='fileUrl'),
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
    appId: string(name='AppId', description='appId'),
  }(name='WatermarkInfo', description='data.watermarkDto'),
}

async function getWatermarkWithOptions(request: GetWatermarkRequest, runtime: Util.RuntimeOptions): GetWatermarkResponse {
  Util.validateModel(request);
  return doRequest('GetWatermark', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getWatermark(request: GetWatermarkRequest): GetWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkWithOptions(request, runtime);
}

model SetDefaultWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
}

model SetDefaultWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setDefaultWatermarkWithOptions(request: SetDefaultWatermarkRequest, runtime: Util.RuntimeOptions): SetDefaultWatermarkResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultWatermark', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setDefaultWatermark(request: SetDefaultWatermarkRequest): SetDefaultWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultWatermarkWithOptions(request, runtime);
}

model ListWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  appId?: string(name='AppId', description='appId'),
}

model ListWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarkInfos: [
    {
      creationTime: string(name='CreationTime', description='creationTime'),
      type: string(name='Type', description='type'),
      isDefault: string(name='IsDefault', description='isDefault'),
      watermarkId: string(name='WatermarkId', description='watermarkId'),
      name: string(name='Name', description='name'),
      fileUrl: string(name='FileUrl', description='fileUrl'),
      watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
      appId: string(name='AppId', description='appId'),
    }
  ](name='WatermarkInfos', description='data.watermarkDtos'),
}

async function listWatermarkWithOptions(request: ListWatermarkRequest, runtime: Util.RuntimeOptions): ListWatermarkResponse {
  Util.validateModel(request);
  return doRequest('ListWatermark', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listWatermark(request: ListWatermarkRequest): ListWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWatermarkWithOptions(request, runtime);
}

model UpdateWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name?: string(name='Name', description='name'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
  watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
}

model UpdateWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarkInfo: {
    creationTime: string(name='CreationTime', description='creationTime'),
    type: string(name='Type', description='type'),
    isDefault: string(name='IsDefault', description='isDefault'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    name: string(name='Name', description='name'),
    fileUrl: string(name='FileUrl', description='fileUrl'),
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  }(name='WatermarkInfo', description='data.watermarkDto'),
}

async function updateWatermarkWithOptions(request: UpdateWatermarkRequest, runtime: Util.RuntimeOptions): UpdateWatermarkResponse {
  Util.validateModel(request);
  return doRequest('UpdateWatermark', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateWatermark(request: UpdateWatermarkRequest): UpdateWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatermarkWithOptions(request, runtime);
}

model AddWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  type: string(name='Type', description='type'),
  name: string(name='Name', description='name'),
  watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
  appId?: string(name='AppId', description='appId'),
}

model AddWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarkInfo: {
    creationTime: string(name='CreationTime', description='creationTime'),
    type: string(name='Type', description='type'),
    isDefault: string(name='IsDefault', description='isDefault'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    name: string(name='Name', description='name'),
    fileUrl: string(name='FileUrl', description='fileUrl'),
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  }(name='WatermarkInfo', description='data.watermarkDto'),
}

async function addWatermarkWithOptions(request: AddWatermarkRequest, runtime: Util.RuntimeOptions): AddWatermarkResponse {
  Util.validateModel(request);
  return doRequest('AddWatermark', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addWatermark(request: AddWatermarkRequest): AddWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWatermarkWithOptions(request, runtime);
}

model GetMediaDNAResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model GetMediaDNAResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  DNAResult: {
    videoDNA: [
      {
        primaryKey: string(name='PrimaryKey', description='primaryKey'),
        similarity: string(name='Similarity', description='similarity'),
        detail: [
          {
            input: {
              start: string(name='Start', description='start'),
              duration: string(name='Duration', description='duration'),
            }(name='Input', description='input'),
            duplication: {
              start: string(name='Start', description='start'),
              duration: string(name='Duration', description='duration'),
            }(name='Duplication', description='duplication'),
          }
        ](name='Detail', description='fpShotSlices'),
      }
    ](name='VideoDNA', description='videoDNA'),
  }(name='DNAResult', description='data.resultDTO'),
}

async function getMediaDNAResultWithOptions(request: GetMediaDNAResultRequest, runtime: Util.RuntimeOptions): GetMediaDNAResultResponse {
  Util.validateModel(request);
  return doRequest('GetMediaDNAResult', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMediaDNAResult(request: GetMediaDNAResultRequest): GetMediaDNAResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaDNAResultWithOptions(request, runtime);
}

model DeleteMezzaninesRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIdStr'),
  force?: boolean(name='Force', description='force'),
}

model DeleteMezzaninesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
  unRemoveableVideoIds: [ string ] (name='UnRemoveableVideoIds', description='data.unremoveableVideoIds'),
}

async function deleteMezzaninesWithOptions(request: DeleteMezzaninesRequest, runtime: Util.RuntimeOptions): DeleteMezzaninesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMezzanines', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteMezzanines(request: DeleteMezzaninesRequest): DeleteMezzaninesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMezzaninesWithOptions(request, runtime);
}

model UpdateImageInfosRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  updateContent: string(name='UpdateContent', description='updateContent'),
}

model UpdateImageInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistImageIds: {
    imageId: [ string ](name='ImageId', description='ImageId'),
  }(name='NonExistImageIds', description='data.nonExistImageIds'),
}

async function updateImageInfosWithOptions(request: UpdateImageInfosRequest, runtime: Util.RuntimeOptions): UpdateImageInfosResponse {
  Util.validateModel(request);
  return doRequest('UpdateImageInfos', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateImageInfos(request: UpdateImageInfosRequest): UpdateImageInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageInfosWithOptions(request, runtime);
}

model DeleteImageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  deleteImageType: string(name='DeleteImageType', description='deleteImageType'),
  imageURLs?: string(name='ImageURLs', description='imageURLs'),
  imageIds?: string(name='ImageIds', description='imageIds'),
  videoId?: string(name='VideoId', description='videoId'),
  imageType?: string(name='ImageType', description='imageType'),
}

model DeleteImageResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  return doRequest('DeleteImage', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model ListAuditSecurityIpRequest = {
  securityGroupName?: string(name='SecurityGroupName', description='securityGroupName'),
}

model ListAuditSecurityIpResponse = {
  requestId: string(name='RequestId', description='requestId'),
  securityIpList: [
    {
      securityGroupName: string(name='SecurityGroupName', description='securityGroupName'),
      ips: string(name='Ips', description='ips'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modificationTime: string(name='ModificationTime', description='modifyTime'),
    }
  ](name='SecurityIpList', description='data.auditSecurityGroupDTOS'),
}

async function listAuditSecurityIpWithOptions(request: ListAuditSecurityIpRequest, runtime: Util.RuntimeOptions): ListAuditSecurityIpResponse {
  Util.validateModel(request);
  return doRequest('ListAuditSecurityIp', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listAuditSecurityIp(request: ListAuditSecurityIpRequest): ListAuditSecurityIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAuditSecurityIpWithOptions(request, runtime);
}

model SetAuditSecurityIpRequest = {
  securityGroupName?: string(name='SecurityGroupName', description='securityGroupName'),
  ips: string(name='Ips', description='ips'),
  operateMode?: string(name='OperateMode', description='operateMode'),
}

model SetAuditSecurityIpResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setAuditSecurityIpWithOptions(request: SetAuditSecurityIpRequest, runtime: Util.RuntimeOptions): SetAuditSecurityIpResponse {
  Util.validateModel(request);
  return doRequest('SetAuditSecurityIp', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setAuditSecurityIp(request: SetAuditSecurityIpRequest): SetAuditSecurityIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAuditSecurityIpWithOptions(request, runtime);
}

model UploadMediaByURLRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  uploadURLs: string(name='UploadURLs', description='uploadURLs'),
  templateGroupId?: string(name='TemplateGroupId', description='templateGroupId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  uploadMetadatas?: string(name='UploadMetadatas', description='uploadMetadatas'),
  priority?: string(name='Priority', description='priority'),
  messageCallback?: string(name='MessageCallback', description='messageCallback'),
  userData?: string(name='UserData', description='userData'),
  appId?: string(name='AppId', description='appId'),
  workflowId?: string(name='WorkflowId', description='workflowId'),
}

model UploadMediaByURLResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadJobs: [
    {
      jobId: string(name='JobId', description='jobId'),
      sourceURL: string(name='SourceURL', description='sourceUrl'),
    }
  ](name='UploadJobs', description='data.uploadJobs'),
}

async function uploadMediaByURLWithOptions(request: UploadMediaByURLRequest, runtime: Util.RuntimeOptions): UploadMediaByURLResponse {
  Util.validateModel(request);
  return doRequest('UploadMediaByURL', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function uploadMediaByURL(request: UploadMediaByURLRequest): UploadMediaByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMediaByURLWithOptions(request, runtime);
}

model UpdateVideoInfosRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  updateContent: string(name='UpdateContent', description='updateContent'),
}

model UpdateVideoInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
  forbiddenVideoIds: [ string ] (name='ForbiddenVideoIds', description='data.forbiddenVideoIds'),
}

async function updateVideoInfosWithOptions(request: UpdateVideoInfosRequest, runtime: Util.RuntimeOptions): UpdateVideoInfosResponse {
  Util.validateModel(request);
  return doRequest('UpdateVideoInfos', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateVideoInfos(request: UpdateVideoInfosRequest): UpdateVideoInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVideoInfosWithOptions(request, runtime);
}

model SearchMediaRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  searchType?: string(name='SearchType', description='searchType'),
  fields?: string(name='Fields', description='fields'),
  match?: string(name='Match', description='match'),
  sortBy?: string(name='SortBy', description='sortBy'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  scrollToken?: string(name='ScrollToken', description='scrollToken'),
  sessionId?: string(name='SessionId', description='sessionId'),
}

model SearchMediaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  scrollToken: string(name='ScrollToken', description='data.scrollToken'),
  total: long(name='Total', description='data.total'),
  mediaList: [
    {
      mediaType: string(name='MediaType', description='mediaType'),
      creationTime: string(name='CreationTime', description='creationTime'),
      mediaId: string(name='MediaId', description='mediaId'),
      video: {
        videoId: string(name='VideoId', description='mediaId'),
        mediaSource: string(name='MediaSource', description='source'),
        mediaType: string(name='MediaType', description='type'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        downloadSwitch: string(name='DownloadSwitch', description='download'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
        auditStatus: string(name='AuditStatus', description='auditStatus'),
        auditAIStatus: string(name='AuditAIStatus', description='auditAIStatus'),
        auditManualStatus: string(name='AuditManualStatus', description='auditManualStatus'),
        auditAIResult: string(name='AuditAIResult', description='auditAIResult'),
        auditTemplateId: string(name='AuditTemplateId', description='auditTemplateId'),
        customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
        appId: string(name='AppId', description='appId'),
        snapshots: [ string ](name='Snapshots', description='snapshots'),
        spriteSnapshots: [ string ](name='SpriteSnapshots', description='spriteImages'),
      }(name='Video', description='video'),
      audio: {
        audioId: string(name='AudioId', description='mediaId'),
        mediaSource: string(name='MediaSource', description='source'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        downloadSwitch: string(name='DownloadSwitch', description='download'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
        auditStatus: string(name='AuditStatus', description='auditStatus'),
        auditAIStatus: string(name='AuditAIStatus', description='auditAIStatus'),
        auditManualStatus: string(name='AuditManualStatus', description='auditManualStatus'),
        auditAIResult: string(name='AuditAIResult', description='auditAIResult'),
        auditTemplateId: string(name='AuditTemplateId', description='auditTemplateId'),
        customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
        appId: string(name='AppId', description='appId'),
        snapshots: [ string ](name='Snapshots', description='snapshots'),
        spriteSnapshots: [ string ](name='SpriteSnapshots', description='spriteImages'),
      }(name='Audio', description='audio'),
      image: {
        title: string(name='Title', description='title'),
        imageId: string(name='ImageId', description='imageId'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        ext: string(name='Ext', description='ext'),
        creationTime: string(name='CreationTime', description='ct'),
        modificationTime: string(name='ModificationTime', description='mt'),
        tags: string(name='Tags', description='tags'),
        type: string(name='Type', description='type'),
        URL: string(name='URL', description='url'),
        status: string(name='Status', description='status'),
        description: string(name='Description', description='desc'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        appId: string(name='AppId', description='appId'),
      }(name='Image', description='image'),
      attachedMedia: {
        title: string(name='Title', description='title'),
        mediaId: string(name='MediaId', description='mediaId'),
        ext: string(name='Ext', description='ext'),
        creationTime: string(name='CreationTime', description='ct'),
        modificationTime: string(name='ModificationTime', description='mt'),
        tags: string(name='Tags', description='tags'),
        businessType: string(name='BusinessType', description='type'),
        URL: string(name='URL', description='url'),
        status: string(name='Status', description='status'),
        description: string(name='Description', description='desc'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        appId: string(name='AppId', description='appId'),
        icon: string(name='Icon', description='icon'),
        onlineStatus: string(name='OnlineStatus', description='onlineStatus'),
        categories: [
          {
            cateId: long(name='CateId', description='cateId'),
            cateName: string(name='CateName', description='cateName'),
            level: long(name='Level', description='level'),
            parentId: long(name='ParentId', description='parentId'),
          }
        ](name='Categories', description='categories'),
      }(name='AttachedMedia', description='attachedMedia'),
    }
  ](name='MediaList', description='data.mediaDTOList'),
}

async function searchMediaWithOptions(request: SearchMediaRequest, runtime: Util.RuntimeOptions): SearchMediaResponse {
  Util.validateModel(request);
  return doRequest('SearchMedia', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWithOptions(request, runtime);
}

model GetVideoInfosRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIds'),
  additionType?: string(name='AdditionType', description='additionType'),
}

model GetVideoInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoList: [
    {
      videoId: string(name='VideoId', description='mediaId'),
      title: string(name='Title', description='title'),
      tags: string(name='Tags', description='tags'),
      status: string(name='Status', description='state'),
      size: long(name='Size', description='fileSize'),
      duration: float(name='Duration', description='duration'),
      description: string(name='Description', description='description'),
      modificationTime: string(name='ModificationTime', description='modificationTime'),
      creationTime: string(name='CreationTime', description='creationTime'),
      coverURL: string(name='CoverURL', description='coverUrl'),
      cateId: long(name='CateId', description='cateId'),
      cateName: string(name='CateName', description='cateName'),
      downloadSwitch: string(name='DownloadSwitch', description='download'),
      templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
      preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
      storageLocation: string(name='StorageLocation', description='storageLocation'),
      regionId: string(name='RegionId', description='regionId'),
      customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
      appId: string(name='AppId', description='appId'),
      thumbnailList: [
        {
          URL: string(name='URL', description='url'),
        }
      ](name='ThumbnailList', description='thumbnailList'),
      snapshots: [ string ](name='Snapshots', description='snapshots'),
    }
  ](name='VideoList', description='data.mediaInfoDTOS'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
}

async function getVideoInfosWithOptions(request: GetVideoInfosRequest, runtime: Util.RuntimeOptions): GetVideoInfosResponse {
  Util.validateModel(request);
  return doRequest('GetVideoInfos', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getVideoInfos(request: GetVideoInfosRequest): GetVideoInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoInfosWithOptions(request, runtime);
}

model SubmitPreprocessJobsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  preprocessType: string(name='PreprocessType', description='preprocessType'),
}

model SubmitPreprocessJobsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  preprocessJobs: {
    preprocessJob: [
      {
        jobId: string(name='JobId', description='jobId'),
      }
    ](name='PreprocessJob', description='PreprocessJob'),
  }(name='PreprocessJobs', description='data.transcodeJobs'),
}

async function submitPreprocessJobsWithOptions(request: SubmitPreprocessJobsRequest, runtime: Util.RuntimeOptions): SubmitPreprocessJobsResponse {
  Util.validateModel(request);
  return doRequest('SubmitPreprocessJobs', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitPreprocessJobs(request: SubmitPreprocessJobsRequest): SubmitPreprocessJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitPreprocessJobsWithOptions(request, runtime);
}

model DescribePlayVideoStatisRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  videoId: string(name='VideoId', description='videoId'),
}

model DescribePlayVideoStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoPlayStatisDetails: {
    videoPlayStatisDetail: [
      {
        date: string(name='Date', description='date'),
        playDuration: string(name='PlayDuration', description='playTime'),
        VV: string(name='VV', description='vv'),
        UV: string(name='UV', description='uv'),
        playRange: string(name='PlayRange', description='playRange'),
        title: string(name='Title', description='title'),
      }
    ](name='VideoPlayStatisDetail', description='VideoPlayStatisDetail'),
  }(name='VideoPlayStatisDetails', description='data.content.list'),
}

async function describePlayVideoStatisWithOptions(request: DescribePlayVideoStatisRequest, runtime: Util.RuntimeOptions): DescribePlayVideoStatisResponse {
  Util.validateModel(request);
  return doRequest('DescribePlayVideoStatis', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describePlayVideoStatis(request: DescribePlayVideoStatisRequest): DescribePlayVideoStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayVideoStatisWithOptions(request, runtime);
}

model DescribePlayUserTotalRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribePlayUserTotalResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisTotals: {
    userPlayStatisTotal: [
      {
        date: string(name='Date', description='date'),
        playDuration: string(name='PlayDuration', description='playTime'),
        playRange: string(name='PlayRange', description='playRange'),
        VV: {
          android: string(name='Android', description='android'),
          iOS: string(name='iOS', description='ios'),
          flash: string(name='Flash', description='flash'),
          HTML5: string(name='HTML5', description='h5'),
        }(name='VV', description='vv'),
        UV: {
          android: string(name='Android', description='android'),
          iOS: string(name='iOS', description='ios'),
          flash: string(name='Flash', description='flash'),
          HTML5: string(name='HTML5', description='h5'),
        }(name='UV', description='uv'),
      }
    ](name='UserPlayStatisTotal', description='UserPlayStatisTotal'),
  }(name='UserPlayStatisTotals', description='data.content.list'),
}

async function describePlayUserTotalWithOptions(request: DescribePlayUserTotalRequest, runtime: Util.RuntimeOptions): DescribePlayUserTotalResponse {
  Util.validateModel(request);
  return doRequest('DescribePlayUserTotal', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describePlayUserTotal(request: DescribePlayUserTotalRequest): DescribePlayUserTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayUserTotalWithOptions(request, runtime);
}

model DescribePlayUserAvgRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribePlayUserAvgResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisAvgs: {
    userPlayStatisAvg: [
      {
        date: string(name='Date', description='date'),
        avgPlayDuration: string(name='AvgPlayDuration', description='avgPlayTime'),
        avgPlayCount: string(name='AvgPlayCount', description='avgPlayCount'),
      }
    ](name='UserPlayStatisAvg', description='UserPlayStatisAvg'),
  }(name='UserPlayStatisAvgs', description='data.content.list'),
}

async function describePlayUserAvgWithOptions(request: DescribePlayUserAvgRequest, runtime: Util.RuntimeOptions): DescribePlayUserAvgResponse {
  Util.validateModel(request);
  return doRequest('DescribePlayUserAvg', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describePlayUserAvg(request: DescribePlayUserAvgRequest): DescribePlayUserAvgResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayUserAvgWithOptions(request, runtime);
}

model DescribePlayTopVideosRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  bizDate: string(name='BizDate', description='bizdate'),
  pageNo?: long(name='PageNo', description='pageNum'),
  pageSize?: long(name='PageSize', description='pageSize'),
}

model DescribePlayTopVideosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageNo: long(name='PageNo', description='data.content.pageNum'),
  pageSize: long(name='PageSize', description='data.content.pageSize'),
  totalNum: long(name='TotalNum', description='data.content.totalNum'),
  topPlayVideos: {
    topPlayVideoStatis: [
      {
        playDuration: string(name='PlayDuration', description='playtime'),
        VV: string(name='VV', description='vv'),
        UV: string(name='UV', description='uv'),
        videoId: string(name='VideoId', description='videoid'),
        title: string(name='Title', description='title'),
      }
    ](name='TopPlayVideoStatis', description='TopPlayVideoStatis'),
  }(name='TopPlayVideos', description='data.content.list'),
}

async function describePlayTopVideosWithOptions(request: DescribePlayTopVideosRequest, runtime: Util.RuntimeOptions): DescribePlayTopVideosResponse {
  Util.validateModel(request);
  return doRequest('DescribePlayTopVideos', 'HTTPS', 'POST', '2017-03-21', 'AK', request, null, runtime);
}

async function describePlayTopVideos(request: DescribePlayTopVideosRequest): DescribePlayTopVideosResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayTopVideosWithOptions(request, runtime);
}

model ListSnapshotsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  snapshotType?: string(name='SnapshotType', description='snapshotType'),
  authTimeout?: string(name='AuthTimeout', description='authTimeout'),
  pageSize?: string(name='PageSize', description='pageSize'),
  pageNo?: string(name='PageNo', description='pageNo'),
}

model ListSnapshotsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaSnapshot: {
    total: long(name='Total', description='total'),
    regular: string(name='Regular', description='regular'),
    creationTime: string(name='CreationTime', description='creationTime'),
    jobId: string(name='JobId', description='jobId'),
    snapshots: {
      snapshot: [
        {
          index: long(name='Index', description='index'),
          url: string(name='Url', description='url'),
        }
      ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshots'),
  }(name='MediaSnapshot', description='data.mediaSnapshot'),
}

async function listSnapshotsWithOptions(request: ListSnapshotsRequest, runtime: Util.RuntimeOptions): ListSnapshotsResponse {
  Util.validateModel(request);
  return doRequest('ListSnapshots', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listSnapshots(request: ListSnapshotsRequest): ListSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSnapshotsWithOptions(request, runtime);
}

model SubmitTranscodeJobsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId?: string(name='VideoId', description='mediaId'),
  templateGroupId: string(name='TemplateGroupId', description='groupId'),
  pipelineId?: string(name='PipelineId', description='pipelineId'),
  encryptConfig?: string(name='EncryptConfig', description='encryptConfig'),
  overrideParams?: string(name='OverrideParams', description='overrideParams'),
  priority?: string(name='Priority', description='priority'),
  userData?: string(name='UserData', description='userData'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
}

model SubmitTranscodeJobsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeTaskId: string(name='TranscodeTaskId', description='data.processId'),
  transcodeJobs: {
    transcodeJob: [
      {
        jobId: string(name='JobId', description='jobId'),
      }
    ](name='TranscodeJob', description='TranscodeJob'),
  }(name='TranscodeJobs', description='data.transcodeJobs'),
}

async function submitTranscodeJobsWithOptions(request: SubmitTranscodeJobsRequest, runtime: Util.RuntimeOptions): SubmitTranscodeJobsResponse {
  Util.validateModel(request);
  return doRequest('SubmitTranscodeJobs', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitTranscodeJobs(request: SubmitTranscodeJobsRequest): SubmitTranscodeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTranscodeJobsWithOptions(request, runtime);
}

model ListLiveRecordVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  streamName?: string(name='StreamName', description='streamName'),
  domainName?: string(name='DomainName', description='domainName'),
  appName?: string(name='AppName', description='appName'),
  queryType?: string(name='QueryType', description='queryType'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model ListLiveRecordVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  liveRecordVideoList: {
    liveRecordVideo: [
      {
        streamName: string(name='StreamName', description='streamName'),
        domainName: string(name='DomainName', description='domainName'),
        appName: string(name='AppName', description='appName'),
        playlistId: string(name='PlaylistId', description='playlistId'),
        recordStartTime: string(name='RecordStartTime', description='recordStartTime'),
        recordEndTime: string(name='RecordEndTime', description='recordEndTime'),
        playInfoList: {
          playInfo: [
            {
              width: long(name='Width', description='width'),
              height: long(name='Height', description='height'),
              size: long(name='Size', description='size'),
              playURL: string(name='PlayURL', description='playURL'),
              bitrate: string(name='Bitrate', description='bitrate'),
              definition: string(name='Definition', description='definition'),
              duration: string(name='Duration', description='duration'),
              format: string(name='Format', description='format'),
              fps: string(name='Fps', description='fps'),
              encrypt: long(name='Encrypt', description='encrypt'),
              plaintext: string(name='Plaintext', description='plaintext'),
              complexity: string(name='Complexity', description='complexity'),
              streamType: string(name='StreamType', description='streamType'),
              rand: string(name='Rand', description='rand'),
              jobId: string(name='JobId', description='jobId'),
            }
          ](name='PlayInfo', description='PlayInfo'),
        }(name='PlayInfoList', description='playInfoList'),
        video: {
          videoId: string(name='VideoId', description='mediaId'),
          title: string(name='Title', description='title'),
          tags: string(name='Tags', description='tags'),
          status: string(name='Status', description='state'),
          size: long(name='Size', description='fileSize'),
          privilege: integer(name='Privilege', description='publicType'),
          duration: float(name='Duration', description='duration'),
          description: string(name='Description', description='description'),
          customerId: long(name='CustomerId', description='userId'),
          createTime: string(name='CreateTime', description='gmtCreate'),
          creationTime: string(name='CreationTime', description='creationTime'),
          modifyTime: string(name='ModifyTime', description='gmtModified'),
          coverURL: string(name='CoverURL', description='coverUrl'),
          cateId: integer(name='CateId', description='cateId'),
          cateName: string(name='CateName', description='cateName'),
          downloadSwitch: string(name='DownloadSwitch', description='download'),
          templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
          snapshots: {
            snapshot: [ string ](name='Snapshot', description='Snapshot'),
          }(name='Snapshots', description='snapshots'),
        }(name='Video', description='mediaInfo'),
      }
    ](name='LiveRecordVideo', description='LiveRecordVideo'),
  }(name='LiveRecordVideoList', description='data.liveRecordVideoList'),
}

async function listLiveRecordVideoWithOptions(request: ListLiveRecordVideoRequest, runtime: Util.RuntimeOptions): ListLiveRecordVideoResponse {
  Util.validateModel(request);
  return doRequest('ListLiveRecordVideo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listLiveRecordVideo(request: ListLiveRecordVideoRequest): ListLiveRecordVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRecordVideoWithOptions(request, runtime);
}

model CreateAuditRequest = {
  auditContent: string(name='AuditContent', description='auditContent'),
}

model CreateAuditResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function createAuditWithOptions(request: CreateAuditRequest, runtime: Util.RuntimeOptions): CreateAuditResponse {
  Util.validateModel(request);
  return doRequest('CreateAudit', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function createAudit(request: CreateAuditRequest): CreateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAuditWithOptions(request, runtime);
}

model GetAuditHistoryRequest = {
  videoId: string(name='VideoId', description='mediaId'),
  pageNo?: long(name='PageNo', description='pageNo'),
  pageSize?: long(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
}

model GetAuditHistoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  status: string(name='Status', description='data.status'),
  total: long(name='Total', description='data.total'),
  histories: [
    {
      creationTime: string(name='CreationTime', description='timestamp'),
      status: string(name='Status', description='status'),
      reason: string(name='Reason', description='reason'),
      comment: string(name='Comment', description='comment'),
      auditor: string(name='Auditor', description='auditor'),
    }
  ](name='Histories', description='data.auditHistoryList'),
}

async function getAuditHistoryWithOptions(request: GetAuditHistoryRequest, runtime: Util.RuntimeOptions): GetAuditHistoryResponse {
  Util.validateModel(request);
  return doRequest('GetAuditHistory', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getAuditHistory(request: GetAuditHistoryRequest): GetAuditHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuditHistoryWithOptions(request, runtime);
}

model ListAIJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  jobIds: string(name='JobIds', description='jobIds'),
}

model ListAIJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIJobList: {
    AIJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        type: string(name='Type', description='type'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        completeTime: string(name='CompleteTime', description='completeTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIJob', description='AIJob'),
  }(name='AIJobList', description='data.jobDTOs'),
  nonExistAIJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIJobIds', description='data.nonExistJobIds'),
}

async function listAIJobWithOptions(request: ListAIJobRequest, runtime: Util.RuntimeOptions): ListAIJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function listAIJob(request: ListAIJobRequest): ListAIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIJobWithOptions(request, runtime);
}

model SubmitAIJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId?: string(name='MediaId', description='mediaId'),
  types?: string(name='Types', description='types'),
  config?: string(name='Config', description='config'),
  userData?: string(name='UserData', description='userData'),
  input?: string(name='Input', description='input'),
}

model SubmitAIJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIJobList: {
    AIJob: [
      {
        jobId: string(name='JobId', description='id'),
        type: string(name='Type', description='type'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIJob', description='AIJob'),
  }(name='AIJobList', description='data.jobDTOs'),
}

async function submitAIJobWithOptions(request: SubmitAIJobRequest, runtime: Util.RuntimeOptions): SubmitAIJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitAIJob(request: SubmitAIJobRequest): SubmitAIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIJobWithOptions(request, runtime);
}

model GetImageInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  imageId: string(name='ImageId', description='mediaId'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  outputType?: string(name='OutputType', description='outputType'),
}

model GetImageInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  imageInfo: {
    imageId: string(name='ImageId', description='mediaId'),
    title: string(name='Title', description='title'),
    creationTime: string(name='CreationTime', description='createTime'),
    imageType: string(name='ImageType', description='imageType'),
    tags: string(name='Tags', description='tags'),
    URL: string(name='URL', description='url'),
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    description: string(name='Description', description='desc'),
    storageLocation: string(name='StorageLocation', description='storageLocation'),
    status: string(name='Status', description='statusDescription'),
    appId: string(name='AppId', description='appId'),
    regionId: string(name='RegionId', description='regionId'),
    auditStatus: string(name='AuditStatus', description='auditStatusDescription'),
    mezzanine: {
      originalFileName: string(name='OriginalFileName', description='originalFileName'),
      fileSize: string(name='FileSize', description='fileSize'),
      width: integer(name='Width', description='width'),
      height: integer(name='Height', description='height'),
      fileURL: string(name='FileURL', description='fileUrl'),
    }(name='Mezzanine', description='mezzanineDTO'),
  }(name='ImageInfo', description='data.image'),
}

async function getImageInfoWithOptions(request: GetImageInfoRequest, runtime: Util.RuntimeOptions): GetImageInfoResponse {
  Util.validateModel(request);
  return doRequest('GetImageInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getImageInfo(request: GetImageInfoRequest): GetImageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageInfoWithOptions(request, runtime);
}

model DeleteStreamRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  jobIds: string(name='JobIds', description='jobIds'),
  videoId: string(name='VideoId', description='mediaId'),
}

model DeleteStreamResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteStreamWithOptions(request: DeleteStreamRequest, runtime: Util.RuntimeOptions): DeleteStreamResponse {
  Util.validateModel(request);
  return doRequest('DeleteStream', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteStream(request: DeleteStreamRequest): DeleteStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStreamWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId?: string(name='VideoId', description='mediaId'),
  specifiedOffsetTime?: long(name='SpecifiedOffsetTime', description='time'),
  width?: string(name='Width', description='width'),
  height?: string(name='Height', description='height'),
  count?: long(name='Count', description='num'),
  interval?: long(name='Interval', description='interval'),
  spriteSnapshotConfig?: string(name='SpriteSnapshotConfig', description='spriteConfig'),
  snapshotTemplateId?: string(name='SnapshotTemplateId', description='snapshotTemplateId'),
  userData?: string(name='UserData', description='userData'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
}

model SubmitSnapshotJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  snapshotJob: {
    jobId: string(name='JobId', description='jobId'),
  }(name='SnapshotJob', description='data.submitSnapshotJobDTO'),
}

async function submitSnapshotJobWithOptions(request: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitSnapshotJob', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model UpdateEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
  title?: string(name='Title', description='title'),
  timeline?: string(name='Timeline', description='timeline'),
  description?: string(name='Description', description='description'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
}

model UpdateEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateEditingProjectWithOptions(request: UpdateEditingProjectRequest, runtime: Util.RuntimeOptions): UpdateEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('UpdateEditingProject', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateEditingProject(request: UpdateEditingProjectRequest): UpdateEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEditingProjectWithOptions(request, runtime);
}

model SetEditingProjectMaterialsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
  materialIds: string(name='MaterialIds', description='materialIds'),
}

model SetEditingProjectMaterialsResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setEditingProjectMaterialsWithOptions(request: SetEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): SetEditingProjectMaterialsResponse {
  Util.validateModel(request);
  return doRequest('SetEditingProjectMaterials', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setEditingProjectMaterials(request: SetEditingProjectMaterialsRequest): SetEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setEditingProjectMaterialsWithOptions(request, runtime);
}

model SearchEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  endTime?: string(name='EndTime', description='endTime'),
  startTime?: string(name='StartTime', description='startTime'),
  status?: string(name='Status', description='state'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  title?: string(name='Title', description='title'),
}

model SearchEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  projectList: {
    project: [
      {
        projectId: string(name='ProjectId', description='projectId'),
        creationTime: string(name='CreationTime', description='utcCreate'),
        modifiedTime: string(name='ModifiedTime', description='utcModified'),
        status: string(name='Status', description='stateStr'),
        description: string(name='Description', description='description'),
        title: string(name='Title', description='title'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='region'),
        duration: float(name='Duration', description='duration'),
      }
    ](name='Project', description='Project'),
  }(name='ProjectList', description='data.projectDOList'),
}

async function searchEditingProjectWithOptions(request: SearchEditingProjectRequest, runtime: Util.RuntimeOptions): SearchEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('SearchEditingProject', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function searchEditingProject(request: SearchEditingProjectRequest): SearchEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEditingProjectWithOptions(request, runtime);
}

model ProduceEditingProjectVideoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  projectId?: string(name='ProjectId', description='projectId'),
  timeline?: string(name='Timeline', description='timeline'),
  title?: string(name='Title', description='title'),
  description?: string(name='Description', description='description'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  mediaMetadata?: string(name='MediaMetadata', description='mediaMetadata'),
  produceConfig?: string(name='ProduceConfig', description='produceConfig'),
  userData?: string(name='UserData', description='userData'),
}

model ProduceEditingProjectVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
  projectId: string(name='ProjectId', description='data.projectId'),
}

async function produceEditingProjectVideoWithOptions(request: ProduceEditingProjectVideoRequest, runtime: Util.RuntimeOptions): ProduceEditingProjectVideoResponse {
  Util.validateModel(request);
  return doRequest('ProduceEditingProjectVideo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function produceEditingProjectVideo(request: ProduceEditingProjectVideoRequest): ProduceEditingProjectVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return produceEditingProjectVideoWithOptions(request, runtime);
}

model GetEditingProjectMaterialsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
  type?: string(name='Type', description='type'),
  materialType?: string(name='MaterialType', description='materialType'),
}

model GetEditingProjectMaterialsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  materialList: {
    material: [
      {
        materialId: string(name='MaterialId', description='mediaId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='stateStr'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        creationTime: string(name='CreationTime', description='utcCreate'),
        modifiedTime: string(name='ModifiedTime', description='utcModified'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        source: string(name='Source', description='source'),
        spriteConfig: string(name='SpriteConfig', description='spriteConfig'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshotList'),
        sprites: {
          sprite: [ string ](name='Sprite', description='Sprite'),
        }(name='Sprites', description='tileList'),
      }
    ](name='Material', description='Material'),
  }(name='MaterialList', description='data.materialDOs'),
}

async function getEditingProjectMaterialsWithOptions(request: GetEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): GetEditingProjectMaterialsResponse {
  Util.validateModel(request);
  return doRequest('GetEditingProjectMaterials', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getEditingProjectMaterials(request: GetEditingProjectMaterialsRequest): GetEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectMaterialsWithOptions(request, runtime);
}

model GetEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
}

model GetEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  project: {
    projectId: string(name='ProjectId', description='projectId'),
    creationTime: string(name='CreationTime', description='utcCreate'),
    modifiedTime: string(name='ModifiedTime', description='utcModified'),
    status: string(name='Status', description='stateStr'),
    description: string(name='Description', description='description'),
    title: string(name='Title', description='title'),
    timeline: string(name='Timeline', description='timeline'),
    coverURL: string(name='CoverURL', description='coverUrl'),
    storageLocation: string(name='StorageLocation', description='storageLocation'),
    regionId: string(name='RegionId', description='region'),
  }(name='Project', description='data.project'),
}

async function getEditingProjectWithOptions(request: GetEditingProjectRequest, runtime: Util.RuntimeOptions): GetEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('GetEditingProject', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getEditingProject(request: GetEditingProjectRequest): GetEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectWithOptions(request, runtime);
}

model DeleteEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectIds: string(name='ProjectIds', description='projectIdStr'),
}

model DeleteEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteEditingProjectWithOptions(request: DeleteEditingProjectRequest, runtime: Util.RuntimeOptions): DeleteEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('DeleteEditingProject', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteEditingProject(request: DeleteEditingProjectRequest): DeleteEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEditingProjectWithOptions(request, runtime);
}

model AddEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  title: string(name='Title', description='title'),
  description?: string(name='Description', description='description'),
  timeline?: string(name='Timeline', description='timeline'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  division?: string(name='Division', description='projectRegion'),
}

model AddEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  project: {
    projectId: string(name='ProjectId', description='projectId'),
    creationTime: string(name='CreationTime', description='utcCreate'),
    modifiedTime: string(name='ModifiedTime', description='utcModified'),
    status: string(name='Status', description='stateStr'),
    description: string(name='Description', description='description'),
    title: string(name='Title', description='title'),
  }(name='Project', description='data.project'),
}

async function addEditingProjectWithOptions(request: AddEditingProjectRequest, runtime: Util.RuntimeOptions): AddEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('AddEditingProject', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addEditingProject(request: AddEditingProjectRequest): AddEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEditingProjectWithOptions(request, runtime);
}

model GetMezzanineInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  previewSegment?: boolean(name='PreviewSegment', description='previewSegment'),
  outputType?: string(name='OutputType', description='outputType'),
  additionType?: string(name='AdditionType', description='additionType'),
}

model GetMezzanineInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mezzanine: {
    videoId: string(name='VideoId', description='mediaId'),
    bitrate: string(name='Bitrate', description='bitrate'),
    creationTime: string(name='CreationTime', description='createTime'),
    duration: string(name='Duration', description='durationStr'),
    fps: string(name='Fps', description='fps'),
    height: long(name='Height', description='height'),
    width: long(name='Width', description='width'),
    size: long(name='Size', description='size'),
    status: string(name='Status', description='status'),
    fileURL: string(name='FileURL', description='fileURL'),
    fileName: string(name='FileName', description='fileName'),
    CRC64: string(name='CRC64', description='crc64'),
    preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
    outputType: string(name='OutputType', description='outputType'),
    audioStreamList: [
      {
        index: string(name='Index', description='index'),
        codecName: string(name='CodecName', description='codecName'),
        codecLongName: string(name='CodecLongName', description='codecLongName'),
        codecTimeBase: string(name='CodecTimeBase', description='codecTimeBase'),
        codecTagString: string(name='CodecTagString', description='codecTagString'),
        codecTag: string(name='CodecTag', description='codecTag'),
        sampleFmt: string(name='SampleFmt', description='sampleFmt'),
        sampleRate: string(name='SampleRate', description='sampleRate'),
        channels: string(name='Channels', description='channels'),
        channelLayout: string(name='ChannelLayout', description='channelLayout'),
        timebase: string(name='Timebase', description='timebase'),
        startTime: string(name='StartTime', description='startTime'),
        duration: string(name='Duration', description='duration'),
        bitrate: string(name='Bitrate', description='bitrate'),
        numFrames: string(name='NumFrames', description='numFrames'),
        lang: string(name='Lang', description='lang'),
      }
    ](name='AudioStreamList', description='audioStreamList'),
    videoStreamList: [
      {
        index: string(name='Index', description='index'),
        codecName: string(name='CodecName', description='codecName'),
        codecLongName: string(name='CodecLongName', description='codecLongName'),
        profile: string(name='Profile', description='profile'),
        codecTimeBase: string(name='CodecTimeBase', description='codecTimeBase'),
        codecTagString: string(name='CodecTagString', description='codecTagString'),
        codecTag: string(name='CodecTag', description='codecTag'),
        width: string(name='Width', description='width'),
        height: string(name='Height', description='height'),
        hasBFrames: string(name='HasBFrames', description='hasBFrames'),
        sar: string(name='Sar', description='sar'),
        dar: string(name='Dar', description='dar'),
        pixFmt: string(name='PixFmt', description='pixFmt'),
        level: string(name='Level', description='level'),
        fps: string(name='Fps', description='fps'),
        avgFPS: string(name='AvgFPS', description='avgFPS'),
        timebase: string(name='Timebase', description='timebase'),
        startTime: string(name='StartTime', description='startTime'),
        duration: string(name='Duration', description='duration'),
        numFrames: string(name='NumFrames', description='numFrames'),
        lang: string(name='Lang', description='lang'),
        rotate: string(name='Rotate', description='rotate'),
      }
    ](name='VideoStreamList', description='videoStreamList'),
  }(name='Mezzanine', description='data.fileInfo'),
}

async function getMezzanineInfoWithOptions(request: GetMezzanineInfoRequest, runtime: Util.RuntimeOptions): GetMezzanineInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMezzanineInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMezzanineInfo(request: GetMezzanineInfoRequest): GetMezzanineInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMezzanineInfoWithOptions(request, runtime);
}

model UpdateCategoryRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  cateName: string(name='CateName', description='cateName'),
  cateId: long(name='CateId', description='cateId'),
}

model UpdateCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateCategoryWithOptions(request: UpdateCategoryRequest, runtime: Util.RuntimeOptions): UpdateCategoryResponse {
  Util.validateModel(request);
  return doRequest('UpdateCategory', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateCategory(request: UpdateCategoryRequest): UpdateCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryWithOptions(request, runtime);
}

model GetCategoriesRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  cateId?: long(name='CateId', description='cateId'),
  pageNo?: long(name='PageNo', description='pageNo'),
  pageSize?: long(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  type?: string(name='Type', description='type'),
}

model GetCategoriesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  subTotal: long(name='SubTotal', description='data.subTotal'),
  subCategories: {
    category: [
      {
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        level: long(name='Level', description='level'),
        parentId: long(name='ParentId', description='parentId'),
        subTotal: long(name='SubTotal', description='subTotal'),
        type: string(name='Type', description='type'),
      }
    ](name='Category', description='Category'),
  }(name='SubCategories', description='data.subCategories'),
  category: {
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    level: long(name='Level', description='level'),
    parentId: long(name='ParentId', description='parentId'),
    type: string(name='Type', description='type'),
  }(name='Category', description='data.category'),
}

async function getCategoriesWithOptions(request: GetCategoriesRequest, runtime: Util.RuntimeOptions): GetCategoriesResponse {
  Util.validateModel(request);
  return doRequest('GetCategories', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getCategories(request: GetCategoriesRequest): GetCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCategoriesWithOptions(request, runtime);
}

model DeleteCategoryRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  cateId: long(name='CateId', description='cateId'),
}

model DeleteCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: Util.RuntimeOptions): DeleteCategoryResponse {
  Util.validateModel(request);
  return doRequest('DeleteCategory', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCategoryWithOptions(request, runtime);
}

model AddCategoryRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  cateName: string(name='CateName', description='cateName'),
  parentId?: long(name='ParentId', description='parentId'),
  type?: string(name='Type', description='type'),
}

model AddCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  category: {
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    parentId: long(name='ParentId', description='parentId'),
    level: long(name='Level', description='level'),
    type: string(name='Type', description='type'),
  }(name='Category', description='data.category'),
}

async function addCategoryWithOptions(request: AddCategoryRequest, runtime: Util.RuntimeOptions): AddCategoryResponse {
  Util.validateModel(request);
  return doRequest('AddCategory', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCategoryWithOptions(request, runtime);
}

model GetPlayInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  formats?: string(name='Formats', description='formats'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  outputType?: string(name='OutputType', description='outputType'),
  streamType?: string(name='StreamType', description='streamType'),
  reAuthInfo?: string(name='ReAuthInfo', description='reAuthInfo'),
  definition?: string(name='Definition', description='definition'),
  resultType?: string(name='ResultType', description='resultType'),
  playConfig?: string(name='PlayConfig', description='playConfig'),
}

model GetPlayInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playInfoList: {
    playInfo: [
      {
        width: long(name='Width', description='width'),
        height: long(name='Height', description='height'),
        size: long(name='Size', description='size'),
        playURL: string(name='PlayURL', description='playURL'),
        bitrate: string(name='Bitrate', description='bitrate'),
        definition: string(name='Definition', description='definition'),
        duration: string(name='Duration', description='duration'),
        format: string(name='Format', description='format'),
        fps: string(name='Fps', description='fps'),
        encrypt: long(name='Encrypt', description='encrypt'),
        plaintext: string(name='Plaintext', description='plaintext'),
        complexity: string(name='Complexity', description='complexity'),
        streamType: string(name='StreamType', description='streamType'),
        rand: string(name='Rand', description='rand'),
        jobId: string(name='JobId', description='jobId'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        watermarkId: string(name='WatermarkId', description='watermarkId'),
        status: string(name='Status', description='status'),
        creationTime: string(name='CreationTime', description='creationTime'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        encryptType: string(name='EncryptType', description='encryptType'),
        narrowBandType: string(name='NarrowBandType', description='narrowBandType'),
        specification: string(name='Specification', description='specification'),
      }
    ](name='PlayInfo', description='PlayInfo'),
  }(name='PlayInfoList', description='data.playInfoList'),
  videoBase: {
    outputType: string(name='OutputType', description='outputType'),
    coverURL: string(name='CoverURL', description='coverURL'),
    duration: string(name='Duration', description='duration'),
    status: string(name='Status', description='status'),
    title: string(name='Title', description='title'),
    videoId: string(name='VideoId', description='videoId'),
    mediaType: string(name='MediaType', description='mediaType'),
    creationTime: string(name='CreationTime', description='creationTime'),
    transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
    thumbnailList: {
      thumbnail: [
        {
          URL: string(name='URL', description='url'),
        }
      ](name='Thumbnail', description='Thumbnail'),
    }(name='ThumbnailList', description='thumbnailList'),
  }(name='VideoBase', description='data.videoBase'),
}

async function getPlayInfoWithOptions(request: GetPlayInfoRequest, runtime: Util.RuntimeOptions): GetPlayInfoResponse {
  Util.validateModel(request);
  return doRequest('GetPlayInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getPlayInfo(request: GetPlayInfoRequest): GetPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayInfoWithOptions(request, runtime);
}

model CreateUploadImageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  title?: string(name='Title', description='title'),
  imageType: string(name='ImageType', description='imageType'),
  imageExt?: string(name='ImageExt', description='imageExt'),
  originalFileName?: string(name='OriginalFileName', description='originalFileName'),
  tags?: string(name='Tags', description='tags'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  cateId?: long(name='CateId', description='cateId'),
  userData?: string(name='UserData', description='userData'),
  description?: string(name='Description', description='description'),
  appId?: string(name='AppId', description='appId'),
}

model CreateUploadImageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  imageId: string(name='ImageId', description='data.mediaId'),
  imageURL: string(name='ImageURL', description='data.imageURL'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
  fileURL: string(name='FileURL', description='data.fileUrl'),
}

async function createUploadImageWithOptions(request: CreateUploadImageRequest, runtime: Util.RuntimeOptions): CreateUploadImageResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadImage', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function createUploadImage(request: CreateUploadImageRequest): CreateUploadImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadImageWithOptions(request, runtime);
}

model SetMessageCallbackRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  callbackType?: string(name='CallbackType', description='callbackType'),
  callbackURL?: string(name='CallbackURL', description='callbackURL'),
  eventTypeList?: string(name='EventTypeList', description='eventTypeList'),
  authSwitch?: string(name='AuthSwitch', description='authSwitch'),
  authKey?: string(name='AuthKey', description='authKey'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  mnsEndpoint?: string(name='MnsEndpoint', description='mnsEndpoint'),
  mnsQueueName?: string(name='MnsQueueName', description='mnsQueueName'),
  appId?: string(name='AppId', description='appId'),
}

model SetMessageCallbackResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setMessageCallbackWithOptions(request: SetMessageCallbackRequest, runtime: Util.RuntimeOptions): SetMessageCallbackResponse {
  Util.validateModel(request);
  return doRequest('SetMessageCallback', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function setMessageCallback(request: SetMessageCallbackRequest): SetMessageCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return setMessageCallbackWithOptions(request, runtime);
}

model GetMessageCallbackRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  appId?: string(name='AppId', description='appId'),
}

model GetMessageCallbackResponse = {
  requestId: string(name='RequestId', description='requestId'),
  messageCallback: {
    callbackType: string(name='CallbackType', description='callbackType'),
    callbackURL: string(name='CallbackURL', description='uri'),
    eventTypeList: string(name='EventTypeList', description='eventTypeList'),
    authSwitch: string(name='AuthSwitch', description='authSwitch'),
    authKey: string(name='AuthKey', description='httpAuthKey'),
    mnsEndpoint: string(name='MnsEndpoint', description='mnsEndpoint'),
    mnsQueueName: string(name='MnsQueueName', description='mnsQueueName'),
    appId: string(name='AppId', description='appId'),
  }(name='MessageCallback', description='data.userMessageCallbackDTO'),
}

async function getMessageCallbackWithOptions(request: GetMessageCallbackRequest, runtime: Util.RuntimeOptions): GetMessageCallbackResponse {
  Util.validateModel(request);
  return doRequest('GetMessageCallback', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getMessageCallback(request: GetMessageCallbackRequest): GetMessageCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMessageCallbackWithOptions(request, runtime);
}

model UpdateVideoInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  title?: string(name='Title', description='title'),
  tags?: string(name='Tags', description='tags'),
  description?: string(name='Description', description='description'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  cateId?: long(name='CateId', description='cateId'),
  customMediaInfo?: string(name='CustomMediaInfo', description='customMediaInfo'),
}

model UpdateVideoInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateVideoInfoWithOptions(request: UpdateVideoInfoRequest, runtime: Util.RuntimeOptions): UpdateVideoInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateVideoInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function updateVideoInfo(request: UpdateVideoInfoRequest): UpdateVideoInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVideoInfoWithOptions(request, runtime);
}

model GetVideoPlayAuthRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  authInfoTimeout?: long(name='AuthInfoTimeout', description='authInfoTimeout'),
  playConfig?: string(name='PlayConfig', description='playConfig'),
}

model GetVideoPlayAuthResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playAuth: string(name='PlayAuth', description='data.playAuth'),
  videoMeta: {
    coverURL: string(name='CoverURL', description='coverURL'),
    duration: float(name='Duration', description='duration'),
    status: string(name='Status', description='status'),
    title: string(name='Title', description='title'),
    videoId: string(name='VideoId', description='mediaId'),
  }(name='VideoMeta', description='data.videoMeta'),
}

async function getVideoPlayAuthWithOptions(request: GetVideoPlayAuthRequest, runtime: Util.RuntimeOptions): GetVideoPlayAuthResponse {
  Util.validateModel(request);
  return doRequest('GetVideoPlayAuth', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getVideoPlayAuth(request: GetVideoPlayAuthRequest): GetVideoPlayAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoPlayAuthWithOptions(request, runtime);
}

model GetVideoListRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  cateId?: long(name='CateId', description='cateId'),
  status?: string(name='Status', description='status'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
}

model GetVideoListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  videoList: {
    video: [
      {
        videoId: string(name='VideoId', description='mediaId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        createTime: string(name='CreateTime', description='gmtCreate'),
        modifyTime: string(name='ModifyTime', description='gmtModified'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        appId: string(name='AppId', description='appId'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshots'),
      }
    ](name='Video', description='Video'),
  }(name='VideoList', description='data.aMediaList'),
}

async function getVideoListWithOptions(request: GetVideoListRequest, runtime: Util.RuntimeOptions): GetVideoListResponse {
  Util.validateModel(request);
  return doRequest('GetVideoList', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getVideoList(request: GetVideoListRequest): GetVideoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoListWithOptions(request, runtime);
}

model GetVideoInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  additionType?: string(name='AdditionType', description='additionType'),
}

model GetVideoInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AI: string(name='AI', description='data.aiResult'),
  video: {
    videoId: string(name='VideoId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
    status: string(name='Status', description='state'),
    size: long(name='Size', description='fileSize'),
    duration: float(name='Duration', description='duration'),
    description: string(name='Description', description='description'),
    createTime: string(name='CreateTime', description='gmtCreate'),
    modifyTime: string(name='ModifyTime', description='gmtModified'),
    modificationTime: string(name='ModificationTime', description='modificationTime'),
    creationTime: string(name='CreationTime', description='creationTime'),
    coverURL: string(name='CoverURL', description='coverUrl'),
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    downloadSwitch: string(name='DownloadSwitch', description='download'),
    templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
    preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
    storageLocation: string(name='StorageLocation', description='storageLocation'),
    regionId: string(name='RegionId', description='regionId'),
    customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
    auditStatus: string(name='AuditStatus', description='auditStatus'),
    appId: string(name='AppId', description='appId'),
    thumbnailList: {
      thumbnail: [
        {
          URL: string(name='URL', description='url'),
        }
      ](name='Thumbnail', description='Thumbnail'),
    }(name='ThumbnailList', description='thumbnailList'),
    snapshots: {
      snapshot: [ string ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshots'),
  }(name='Video', description='data.mediaInfo'),
}

async function getVideoInfoWithOptions(request: GetVideoInfoRequest, runtime: Util.RuntimeOptions): GetVideoInfoResponse {
  Util.validateModel(request);
  return doRequest('GetVideoInfo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function getVideoInfo(request: GetVideoInfoRequest): GetVideoInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoInfoWithOptions(request, runtime);
}

model DeleteVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIdStr'),
}

model DeleteVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
  forbiddenVideoIds: [ string ] (name='ForbiddenVideoIds', description='data.forbiddenVideoIds'),
}

async function deleteVideoWithOptions(request: DeleteVideoRequest, runtime: Util.RuntimeOptions): DeleteVideoResponse {
  Util.validateModel(request);
  return doRequest('DeleteVideo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoWithOptions(request, runtime);
}

model RefreshUploadVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
}

model RefreshUploadVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  videoId: string(name='VideoId', description='data.videoId'),
}

async function refreshUploadVideoWithOptions(request: RefreshUploadVideoRequest, runtime: Util.RuntimeOptions): RefreshUploadVideoResponse {
  Util.validateModel(request);
  return doRequest('RefreshUploadVideo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function refreshUploadVideo(request: RefreshUploadVideoRequest): RefreshUploadVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshUploadVideoWithOptions(request, runtime);
}

model CreateUploadVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  description?: string(name='Description', description='description'),
  fileName: string(name='FileName', description='fileName'),
  fileSize?: long(name='FileSize', description='fileSize'),
  IP?: string(name='IP', description='createIp'),
  title: string(name='Title', description='title'),
  cateId?: long(name='CateId', description='cateId'),
  tags?: string(name='Tags', description='tags'),
  transcodeMode?: string(name='TranscodeMode', description='transcodeMode'),
  userData?: string(name='UserData', description='userData'),
  templateGroupId?: string(name='TemplateGroupId', description='templateGroupId'),
  workflowId?: string(name='WorkflowId', description='workflowId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  customMediaInfo?: string(name='CustomMediaInfo', description='customMediaInfo'),
  appId?: string(name='AppId', description='appId'),
}

model CreateUploadVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoId: string(name='VideoId', description='data.mediaInfo.mediaId'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
}

async function createUploadVideoWithOptions(request: CreateUploadVideoRequest, runtime: Util.RuntimeOptions): CreateUploadVideoResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadVideo', 'HTTPS', 'POST', '2017-03-21', 'AK', null, request, runtime);
}

async function createUploadVideo(request: CreateUploadVideoRequest): CreateUploadVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadVideoWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
