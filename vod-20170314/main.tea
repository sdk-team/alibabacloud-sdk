import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'vod.cn-shanghai.aliyuncs.com',
    cn-hangzhou = 'vod.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'vod.cn-shanghai.aliyuncs.com',
    ap-northeast-2-pop = 'vod.ap-northeast-1.aliyuncs.com',
    ap-southeast-2 = 'vod.ap-northeast-1.aliyuncs.com',
    ap-southeast-3 = 'vod.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'vod.aliyuncs.com',
    cn-beijing-finance-pop = 'vod.aliyuncs.com',
    cn-beijing-gov-1 = 'vod.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vod.aliyuncs.com',
    cn-chengdu = 'vod.aliyuncs.com',
    cn-edge-1 = 'vod.aliyuncs.com',
    cn-fujian = 'vod.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vod.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vod.aliyuncs.com',
    cn-hangzhou-finance = 'vod.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vod.aliyuncs.com',
    cn-hangzhou-test-306 = 'vod.aliyuncs.com',
    cn-hongkong-finance-pop = 'vod.aliyuncs.com',
    cn-huhehaote = 'vod.aliyuncs.com',
    cn-qingdao = 'vod.aliyuncs.com',
    cn-qingdao-nebula = 'vod.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vod.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vod.aliyuncs.com',
    cn-shanghai-finance-1 = 'vod.aliyuncs.com',
    cn-shanghai-inner = 'vod.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vod.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vod.aliyuncs.com',
    cn-shenzhen-inner = 'vod.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vod.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vod.aliyuncs.com',
    cn-wuhan = 'vod.aliyuncs.com',
    cn-yushanfang = 'vod.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vod.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vod.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vod.aliyuncs.com',
    eu-west-1-oxs = 'vod.ap-northeast-1.aliyuncs.com',
    me-east-1 = 'vod.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'vod.ap-northeast-1.aliyuncs.com',
    us-east-1 = 'vod.ap-northeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint(@productId, @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model DescribeVodDomainISPDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainISPDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  dataInterval: string(name='DataInterval', description='data.content.dataInterval'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  value: {
    ISPProportionData: [
      {
        ISP: string(name='ISP', description='isp'),
        proportion: string(name='Proportion', description='totalQueryPer'),
        ispEname: string(name='IspEname', description='ispEname'),
        avgObjectSize: string(name='AvgObjectSize', description='avgObjectSize'),
        avgResponseTime: string(name='AvgResponseTime', description='avgResponseTime'),
        bps: string(name='Bps', description='bps'),
        qps: string(name='Qps', description='qps'),
        avgResponseRate: string(name='AvgResponseRate', description='avgResponseRate'),
        reqErrRate: string(name='ReqErrRate', description='reqErrRate'),
        totalBytes: string(name='TotalBytes', description='totalBytes'),
        bytesProportion: string(name='BytesProportion', description='totalBytesPer'),
        totalQuery: string(name='TotalQuery', description='totalQuery'),
      }
    ](name='ISPProportionData', description='ISPProportionData'),
  }(name='Value', description='data.content.ispDatas'),
}

async function describeVodDomainISPDataWithOptions(request: DescribeVodDomainISPDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainISPDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainISPData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainISPData(request: DescribeVodDomainISPDataRequest): DescribeVodDomainISPDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainISPDataWithOptions(request, runtime);
}

model DescribeVodDomainRegionDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRegionDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  dataInterval: string(name='DataInterval', description='data.content.dataInterval'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  value: {
    regionProportionData: [
      {
        region: string(name='Region', description='region'),
        proportion: string(name='Proportion', description='totalQueryPer'),
        regionEname: string(name='RegionEname', description='regionEname'),
        avgObjectSize: string(name='AvgObjectSize', description='avgObjectSize'),
        avgResponseTime: string(name='AvgResponseTime', description='avgResponseTime'),
        bps: string(name='Bps', description='bps'),
        qps: string(name='Qps', description='qps'),
        avgResponseRate: string(name='AvgResponseRate', description='avgResponseRate'),
        reqErrRate: string(name='ReqErrRate', description='reqErrRate'),
        totalBytes: string(name='TotalBytes', description='totalBytes'),
        bytesProportion: string(name='BytesProportion', description='totalBytesPer'),
        totalQuery: string(name='TotalQuery', description='totalQuery'),
      }
    ](name='RegionProportionData', description='RegionProportionData'),
  }(name='Value', description='data.content.regionDatas'),
}

async function describeVodDomainRegionDataWithOptions(request: DescribeVodDomainRegionDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRegionDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRegionData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRegionData(request: DescribeVodDomainRegionDataRequest): DescribeVodDomainRegionDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRegionDataWithOptions(request, runtime);
}

model DescribeVodDomainTopReferVisitRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  sortBy?: string(name='SortBy', description='sortBy'),
  percent?: string(name='Percent', description='percent'),
}

model DescribeVodDomainTopReferVisitResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  topReferList: {
    referList: [
      {
        referDetail: string(name='ReferDetail', description='refer'),
        visitData: string(name='VisitData', description='pv'),
        visitProportion: float(name='VisitProportion', description='pv_proportion'),
        flow: string(name='Flow', description='traf'),
        flowProportion: float(name='FlowProportion', description='traf_proportion'),
      }
    ](name='ReferList', description='ReferList'),
  }(name='TopReferList', description='data.content'),
}

async function describeVodDomainTopReferVisitWithOptions(request: DescribeVodDomainTopReferVisitRequest, runtime: Util.RuntimeOptions): DescribeVodDomainTopReferVisitResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainTopReferVisit', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainTopReferVisit(request: DescribeVodDomainTopReferVisitRequest): DescribeVodDomainTopReferVisitResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainTopReferVisitWithOptions(request, runtime);
}

model DescribeVodDomainTopUrlVisitRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  sortBy?: string(name='SortBy', description='sortBy'),
  percent?: string(name='Percent', description='percent'),
}

model DescribeVodDomainTopUrlVisitResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  allUrlList: {
    urlList: [
      {
        urlDetail: string(name='UrlDetail', description='url'),
        visitData: string(name='VisitData', description='pv'),
        visitProportion: float(name='VisitProportion', description='pv_proportion'),
        flow: string(name='Flow', description='traf'),
        flowProportion: float(name='FlowProportion', description='traf_proportion'),
      }
    ](name='UrlList', description='UrlList'),
  }(name='AllUrlList', description='data.content.all_url_list'),
  url200List: {
    urlList: [
      {
        urlDetail: string(name='UrlDetail', description='url'),
        visitData: string(name='VisitData', description='pv'),
        visitProportion: float(name='VisitProportion', description='pv_proportion'),
        flow: string(name='Flow', description='traf'),
        flowProportion: float(name='FlowProportion', description='traf_proportion'),
      }
    ](name='UrlList', description='UrlList'),
  }(name='Url200List', description='data.content.2xx_url_list'),
  url300List: {
    urlList: [
      {
        urlDetail: string(name='UrlDetail', description='url'),
        visitData: string(name='VisitData', description='pv'),
        visitProportion: float(name='VisitProportion', description='pv_proportion'),
        flow: string(name='Flow', description='traf'),
        flowProportion: float(name='FlowProportion', description='traf_proportion'),
      }
    ](name='UrlList', description='UrlList'),
  }(name='Url300List', description='data.content.3xx_url_list'),
  url400List: {
    urlList: [
      {
        urlDetail: string(name='UrlDetail', description='url'),
        visitData: string(name='VisitData', description='pv'),
        visitProportion: float(name='VisitProportion', description='pv_proportion'),
        flow: string(name='Flow', description='traf'),
        flowProportion: float(name='FlowProportion', description='traf_proportion'),
      }
    ](name='UrlList', description='UrlList'),
  }(name='Url400List', description='data.content.4xx_url_list'),
  url500List: {
    urlList: [
      {
        urlDetail: string(name='UrlDetail', description='url'),
        visitData: string(name='VisitData', description='pv'),
        visitProportion: float(name='VisitProportion', description='pv_proportion'),
        flow: string(name='Flow', description='traf'),
        flowProportion: float(name='FlowProportion', description='traf_proportion'),
      }
    ](name='UrlList', description='UrlList'),
  }(name='Url500List', description='data.content.5xx_url_list'),
}

async function describeVodDomainTopUrlVisitWithOptions(request: DescribeVodDomainTopUrlVisitRequest, runtime: Util.RuntimeOptions): DescribeVodDomainTopUrlVisitResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainTopUrlVisit', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainTopUrlVisit(request: DescribeVodDomainTopUrlVisitRequest): DescribeVodDomainTopUrlVisitResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainTopUrlVisitWithOptions(request, runtime);
}

model DescribeVodTopDomainsByFlowRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  product?: string(name='Product', description='product'),
  limit?: long(name='Limit', description='limit'),
}

model DescribeVodTopDomainsByFlowResponse = {
  requestId: string(name='RequestId', description='requestId'),
  startTime: string(name='StartTime', description='data.content.startTime'),
  endTime: string(name='EndTime', description='data.content.endTime'),
  domainCount: long(name='DomainCount', description='data.content.statisData.dm_cnt'),
  domainOnlineCount: long(name='DomainOnlineCount', description='data.content.statisData.dm_online_cnt'),
  topDomains: {
    topDomain: [
      {
        domainName: string(name='DomainName', description='dm_name'),
        rank: long(name='Rank', description='rank'),
        totalTraffic: string(name='TotalTraffic', description='t_traf'),
        trafficPercent: string(name='TrafficPercent', description='traf_per'),
        maxBps: long(name='MaxBps', description='max_bps'),
        maxBpsTime: string(name='MaxBpsTime', description='max_bps_time'),
        totalAccess: long(name='TotalAccess', description='t_acc'),
      }
    ](name='TopDomain', description='TopDomain'),
  }(name='TopDomains', description='data.content.data'),
}

async function describeVodTopDomainsByFlowWithOptions(request: DescribeVodTopDomainsByFlowRequest, runtime: Util.RuntimeOptions): DescribeVodTopDomainsByFlowResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodTopDomainsByFlow', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodTopDomainsByFlow(request: DescribeVodTopDomainsByFlowRequest): DescribeVodTopDomainsByFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodTopDomainsByFlowWithOptions(request, runtime);
}

model DescribeVodDomainPvDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainPvDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  pvDataInterval: {
    pvDataInterval: [
      {
        value: string(name='Value', description='pv'),
        timeStamp: string(name='TimeStamp', description='time_stp'),
      }
    ](name='PvDataInterval', description='PvDataInterval'),
  }(name='PvDataInterval', description='data.content'),
}

async function describeVodDomainPvDataWithOptions(request: DescribeVodDomainPvDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainPvDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainPvData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainPvData(request: DescribeVodDomainPvDataRequest): DescribeVodDomainPvDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainPvDataWithOptions(request, runtime);
}

model DescribeVodDomainUvDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainUvDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  uvDataInterval: {
    uvDataInterval: [
      {
        value: string(name='Value', description='uv'),
        timeStamp: string(name='TimeStamp', description='time_stp'),
      }
    ](name='UvDataInterval', description='UvDataInterval'),
  }(name='UvDataInterval', description='data.content'),
}

async function describeVodDomainUvDataWithOptions(request: DescribeVodDomainUvDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainUvDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainUvData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainUvData(request: DescribeVodDomainUvDataRequest): DescribeVodDomainUvDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainUvDataWithOptions(request, runtime);
}

model GetOSSFlowStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
  startTimeUTC?: string(name='StartTimeUTC', description='startTimeUTC'),
  endTimeUTC?: string(name='EndTimeUTC', description='endTimeUTC'),
  level: string(name='Level', description='level'),
  division?: string(name='Division', description='division'),
}

model GetOSSFlowStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  OSSFlowStatisList: [
    {
      statTime: string(name='StatTime', description='statTimeStr'),
      statTimeUTC: string(name='StatTimeUTC', description='statTimeUTC'),
      networkOut: long(name='NetworkOut', description='networkOut'),
    }
  ](name='OSSFlowStatisList', description='data.ossStatisList'),
}

async function getOSSFlowStatisWithOptions(request: GetOSSFlowStatisRequest, runtime: Util.RuntimeOptions): GetOSSFlowStatisResponse {
  Util.validateModel(request);
  return doRequest('GetOSSFlowStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getOSSFlowStatis(request: GetOSSFlowStatisRequest): GetOSSFlowStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOSSFlowStatisWithOptions(request, runtime);
}

model ListAIStatisTypeRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model ListAIStatisTypeResponse = {
  requestId: string(name='RequestId', description='requestId'),
  types: string(name='Types', description='data.types'),
}

async function listAIStatisTypeWithOptions(request: ListAIStatisTypeRequest, runtime: Util.RuntimeOptions): ListAIStatisTypeResponse {
  Util.validateModel(request);
  return doRequest('ListAIStatisType', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIStatisType(request: ListAIStatisTypeRequest): ListAIStatisTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIStatisTypeWithOptions(request, runtime);
}

model GetAIStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
  startTimeUTC?: string(name='StartTimeUTC', description='startTimeUTC'),
  endTimeUTC?: string(name='EndTimeUTC', description='endTimeUTC'),
  level: string(name='Level', description='level'),
  type: string(name='Type', description='type'),
  division?: string(name='Division', description='division'),
}

model GetAIStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIStatisList: [
    {
      statTime: string(name='StatTime', description='statTimeStr'),
      statTimeUTC: string(name='StatTimeUTC', description='statTimeUTC'),
      duration: long(name='Duration', description='duration'),
    }
  ](name='AIStatisList', description='data.aiStatisList'),
}

async function getAIStatisWithOptions(request: GetAIStatisRequest, runtime: Util.RuntimeOptions): GetAIStatisResponse {
  Util.validateModel(request);
  return doRequest('GetAIStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAIStatis(request: GetAIStatisRequest): GetAIStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAIStatisWithOptions(request, runtime);
}

model SetDefaultAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model SetDefaultAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function setDefaultAITemplateWithOptions(request: SetDefaultAITemplateRequest, runtime: Util.RuntimeOptions): SetDefaultAITemplateResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setDefaultAITemplate(request: SetDefaultAITemplateRequest): SetDefaultAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultAITemplateWithOptions(request, runtime);
}

model GetDefaultAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateType: string(name='TemplateType', description='templateType'),
}

model GetDefaultAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateInfo: {
    templateId: string(name='TemplateId', description='templateId'),
    templateType: string(name='TemplateType', description='templateType'),
    templateName: string(name='TemplateName', description='templateName'),
    templateConfig: string(name='TemplateConfig', description='templateConfig'),
    source: string(name='Source', description='source'),
    isDefault: string(name='IsDefault', description='isDefault'),
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
  }(name='TemplateInfo', description='data.templateInfo'),
}

async function getDefaultAITemplateWithOptions(request: GetDefaultAITemplateRequest, runtime: Util.RuntimeOptions): GetDefaultAITemplateResponse {
  Util.validateModel(request);
  return doRequest('GetDefaultAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getDefaultAITemplate(request: GetDefaultAITemplateRequest): GetDefaultAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultAITemplateWithOptions(request, runtime);
}

model ListAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateType: string(name='TemplateType', description='templateType'),
}

model ListAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateInfoList: [
    {
      templateId: string(name='TemplateId', description='templateId'),
      templateType: string(name='TemplateType', description='templateType'),
      templateName: string(name='TemplateName', description='templateName'),
      templateConfig: string(name='TemplateConfig', description='templateConfig'),
      source: string(name='Source', description='source'),
      isDefault: string(name='IsDefault', description='isDefault'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modifyTime: string(name='ModifyTime', description='modifyTime'),
    }
  ](name='TemplateInfoList', description='data.templateInfoList'),
}

async function listAITemplateWithOptions(request: ListAITemplateRequest, runtime: Util.RuntimeOptions): ListAITemplateResponse {
  Util.validateModel(request);
  return doRequest('ListAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAITemplate(request: ListAITemplateRequest): ListAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAITemplateWithOptions(request, runtime);
}

model GetAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model GetAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateInfo: {
    templateId: string(name='TemplateId', description='templateId'),
    templateType: string(name='TemplateType', description='templateType'),
    templateName: string(name='TemplateName', description='templateName'),
    templateConfig: string(name='TemplateConfig', description='templateConfig'),
    source: string(name='Source', description='source'),
    isDefault: string(name='IsDefault', description='isDefault'),
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
  }(name='TemplateInfo', description='data.templateInfo'),
}

async function getAITemplateWithOptions(request: GetAITemplateRequest, runtime: Util.RuntimeOptions): GetAITemplateResponse {
  Util.validateModel(request);
  return doRequest('GetAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAITemplate(request: GetAITemplateRequest): GetAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAITemplateWithOptions(request, runtime);
}

model UpdateAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
  templateName: string(name='TemplateName', description='templateName'),
  templateConfig: string(name='TemplateConfig', description='templateConfig'),
}

model UpdateAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function updateAITemplateWithOptions(request: UpdateAITemplateRequest, runtime: Util.RuntimeOptions): UpdateAITemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateAITemplate(request: UpdateAITemplateRequest): UpdateAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAITemplateWithOptions(request, runtime);
}

model DeleteAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model DeleteAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function deleteAITemplateWithOptions(request: DeleteAITemplateRequest, runtime: Util.RuntimeOptions): DeleteAITemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteAITemplate(request: DeleteAITemplateRequest): DeleteAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAITemplateWithOptions(request, runtime);
}

model AddAITemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateName: string(name='TemplateName', description='templateName'),
  templateType: string(name='TemplateType', description='templateType'),
  templateConfig: string(name='TemplateConfig', description='templateConfig'),
}

model AddAITemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateId: string(name='TemplateId', description='data.templateId'),
}

async function addAITemplateWithOptions(request: AddAITemplateRequest, runtime: Util.RuntimeOptions): AddAITemplateResponse {
  Util.validateModel(request);
  return doRequest('AddAITemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addAITemplate(request: AddAITemplateRequest): AddAITemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAITemplateWithOptions(request, runtime);
}

model GetMediaAuditResultTimelineRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model GetMediaAuditResultTimelineResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditResultTimeline: {
    porn: [
      {
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        timestamp: string(name='Timestamp', description='timestamp'),
      }
    ](name='Porn', description='porn'),
    terrorism: [
      {
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        timestamp: string(name='Timestamp', description='timestamp'),
      }
    ](name='Terrorism', description='terrorism'),
  }(name='MediaAuditResultTimeline', description='data.resultDTO'),
}

async function getMediaAuditResultTimelineWithOptions(request: GetMediaAuditResultTimelineRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultTimelineResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditResultTimeline', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaAuditResultTimeline(request: GetMediaAuditResultTimelineRequest): GetMediaAuditResultTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultTimelineWithOptions(request, runtime);
}

model GetMediaAuditResultDetailRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  pageNo: integer(name='PageNo', description='pageNo'),
}

model GetMediaAuditResultDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditResultDetail: {
    total: integer(name='Total', description='total'),
    list: [
      {
        pornLabel: string(name='PornLabel', description='pornLabel'),
        pornScore: string(name='PornScore', description='pornScore'),
        terrorismLabel: string(name='TerrorismLabel', description='terrorismLabel'),
        terrorismScore: string(name='TerrorismScore', description='terrorismScore'),
        timestamp: string(name='Timestamp', description='timestamp'),
        url: string(name='Url', description='url'),
      }
    ](name='List', description='list'),
  }(name='MediaAuditResultDetail', description='data.resultDTO'),
}

async function getMediaAuditResultDetailWithOptions(request: GetMediaAuditResultDetailRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultDetailResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditResultDetail', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaAuditResultDetail(request: GetMediaAuditResultDetailRequest): GetMediaAuditResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultDetailWithOptions(request, runtime);
}

model GetMediaAuditResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetMediaAuditResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditResult: {
    abnormalModules: string(name='AbnormalModules', description='abnormalContent'),
    label: string(name='Label', description='label'),
    suggestion: string(name='Suggestion', description='suggestion'),
    imageResult: [
      {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        type: string(name='Type', description='type'),
        url: string(name='Url', description='url'),
        result: [
          {
            suggestion: string(name='Suggestion', description='suggestion'),
            label: string(name='Label', description='label'),
            score: string(name='Score', description='score'),
            scene: string(name='Scene', description='scene'),
          }
        ](name='Result', description='result'),
      }
    ](name='ImageResult', description='imageResult'),
    textResult: [
      {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        score: string(name='Score', description='score'),
        scene: string(name='Scene', description='scene'),
        type: string(name='Type', description='type'),
        content: string(name='Content', description='content'),
      }
    ](name='TextResult', description='textResult'),
    videoResult: {
      suggestion: string(name='Suggestion', description='suggestion'),
      label: string(name='Label', description='label'),
      terrorismResult: {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        maxScore: string(name='MaxScore', description='maxScore'),
        averageScore: string(name='AverageScore', description='averageScore'),
        counterList: [
          {
            label: string(name='Label', description='label'),
            count: integer(name='Count', description='count'),
          }
        ](name='CounterList', description='counterList'),
        topList: [
          {
            label: string(name='Label', description='label'),
            score: string(name='Score', description='score'),
            timestamp: string(name='Timestamp', description='timestamp'),
            url: string(name='Url', description='url'),
          }
        ](name='TopList', description='topList'),
      }(name='TerrorismResult', description='terrorismResult'),
      pornResult: {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        maxScore: string(name='MaxScore', description='maxScore'),
        averageScore: string(name='AverageScore', description='averageScore'),
        counterList: [
          {
            label: string(name='Label', description='label'),
            count: integer(name='Count', description='count'),
          }
        ](name='CounterList', description='counterList'),
        topList: [
          {
            label: string(name='Label', description='label'),
            score: string(name='Score', description='score'),
            timestamp: string(name='Timestamp', description='timestamp'),
            url: string(name='Url', description='url'),
          }
        ](name='TopList', description='topList'),
      }(name='PornResult', description='pornResult'),
    }(name='VideoResult', description='videoResult'),
  }(name='MediaAuditResult', description='data.resultDTO'),
}

async function getMediaAuditResultWithOptions(request: GetMediaAuditResultRequest, runtime: Util.RuntimeOptions): GetMediaAuditResultResponse {
  Util.validateModel(request);
  return doRequest('GetMediaAuditResult', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaAuditResult(request: GetMediaAuditResultRequest): GetMediaAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaAuditResultWithOptions(request, runtime);
}

model SubmitAIMediaAuditJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaId: string(name='MediaId', description='mediaId'),
  templateId?: string(name='TemplateId', description='templateId'),
}

model SubmitAIMediaAuditJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
  jobId: string(name='JobId', description='data.jobId'),
}

async function submitAIMediaAuditJobWithOptions(request: SubmitAIMediaAuditJobRequest, runtime: Util.RuntimeOptions): SubmitAIMediaAuditJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIMediaAuditJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIMediaAuditJob(request: SubmitAIMediaAuditJobRequest): SubmitAIMediaAuditJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIMediaAuditJobWithOptions(request, runtime);
}

model GetAIMediaAuditJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  jobId: string(name='JobId', description='jobId'),
}

model GetAIMediaAuditJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaAuditJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    type: string(name='Type', description='type'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    completeTime: string(name='CompleteTime', description='completeTime'),
    data: {
      suggestion: string(name='Suggestion', description='suggestion'),
      abnormalModules: string(name='AbnormalModules', description='abnormalContent'),
      label: string(name='Label', description='label'),
      imageResult: [
        {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          type: string(name='Type', description='type'),
          url: string(name='Url', description='url'),
          result: [
            {
              suggestion: string(name='Suggestion', description='suggestion'),
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              scene: string(name='Scene', description='scene'),
            }
          ](name='Result', description='result'),
        }
      ](name='ImageResult', description='imageResult'),
      textResult: [
        {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          score: string(name='Score', description='score'),
          scene: string(name='Scene', description='scene'),
          type: string(name='Type', description='type'),
          content: string(name='Content', description='content'),
        }
      ](name='TextResult', description='textResult'),
      videoResult: {
        suggestion: string(name='Suggestion', description='suggestion'),
        label: string(name='Label', description='label'),
        terrorismResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='TerrorismResult', description='terrorismResult'),
        pornResult: {
          suggestion: string(name='Suggestion', description='suggestion'),
          label: string(name='Label', description='label'),
          maxScore: string(name='MaxScore', description='maxScore'),
          averageScore: string(name='AverageScore', description='averageScore'),
          counterList: [
            {
              label: string(name='Label', description='label'),
              count: integer(name='Count', description='count'),
            }
          ](name='CounterList', description='counterList'),
          topList: [
            {
              label: string(name='Label', description='label'),
              score: string(name='Score', description='score'),
              timestamp: string(name='Timestamp', description='timestamp'),
              url: string(name='Url', description='url'),
            }
          ](name='TopList', description='topList'),
        }(name='PornResult', description='pornResult'),
      }(name='VideoResult', description='videoResult'),
    }(name='Data', description='data'),
  }(name='MediaAuditJob', description='data.resultDTO'),
}

async function getAIMediaAuditJobWithOptions(request: GetAIMediaAuditJobRequest, runtime: Util.RuntimeOptions): GetAIMediaAuditJobResponse {
  Util.validateModel(request);
  return doRequest('GetAIMediaAuditJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAIMediaAuditJob(request: GetAIMediaAuditJobRequest): GetAIMediaAuditJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAIMediaAuditJobWithOptions(request, runtime);
}

model DisplayAIAuditSwitchRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
}

model DisplayAIAuditSwitchResponse = {
  requestId: string(name='RequestId', description='requestId'),
  isDisplay: boolean(name='IsDisplay', description='data.isDisplay'),
}

async function displayAIAuditSwitchWithOptions(request: DisplayAIAuditSwitchRequest, runtime: Util.RuntimeOptions): DisplayAIAuditSwitchResponse {
  Util.validateModel(request);
  return doRequest('DisplayAIAuditSwitch', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function displayAIAuditSwitch(request: DisplayAIAuditSwitchRequest): DisplayAIAuditSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return displayAIAuditSwitchWithOptions(request, runtime);
}

model DescribePlayVideoStatisRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  videoId: string(name='VideoId', description='videoId'),
}

model DescribePlayVideoStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoPlayStatisDetails: {
    videoPlayStatisDetail: [
      {
        date: string(name='Date', description='date'),
        playDuration: string(name='PlayDuration', description='playTime'),
        VV: string(name='VV', description='vv'),
        UV: string(name='UV', description='uv'),
        playRange: string(name='PlayRange', description='playRange'),
        title: string(name='Title', description='title'),
      }
    ](name='VideoPlayStatisDetail', description='VideoPlayStatisDetail'),
  }(name='VideoPlayStatisDetails', description='data.content.list'),
}

async function describePlayVideoStatisWithOptions(request: DescribePlayVideoStatisRequest, runtime: Util.RuntimeOptions): DescribePlayVideoStatisResponse {
  Util.validateModel(request);
  return doRequest('DescribePlayVideoStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describePlayVideoStatis(request: DescribePlayVideoStatisRequest): DescribePlayVideoStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePlayVideoStatisWithOptions(request, runtime);
}

model TransferMediaDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoId?: string(name='VideoId', description='videoId'),
  videoInfo?: string(name='VideoInfo', description='videoInfo'),
  mezzanineInfo?: string(name='MezzanineInfo', description='mezzanineInfo'),
  streamInfos?: string(name='StreamInfos', description='streamInfos'),
}

model TransferMediaDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function transferMediaDataWithOptions(request: TransferMediaDataRequest, runtime: Util.RuntimeOptions): TransferMediaDataResponse {
  Util.validateModel(request);
  return doRequest('TransferMediaData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function transferMediaData(request: TransferMediaDataRequest): TransferMediaDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferMediaDataWithOptions(request, runtime);
}

model CreateUploadAttachedMediaRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  title?: string(name='Title', description='title'),
  businessType: string(name='BusinessType', description='mediaType'),
  mediaExt: string(name='MediaExt', description='mediaExt'),
  fileName?: string(name='FileName', description='originalFileName'),
  tags?: string(name='Tags', description='tags'),
  cateId?: long(name='CateId', description='cateId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  description?: string(name='Description', description='description'),
  fileSize?: string(name='FileSize', description='fileSize'),
  userData?: string(name='UserData', description='userData'),
}

model CreateUploadAttachedMediaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
  mediaURL: string(name='MediaURL', description='data.mediaUrl'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
  fileURL: string(name='FileURL', description='data.fileUrl'),
}

async function createUploadAttachedMediaWithOptions(request: CreateUploadAttachedMediaRequest, runtime: Util.RuntimeOptions): CreateUploadAttachedMediaResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadAttachedMedia', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createUploadAttachedMedia(request: CreateUploadAttachedMediaRequest): CreateUploadAttachedMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadAttachedMediaWithOptions(request, runtime);
}

model GetUploadProgressRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  source?: string(name='Source', description='source'),
  clientId?: string(name='ClientId', description='clientId'),
  businessType?: string(name='BusinessType', description='businessType'),
  terminalType?: string(name='TerminalType', description='terminalType'),
  deviceModel?: string(name='DeviceModel', description='deviceModel'),
  appVersion?: string(name='AppVersion', description='appVersion'),
  authTimestamp: long(name='AuthTimestamp', description='authTimestamp'),
  authInfo: string(name='AuthInfo', description='authInfo'),
  uploadInfoList: string(name='UploadInfoList', description='uploadInfoList'),
  userId?: long(name='UserId', description='userId'),
  uploadAddress?: string(name='UploadAddress', description='uploadAddress'),
}

model GetUploadProgressResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadProgress: {
    uploadProgressList: [
      {
        source: string(name='Source', description='source'),
        clientId: string(name='ClientId', description='clientId'),
        businessType: string(name='BusinessType', description='businessType'),
        terminalType: string(name='TerminalType', description='terminalType'),
        deviceModel: string(name='DeviceModel', description='deviceModel'),
        appVersion: string(name='AppVersion', description='appVersion'),
        authTimestamp: string(name='AuthTimestamp', description='authTimestamp'),
        authInfo: string(name='AuthInfo', description='authInfo'),
        fileName: string(name='FileName', description='fileName'),
        fileSize: long(name='FileSize', description='fileSize'),
        fileCreateTime: string(name='FileCreateTime', description='fileCreateTime'),
        fileHash: string(name='FileHash', description='fileHash'),
        uploadSpeed: float(name='UploadSpeed', description='uploadSpeed'),
        uploadRatio: float(name='UploadRatio', description='uploadRatio'),
        uploadId: string(name='UploadId', description='uploadId'),
        donePartsCount: integer(name='DonePartsCount', description='donePartsCount'),
        totalPart: string(name='TotalPart', description='totalPart'),
        partSize: long(name='PartSize', description='partSize'),
        uploadPoint: string(name='UploadPoint', description='uploadPoint'),
        uploadAddress: string(name='UploadAddress', description='uploadAddress'),
        videoId: string(name='VideoId', description='videoId'),
      }
    ](name='UploadProgressList', description='uploadProgressList'),
  }(name='UploadProgress', description='data.uploadProgress'),
}

async function getUploadProgressWithOptions(request: GetUploadProgressRequest, runtime: Util.RuntimeOptions): GetUploadProgressResponse {
  Util.validateModel(request);
  return doRequest('GetUploadProgress', 'HTTPS', 'POST', '2017-03-14', 'Anonymous', request, null, runtime);
}

async function getUploadProgress(request: GetUploadProgressRequest): GetUploadProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUploadProgressWithOptions(request, runtime);
}

model UpdateVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
  name?: string(name='Name', description='name'),
  templateConfig?: string(name='TemplateConfig', description='templateConfig'),
}

model UpdateVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function updateVodTemplateWithOptions(request: UpdateVodTemplateRequest, runtime: Util.RuntimeOptions): UpdateVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateVodTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateVodTemplate(request: UpdateVodTemplateRequest): UpdateVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVodTemplateWithOptions(request, runtime);
}

model SetDefaultVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
}

model SetDefaultVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function setDefaultVodTemplateWithOptions(request: SetDefaultVodTemplateRequest, runtime: Util.RuntimeOptions): SetDefaultVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultVodTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setDefaultVodTemplate(request: SetDefaultVodTemplateRequest): SetDefaultVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultVodTemplateWithOptions(request, runtime);
}

model ListVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateType: string(name='TemplateType', description='templateType'),
}

model ListVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateInfoList: [
    {
      name: string(name='Name', description='name'),
      vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
      templateType: string(name='TemplateType', description='templateType'),
      subTemplateType: string(name='SubTemplateType', description='subTemplateType'),
      source: string(name='Source', description='source'),
      isDefault: string(name='IsDefault', description='isDefault'),
      templateConfig: string(name='TemplateConfig', description='templateConfig'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modifyTime: string(name='ModifyTime', description='modifyTime'),
    }
  ](name='VodTemplateInfoList', description='data.vodTemplateInfoList'),
}

async function listVodTemplateWithOptions(request: ListVodTemplateRequest, runtime: Util.RuntimeOptions): ListVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('ListVodTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listVodTemplate(request: ListVodTemplateRequest): ListVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVodTemplateWithOptions(request, runtime);
}

model GetVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
}

model GetVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateInfo: {
    name: string(name='Name', description='name'),
    vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
    templateType: string(name='TemplateType', description='templateType'),
    subTemplateType: string(name='SubTemplateType', description='subTemplateType'),
    source: string(name='Source', description='source'),
    isDefault: string(name='IsDefault', description='isDefault'),
    templateConfig: string(name='TemplateConfig', description='templateConfig'),
    creationTime: string(name='CreationTime', description='creationTime'),
    modifyTime: string(name='ModifyTime', description='modifyTime'),
  }(name='VodTemplateInfo', description='data.vodTemplateInfo'),
}

async function getVodTemplateWithOptions(request: GetVodTemplateRequest, runtime: Util.RuntimeOptions): GetVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('GetVodTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVodTemplate(request: GetVodTemplateRequest): GetVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVodTemplateWithOptions(request, runtime);
}

model DeleteVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  vodTemplateId: string(name='VodTemplateId', description='vodTemplateId'),
}

model DeleteVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function deleteVodTemplateWithOptions(request: DeleteVodTemplateRequest, runtime: Util.RuntimeOptions): DeleteVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteVodTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteVodTemplate(request: DeleteVodTemplateRequest): DeleteVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVodTemplateWithOptions(request, runtime);
}

model AddVodTemplateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name: string(name='Name', description='name'),
  templateType: string(name='TemplateType', description='templateType'),
  subTemplateType?: string(name='SubTemplateType', description='subTemplateType'),
  templateConfig: string(name='TemplateConfig', description='templateConfig'),
}

model AddVodTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  vodTemplateId: string(name='VodTemplateId', description='data.vodTemplateId'),
}

async function addVodTemplateWithOptions(request: AddVodTemplateRequest, runtime: Util.RuntimeOptions): AddVodTemplateResponse {
  Util.validateModel(request);
  return doRequest('AddVodTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addVodTemplate(request: AddVodTemplateRequest): AddVodTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVodTemplateWithOptions(request, runtime);
}

model GetMediaDNAResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model GetMediaDNAResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  DNAResult: {
    videoDNA: [
      {
        primaryKey: string(name='PrimaryKey', description='primaryKey'),
        similarity: string(name='Similarity', description='similarity'),
        fpShotSlices: [
          {
            input: {
              start: string(name='Start', description='start'),
              duration: string(name='Duration', description='duration'),
            }(name='Input', description='input'),
            duplication: {
              start: string(name='Start', description='start'),
              duration: string(name='Duration', description='duration'),
            }(name='Duplication', description='duplication'),
          }
        ](name='FpShotSlices', description='fpShotSlices'),
      }
    ](name='VideoDNA', description='videoDNA'),
  }(name='DNAResult', description='data.resultDTO'),
}

async function getMediaDNAResultWithOptions(request: GetMediaDNAResultRequest, runtime: Util.RuntimeOptions): GetMediaDNAResultResponse {
  Util.validateModel(request);
  return doRequest('GetMediaDNAResult', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaDNAResult(request: GetMediaDNAResultRequest): GetMediaDNAResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaDNAResultWithOptions(request, runtime);
}

model DeleteMezzaninesRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIdStr'),
  force?: boolean(name='Force', description='force'),
}

model DeleteMezzaninesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
  unRemoveableVideoIds: [ string ] (name='UnRemoveableVideoIds', description='data.unremoveableVideoIds'),
}

async function deleteMezzaninesWithOptions(request: DeleteMezzaninesRequest, runtime: Util.RuntimeOptions): DeleteMezzaninesResponse {
  Util.validateModel(request);
  return doRequest('DeleteMezzanines', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteMezzanines(request: DeleteMezzaninesRequest): DeleteMezzaninesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMezzaninesWithOptions(request, runtime);
}

model UpdateImageInfosRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  updateContent: string(name='UpdateContent', description='updateContent'),
}

model UpdateImageInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistImageIds: {
    imageId: [ string ](name='ImageId', description='ImageId'),
  }(name='NonExistImageIds', description='data.nonExistImageIds'),
}

async function updateImageInfosWithOptions(request: UpdateImageInfosRequest, runtime: Util.RuntimeOptions): UpdateImageInfosResponse {
  Util.validateModel(request);
  return doRequest('UpdateImageInfos', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateImageInfos(request: UpdateImageInfosRequest): UpdateImageInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageInfosWithOptions(request, runtime);
}

model DescribeVodDomainUsageDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  type?: string(name='Type', description='type'),
  area?: string(name='Area', description='area'),
  field: string(name='Field', description='field'),
}

model DescribeVodDomainUsageDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  type: string(name='Type', description='data.field'),
  area: string(name='Area', description='data.area'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  usageDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='value'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='UsageDataPerInterval', description='data.content'),
}

async function describeVodDomainUsageDataWithOptions(request: DescribeVodDomainUsageDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainUsageDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainUsageData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainUsageData(request: DescribeVodDomainUsageDataRequest): DescribeVodDomainUsageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainUsageDataWithOptions(request, runtime);
}

model DescribeVodDomainTrafficDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainTrafficDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  trafficDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_vod_all_all_all_traf'),
        domesticValue: string(name='DomesticValue', description='l1_vod_all_inner_all_traf'),
        overseasValue: string(name='OverseasValue', description='l1_vod_all_out_all_traf'),
        httpsValue: string(name='HttpsValue', description='l1_vod_all_all_https_traf'),
        httpsDomesticValue: string(name='HttpsDomesticValue', description='l1_vod_all_inner_https_traf'),
        httpsOverseasValue: string(name='HttpsOverseasValue', description='l1_vod_all_out_https_traf'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='TrafficDataPerInterval', description='data.content.data'),
}

async function describeVodDomainTrafficDataWithOptions(request: DescribeVodDomainTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainTrafficData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainTrafficData(request: DescribeVodDomainTrafficDataRequest): DescribeVodDomainTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainTrafficDataWithOptions(request, runtime);
}

model DescribeVodDomainsUsageByDayRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainsUsageByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  dataInterval: string(name='DataInterval', description='data.dataInterval'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  usageByDays: {
    usageByDay: [
      {
        timeStamp: string(name='TimeStamp', description='timeStamp'),
        qps: string(name='Qps', description='qps'),
        bytesHitRate: string(name='BytesHitRate', description='byteHitRate'),
        requestHitRate: string(name='RequestHitRate', description='requestHitRate'),
        maxBps: string(name='MaxBps', description='maxBps'),
        maxBpsTime: string(name='MaxBpsTime', description='maxBpsTime'),
        maxSrcBps: string(name='MaxSrcBps', description='maxSrcBps'),
        maxSrcBpsTime: string(name='MaxSrcBpsTime', description='maxSrcBpsTime'),
        totalAccess: string(name='TotalAccess', description='totalAccess'),
        totalTraffic: string(name='TotalTraffic', description='totalTraffic'),
      }
    ](name='UsageByDay', description='UsageByDay'),
  }(name='UsageByDays', description='data.content.usageByDays'),
  usageTotal: {
    bytesHitRate: string(name='BytesHitRate', description='byteHitRate'),
    requestHitRate: string(name='RequestHitRate', description='requestHitRate'),
    maxBps: string(name='MaxBps', description='maxBps'),
    maxBpsTime: string(name='MaxBpsTime', description='maxBpsTime'),
    maxSrcBps: string(name='MaxSrcBps', description='maxSrcBps'),
    maxSrcBpsTime: string(name='MaxSrcBpsTime', description='maxSrcBpsTime'),
    totalAccess: string(name='TotalAccess', description='totalAccess'),
    totalTraffic: string(name='TotalTraffic', description='totalTraffic'),
  }(name='UsageTotal', description='data.content.usageTotal'),
}

async function describeVodDomainsUsageByDayWithOptions(request: DescribeVodDomainsUsageByDayRequest, runtime: Util.RuntimeOptions): DescribeVodDomainsUsageByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainsUsageByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainsUsageByDay(request: DescribeVodDomainsUsageByDayRequest): DescribeVodDomainsUsageByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainsUsageByDayWithOptions(request, runtime);
}

model DescribeVodDomainSrcTrafficDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
}

model DescribeVodDomainSrcTrafficDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  srcTrafficDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='origin_vod_all_all_all_traf'),
        httpsValue: string(name='HttpsValue', description='origin_vod_all_all_https_traf'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='SrcTrafficDataPerInterval', description='data.content.data'),
}

async function describeVodDomainSrcTrafficDataWithOptions(request: DescribeVodDomainSrcTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainSrcTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainSrcTrafficData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainSrcTrafficData(request: DescribeVodDomainSrcTrafficDataRequest): DescribeVodDomainSrcTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainSrcTrafficDataWithOptions(request, runtime);
}

model DescribeVodDomainSrcBpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
}

model DescribeVodDomainSrcBpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  srcBpsDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='origin_vod_all_all_all_bps'),
        httpsValue: string(name='HttpsValue', description='origin_vod_all_all_https_bps'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='SrcBpsDataPerInterval', description='data.content.data'),
}

async function describeVodDomainSrcBpsDataWithOptions(request: DescribeVodDomainSrcBpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainSrcBpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainSrcBpsData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainSrcBpsData(request: DescribeVodDomainSrcBpsDataRequest): DescribeVodDomainSrcBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainSrcBpsDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeTrafficDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeTrafficDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  realTimeTrafficDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_all_all_all_all_traf'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='RealTimeTrafficDataPerInterval', description='data.content.data'),
}

async function describeVodDomainRealTimeTrafficDataWithOptions(request: DescribeVodDomainRealTimeTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeTrafficData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeTrafficData(request: DescribeVodDomainRealTimeTrafficDataRequest): DescribeVodDomainRealTimeTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeTrafficDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeSrcTrafficDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeSrcTrafficDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  realTimeSrcTrafficDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='origin_all_all_all_all_traf'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='RealTimeSrcTrafficDataPerInterval', description='data.content.data'),
}

async function describeVodDomainRealTimeSrcTrafficDataWithOptions(request: DescribeVodDomainRealTimeSrcTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeSrcTrafficDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeSrcTrafficData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeSrcTrafficData(request: DescribeVodDomainRealTimeSrcTrafficDataRequest): DescribeVodDomainRealTimeSrcTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeSrcTrafficDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeSrcBpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeSrcBpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  realTimeSrcBpsDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='origin_all_all_all_all_bps'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='RealTimeSrcBpsDataPerInterval', description='data.content.data'),
}

async function describeVodDomainRealTimeSrcBpsDataWithOptions(request: DescribeVodDomainRealTimeSrcBpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeSrcBpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeSrcBpsData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeSrcBpsData(request: DescribeVodDomainRealTimeSrcBpsDataRequest): DescribeVodDomainRealTimeSrcBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeSrcBpsDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeReqHitRateDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeReqHitRateDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: {
    reqHitRateDataModel: [
      {
        reqHitRate: float(name='ReqHitRate', description='req_hit_rate'),
        timeStamp: string(name='TimeStamp', description='time_stp'),
      }
    ](name='ReqHitRateDataModel', description='ReqHitRateDataModel'),
  }(name='Data', description='data.content'),
}

async function describeVodDomainRealTimeReqHitRateDataWithOptions(request: DescribeVodDomainRealTimeReqHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeReqHitRateDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeReqHitRateData', 'HTTPS', 'GET', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeReqHitRateData(request: DescribeVodDomainRealTimeReqHitRateDataRequest): DescribeVodDomainRealTimeReqHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeReqHitRateDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeQpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeQpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: {
    qpsModel: [
      {
        qps: float(name='Qps', description='l1_qps'),
        timeStamp: string(name='TimeStamp', description='time_stp'),
      }
    ](name='QpsModel', description='QpsModel'),
  }(name='Data', description='data.content'),
}

async function describeVodDomainRealTimeQpsDataWithOptions(request: DescribeVodDomainRealTimeQpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeQpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeQpsData', 'HTTPS', 'GET', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeQpsData(request: DescribeVodDomainRealTimeQpsDataRequest): DescribeVodDomainRealTimeQpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeQpsDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeHttpCodeDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainRealTimeHttpCodeDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  realTimeHttpCodeData: {
    usageData: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: {
          realTimeCodeProportionData: [
            {
              code: string(name='Code', description='code'),
              proportion: string(name='Proportion', description='number'),
              count: string(name='Count', description='count'),
            }
          ](name='RealTimeCodeProportionData', description='RealTimeCodeProportionData'),
        }(name='Value', description='l1_all_all_all_all_http_code'),
      }
    ](name='UsageData', description='UsageData'),
  }(name='RealTimeHttpCodeData', description='data.content.data'),
}

async function describeVodDomainRealTimeHttpCodeDataWithOptions(request: DescribeVodDomainRealTimeHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeHttpCodeDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeHttpCodeData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeHttpCodeData(request: DescribeVodDomainRealTimeHttpCodeDataRequest): DescribeVodDomainRealTimeHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeHttpCodeDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeByteHitRateDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeByteHitRateDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: {
    byteHitRateDataModel: [
      {
        byteHitRate: float(name='ByteHitRate', description='byte_hit_rate'),
        timeStamp: string(name='TimeStamp', description='time_stp'),
      }
    ](name='ByteHitRateDataModel', description='ByteHitRateDataModel'),
  }(name='Data', description='data.content'),
}

async function describeVodDomainRealTimeByteHitRateDataWithOptions(request: DescribeVodDomainRealTimeByteHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeByteHitRateDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeByteHitRateData', 'HTTPS', 'GET', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeByteHitRateData(request: DescribeVodDomainRealTimeByteHitRateDataRequest): DescribeVodDomainRealTimeByteHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeByteHitRateDataWithOptions(request, runtime);
}

model DescribeVodDomainRealTimeBpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainRealTimeBpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  data: {
    bpsModel: [
      {
        bps: float(name='Bps', description='l1_bps'),
        timeStamp: string(name='TimeStamp', description='time_stp'),
      }
    ](name='BpsModel', description='BpsModel'),
  }(name='Data', description='data.content'),
}

async function describeVodDomainRealTimeBpsDataWithOptions(request: DescribeVodDomainRealTimeBpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainRealTimeBpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainRealTimeBpsData', 'HTTPS', 'GET', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainRealTimeBpsData(request: DescribeVodDomainRealTimeBpsDataRequest): DescribeVodDomainRealTimeBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainRealTimeBpsDataWithOptions(request, runtime);
}

model DescribeVodDomainQpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainQpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  qpsDataInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_vod_all_all_all_qps'),
        domesticValue: string(name='DomesticValue', description='l1_vod_all_inner_all_qps'),
        overseasValue: string(name='OverseasValue', description='l1_vod_all_out_all_qps'),
        accValue: string(name='AccValue', description='l1_vod_all_all_all_acc'),
        accDomesticValue: string(name='AccDomesticValue', description='l1_vod_all_inner_out_acc'),
        accOverseasValue: string(name='AccOverseasValue', description='l1_vod_all_out_all_acc'),
        httpsValue: string(name='HttpsValue', description='l1_vod_all_all_https_qps'),
        httpsDomesticValue: string(name='HttpsDomesticValue', description='l1_vod_all_inner_https_qps'),
        httpsOverseasValue: string(name='HttpsOverseasValue', description='l1_vod_all_out_https_qps'),
        httpsAccValue: string(name='HttpsAccValue', description='l1_vod_all_all_https_acc'),
        httpsAccDomesticValue: string(name='HttpsAccDomesticValue', description='l1_vod_all_inner_https_acc'),
        httpsAccOverseasValue: string(name='HttpsAccOverseasValue', description='l1_vod_all_out_https_acc'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='QpsDataInterval', description='data.content.data'),
}

async function describeVodDomainQpsDataWithOptions(request: DescribeVodDomainQpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainQpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainQpsData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainQpsData(request: DescribeVodDomainQpsDataRequest): DescribeVodDomainQpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainQpsDataWithOptions(request, runtime);
}

model DescribeVodDomainHttpCodeDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
}

model DescribeVodDomainHttpCodeDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  httpCodeData: {
    usageData: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: {
          codeProportionData: [
            {
              code: string(name='Code', description='code'),
              proportion: string(name='Proportion', description='number'),
              count: string(name='Count', description='count'),
            }
          ](name='CodeProportionData', description='CodeProportionData'),
        }(name='Value', description='l1_vod_all_all_all_http_code'),
      }
    ](name='UsageData', description='UsageData'),
  }(name='HttpCodeData', description='data.content.data'),
}

async function describeVodDomainHttpCodeDataWithOptions(request: DescribeVodDomainHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainHttpCodeDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainHttpCodeData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainHttpCodeData(request: DescribeVodDomainHttpCodeDataRequest): DescribeVodDomainHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainHttpCodeDataWithOptions(request, runtime);
}

model DescribeVodDomainHitRateDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainHitRateDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  hitRateInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_vod_all_all_all_byte_hit_rate'),
        httpsValue: string(name='HttpsValue', description='l1_vod_all_all_https_byte_hit_rate'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='HitRateInterval', description='data.content.data'),
}

async function describeVodDomainHitRateDataWithOptions(request: DescribeVodDomainHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainHitRateDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainHitRateData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainHitRateData(request: DescribeVodDomainHitRateDataRequest): DescribeVodDomainHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainHitRateDataWithOptions(request, runtime);
}

model DescribeVodDomainBpsDataRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  interval?: string(name='Interval', description='interval'),
  ispNameEn?: string(name='IspNameEn', description='ispName'),
  locationNameEn?: string(name='LocationNameEn', description='locName'),
}

model DescribeVodDomainBpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  locationNameEn: string(name='LocationNameEn', description='data.locName'),
  ispNameEn: string(name='IspNameEn', description='data.ispName'),
  dataInterval: string(name='DataInterval', description='data.content.interval'),
  bpsDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='time_stp'),
        value: string(name='Value', description='l1_vod_all_all_all_bps'),
        domesticValue: string(name='DomesticValue', description='l1_vod_all_inner_all_bps'),
        overseasValue: string(name='OverseasValue', description='l1_vod_all_out_all_bps'),
        httpsValue: string(name='HttpsValue', description='l1_vod_all_all_https_bps'),
        httpsDomesticValue: string(name='HttpsDomesticValue', description='l1_vod_all_inner_https_bps'),
        httpsOverseasValue: string(name='HttpsOverseasValue', description='l1_vod_all_out_https_bps'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='BpsDataPerInterval', description='data.content.data'),
}

async function describeVodDomainBpsDataWithOptions(request: DescribeVodDomainBpsDataRequest, runtime: Util.RuntimeOptions): DescribeVodDomainBpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainBpsData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainBpsData(request: DescribeVodDomainBpsDataRequest): DescribeVodDomainBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainBpsDataWithOptions(request, runtime);
}

model GetVideoDNAResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model GetVideoDNAResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoDNAResult: {
    fpShots: [
      {
        primaryKey: string(name='PrimaryKey', description='primaryKey'),
        similarity: string(name='Similarity', description='similarity'),
        fpShotSlices: [
          {
            input: {
              start: string(name='Start', description='start'),
              duration: string(name='Duration', description='duration'),
            }(name='Input', description='input'),
            duplication: {
              start: string(name='Start', description='start'),
              duration: string(name='Duration', description='duration'),
            }(name='Duplication', description='duplication'),
          }
        ](name='FpShotSlices', description='fpShotSlices'),
      }
    ](name='FpShots', description='fpShots'),
  }(name='AIVideoDNAResult', description='data.resultDTO'),
}

async function getVideoDNAResultWithOptions(request: GetVideoDNAResultRequest, runtime: Util.RuntimeOptions): GetVideoDNAResultResponse {
  Util.validateModel(request);
  return doRequest('GetVideoDNAResult', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoDNAResult(request: GetVideoDNAResultRequest): GetVideoDNAResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoDNAResultWithOptions(request, runtime);
}

model DescribeVodCertificateDetailRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  certName: string(name='CertName', description='certName'),
}

model DescribeVodCertificateDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  cert: string(name='Cert', description='data.cert'),
  key: string(name='Key', description='data.key'),
  certId: long(name='CertId', description='data.certId'),
  certName: string(name='CertName', description='data.certName'),
}

async function describeVodCertificateDetailWithOptions(request: DescribeVodCertificateDetailRequest, runtime: Util.RuntimeOptions): DescribeVodCertificateDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodCertificateDetail', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodCertificateDetail(request: DescribeVodCertificateDetailRequest): DescribeVodCertificateDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodCertificateDetailWithOptions(request, runtime);
}

model DeleteImageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  deleteImageType: string(name='DeleteImageType', description='deleteImageType'),
  imageURLs?: string(name='ImageURLs', description='imageURLs'),
  imageIds?: string(name='ImageIds', description='imageIds'),
  videoId?: string(name='VideoId', description='videoId'),
  imageType?: string(name='ImageType', description='imageType'),
}

model DeleteImageResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  return doRequest('DeleteImage', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model GetAuditResultDetailRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  pageNo?: integer(name='PageNo', description='pageNo'),
}

model GetAuditResultDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIAuditResultDetail: {
    total: integer(name='Total', description='total'),
    list: [
      {
        pornLabel: string(name='PornLabel', description='pornLabel'),
        pornScore: string(name='PornScore', description='pornScore'),
        terrorismLabel: string(name='TerrorismLabel', description='terrorismLabel'),
        terrorismScore: string(name='TerrorismScore', description='terrorismScore'),
        index: string(name='Index', description='index'),
        object: string(name='Object', description='object'),
        timestamp: string(name='Timestamp', description='timestamp'),
      }
    ](name='List', description='list'),
  }(name='AIAuditResultDetail', description='data.resultDTO'),
}

async function getAuditResultDetailWithOptions(request: GetAuditResultDetailRequest, runtime: Util.RuntimeOptions): GetAuditResultDetailResponse {
  Util.validateModel(request);
  return doRequest('GetAuditResultDetail', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAuditResultDetail(request: GetAuditResultDetailRequest): GetAuditResultDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuditResultDetailWithOptions(request, runtime);
}

model GetMediaStreamRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  jobId?: string(name='JobId', description='jobId'),
  playURL?: string(name='PlayURL', description='playURL'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetMediaStreamResponse = {
  requestId: string(name='RequestId', description='requestId'),
  streamInfo: {
    videoId: string(name='VideoId', description='videoId'),
    fileType: string(name='FileType', description='fileType'),
    audioStream: {
      index: string(name='Index', description='index'),
      codecName: string(name='CodecName', description='codecName'),
      codecLongName: string(name='CodecLongName', description='codecLongName'),
      codecTimeBase: string(name='CodecTimeBase', description='codecTimeBase'),
      codecTagString: string(name='CodecTagString', description='codecTagString'),
      codecTag: string(name='CodecTag', description='codecTag'),
      sampleFmt: string(name='SampleFmt', description='sampleFmt'),
      sampleRate: string(name='SampleRate', description='sampleRate'),
      channels: string(name='Channels', description='channels'),
      channelLayout: string(name='ChannelLayout', description='channelLayout'),
      timebase: string(name='Timebase', description='timebase'),
      startTime: string(name='StartTime', description='startTime'),
      duration: string(name='Duration', description='duration'),
      bitrate: string(name='Bitrate', description='bitrate'),
      numFrames: string(name='NumFrames', description='numFrames'),
      lang: string(name='Lang', description='lang'),
    }(name='AudioStream', description='audioStream'),
    videoStream: {
      index: string(name='Index', description='index'),
      codecName: string(name='CodecName', description='codecName'),
      codecLongName: string(name='CodecLongName', description='codecLongName'),
      profile: string(name='Profile', description='profile'),
      codecTimeBase: string(name='CodecTimeBase', description='codecTimeBase'),
      codecTagString: string(name='CodecTagString', description='codecTagString'),
      codecTag: string(name='CodecTag', description='codecTag'),
      width: string(name='Width', description='width'),
      height: string(name='Height', description='height'),
      hasBFrames: string(name='HasBFrames', description='hasBFrames'),
      sar: string(name='Sar', description='sar'),
      dar: string(name='Dar', description='dar'),
      pixFmt: string(name='PixFmt', description='pixFmt'),
      level: string(name='Level', description='level'),
      fps: string(name='Fps', description='fps'),
      avgFPS: string(name='AvgFPS', description='avgFPS'),
      timebase: string(name='Timebase', description='timebase'),
      startTime: string(name='StartTime', description='startTime'),
      duration: string(name='Duration', description='duration'),
      numFrames: string(name='NumFrames', description='numFrames'),
      lang: string(name='Lang', description='lang'),
    }(name='VideoStream', description='videoStream'),
    playInfo: {
      width: long(name='Width', description='width'),
      height: long(name='Height', description='height'),
      size: long(name='Size', description='size'),
      playURL: string(name='PlayURL', description='playURL'),
      bitrate: string(name='Bitrate', description='bitrate'),
      definition: string(name='Definition', description='definition'),
      duration: string(name='Duration', description='duration'),
      format: string(name='Format', description='format'),
      fps: string(name='Fps', description='fps'),
      encrypt: long(name='Encrypt', description='encrypt'),
      plaintext: string(name='Plaintext', description='plaintext'),
      complexity: string(name='Complexity', description='complexity'),
      streamType: string(name='StreamType', description='streamType'),
      rand: string(name='Rand', description='rand'),
      jobId: string(name='JobId', description='jobId'),
      preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
      watermarkId: string(name='WatermarkId', description='watermarkId'),
      status: string(name='Status', description='status'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modificationTime: string(name='ModificationTime', description='modificationTime'),
      encryptType: string(name='EncryptType', description='encryptType'),
      templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
      source: string(name='Source', description='source'),
    }(name='PlayInfo', description='playInfo'),
  }(name='StreamInfo', description='data.streamInfo'),
}

async function getMediaStreamWithOptions(request: GetMediaStreamRequest, runtime: Util.RuntimeOptions): GetMediaStreamResponse {
  Util.validateModel(request);
  return doRequest('GetMediaStream', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaStream(request: GetMediaStreamRequest): GetMediaStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaStreamWithOptions(request, runtime);
}

model PayOrderCallbackRequest = {
  accessKeyId?: string(name='AccessKeyId', description='accessKeyId'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  product?: string(name='product', description='product'),
  version?: string(name='version', description='version'),
  action?: string(name='action', description='action'),
  regionId?: string(name='regionId', description='regionId'),
  domain?: string(name='domain', description='domain'),
  data?: string(name='data', description='data'),
}

model PayOrderCallbackResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
  data: string(name='data', description='data'),
}

async function payOrderCallbackWithOptions(request: PayOrderCallbackRequest, runtime: Util.RuntimeOptions): PayOrderCallbackResponse {
  Util.validateModel(request);
  return doRequest('PayOrderCallback', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function payOrderCallback(request: PayOrderCallbackRequest): PayOrderCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return payOrderCallbackWithOptions(request, runtime);
}

model ModifyRequest = {
  accessKeyId?: string(name='AccessKeyId', description='accessKeyId'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  product?: string(name='product', description='product'),
  version?: string(name='version', description='version'),
  action?: string(name='action', description='action'),
  regionId?: string(name='regionId', description='regionId'),
  domain?: string(name='domain', description='domain'),
  data?: string(name='data', description='data'),
}

model ModifyResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
  data: string(name='data', description='data'),
}

async function modifyWithOptions(request: ModifyRequest, runtime: Util.RuntimeOptions): ModifyResponse {
  Util.validateModel(request);
  return doRequest('Modify', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function modify(request: ModifyRequest): ModifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWithOptions(request, runtime);
}

model CompleteOrderParamRequest = {
  accessKeyId?: string(name='AccessKeyId', description='accessKeyId'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  product?: string(name='product', description='product'),
  version?: string(name='version', description='version'),
  action?: string(name='action', description='action'),
  regionId?: string(name='regionId', description='regionId'),
  domain?: string(name='domain', description='domain'),
  data?: string(name='data', description='data'),
}

model CompleteOrderParamResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
  data: string(name='data', description='data'),
}

async function completeOrderParamWithOptions(request: CompleteOrderParamRequest, runtime: Util.RuntimeOptions): CompleteOrderParamResponse {
  Util.validateModel(request);
  return doRequest('CompleteOrderParam', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function completeOrderParam(request: CompleteOrderParamRequest): CompleteOrderParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeOrderParamWithOptions(request, runtime);
}

model UpdateTemplateGroupDaemonRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateGroupId: string(name='TemplateGroupId', description='groupId'),
  userId: long(name='UserId', description='userId'),
  isLocked?: string(name='IsLocked', description='locked'),
  groupName?: string(name='GroupName', description='name'),
}

model UpdateTemplateGroupDaemonResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function updateTemplateGroupDaemonWithOptions(request: UpdateTemplateGroupDaemonRequest, runtime: Util.RuntimeOptions): UpdateTemplateGroupDaemonResponse {
  Util.validateModel(request);
  return doRequest('UpdateTemplateGroupDaemon', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateTemplateGroupDaemon(request: UpdateTemplateGroupDaemonRequest): UpdateTemplateGroupDaemonResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateGroupDaemonWithOptions(request, runtime);
}

model CreateKMSServiceKeyRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  kmsRegionId?: string(name='KmsRegionId', description='kmsRegionId'),
}

model CreateKMSServiceKeyResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function createKMSServiceKeyWithOptions(request: CreateKMSServiceKeyRequest, runtime: Util.RuntimeOptions): CreateKMSServiceKeyResponse {
  Util.validateModel(request);
  return doRequest('CreateKMSServiceKey', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createKMSServiceKey(request: CreateKMSServiceKeyRequest): CreateKMSServiceKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createKMSServiceKeyWithOptions(request, runtime);
}

model SetAuditSecurityIpRequest = {
  securityGroupName?: string(name='SecurityGroupName', description='securityGroupName'),
  ips: string(name='Ips', description='ips'),
  operateMode?: string(name='OperateMode', description='operateMode'),
}

model SetAuditSecurityIpResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setAuditSecurityIpWithOptions(request: SetAuditSecurityIpRequest, runtime: Util.RuntimeOptions): SetAuditSecurityIpResponse {
  Util.validateModel(request);
  return doRequest('SetAuditSecurityIp', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setAuditSecurityIp(request: SetAuditSecurityIpRequest): SetAuditSecurityIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAuditSecurityIpWithOptions(request, runtime);
}

model ListAuditSecurityIpRequest = {
  securityGroupName?: string(name='SecurityGroupName', description='securityGroupName'),
}

model ListAuditSecurityIpResponse = {
  requestId: string(name='RequestId', description='requestId'),
  securityIpList: [
    {
      securityGroupName: string(name='SecurityGroupName', description='securityGroupName'),
      ips: string(name='Ips', description='ips'),
      creationTime: string(name='CreationTime', description='creationTime'),
      modificationTime: string(name='ModificationTime', description='modifyTime'),
    }
  ](name='SecurityIpList', description='data.auditSecurityGroupDTOS'),
}

async function listAuditSecurityIpWithOptions(request: ListAuditSecurityIpRequest, runtime: Util.RuntimeOptions): ListAuditSecurityIpResponse {
  Util.validateModel(request);
  return doRequest('ListAuditSecurityIp', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAuditSecurityIp(request: ListAuditSecurityIpRequest): ListAuditSecurityIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAuditSecurityIpWithOptions(request, runtime);
}

model GetVideoInfosRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIds'),
}

model GetVideoInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoList: [
    {
      videoId: string(name='VideoId', description='mediaId'),
      title: string(name='Title', description='title'),
      tags: string(name='Tags', description='tags'),
      status: string(name='Status', description='state'),
      size: long(name='Size', description='fileSize'),
      duration: float(name='Duration', description='duration'),
      description: string(name='Description', description='description'),
      modificationTime: string(name='ModificationTime', description='modificationTime'),
      creationTime: string(name='CreationTime', description='creationTime'),
      coverURL: string(name='CoverURL', description='coverUrl'),
      cateId: long(name='CateId', description='cateId'),
      cateName: string(name='CateName', description='cateName'),
      downloadSwitch: string(name='DownloadSwitch', description='download'),
      templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
      preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
      storageLocation: string(name='StorageLocation', description='storageLocation'),
      regionId: string(name='RegionId', description='regionId'),
      thumbnailList: [
        {
          URL: string(name='URL', description='url'),
        }
      ](name='ThumbnailList', description='thumbnailList'),
      snapshots: [ string ](name='Snapshots', description='snapshots'),
    }
  ](name='VideoList', description='data.mediaInfoDTOS'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
}

async function getVideoInfosWithOptions(request: GetVideoInfosRequest, runtime: Util.RuntimeOptions): GetVideoInfosResponse {
  Util.validateModel(request);
  return doRequest('GetVideoInfos', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoInfos(request: GetVideoInfosRequest): GetVideoInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoInfosWithOptions(request, runtime);
}

model AssumeOssRoleRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  source: string(name='Source', description='source'),
  clientId: string(name='ClientId', description='clientId'),
  businessType: string(name='BusinessType', description='businessType'),
  terminalType: string(name='TerminalType', description='terminalType'),
  deviceModel: string(name='DeviceModel', description='deviceModel'),
  appVersion: string(name='AppVersion', description='appVersion'),
  authTimestamp: long(name='AuthTimestamp', description='authTimestamp'),
  authInfo: string(name='AuthInfo', description='authInfo'),
  prefix?: string(name='Prefix', description='prefix'),
}

model AssumeOssRoleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  ossAuthResult: string(name='OssAuthResult', description='data.ossAuthResult'),
}

async function assumeOssRoleWithOptions(request: AssumeOssRoleRequest, runtime: Util.RuntimeOptions): AssumeOssRoleResponse {
  Util.validateModel(request);
  return doRequest('AssumeOssRole', 'HTTPS', 'POST', '2017-03-14', 'Anonymous', request, null, runtime);
}

async function assumeOssRole(request: AssumeOssRoleRequest): AssumeOssRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return assumeOssRoleWithOptions(request, runtime);
}

model UpdateVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  sources?: string(name='Sources', description='sources'),
  resourceGroupId?: string(name='ResourceGroupId', description='resourceGroupId'),
  topLevelDomain?: string(name='TopLevelDomain', description='topLevelDomain'),
}

model UpdateVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateVodDomainWithOptions(request: UpdateVodDomainRequest, runtime: Util.RuntimeOptions): UpdateVodDomainResponse {
  Util.validateModel(request);
  return doRequest('UpdateVodDomain', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateVodDomain(request: UpdateVodDomainRequest): UpdateVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVodDomainWithOptions(request, runtime);
}

model StopVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
}

model StopVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function stopVodDomainWithOptions(request: StopVodDomainRequest, runtime: Util.RuntimeOptions): StopVodDomainResponse {
  Util.validateModel(request);
  return doRequest('StopVodDomain', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function stopVodDomain(request: StopVodDomainRequest): StopVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopVodDomainWithOptions(request, runtime);
}

model StartVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
}

model StartVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function startVodDomainWithOptions(request: StartVodDomainRequest, runtime: Util.RuntimeOptions): StartVodDomainResponse {
  Util.validateModel(request);
  return doRequest('StartVodDomain', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function startVodDomain(request: StartVodDomainRequest): StartVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVodDomainWithOptions(request, runtime);
}

model SetVodDomainCertificateRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  certName?: string(name='CertName', description='certName'),
  SSLProtocol: string(name='SSLProtocol', description='sslProtocol'),
  SSLPub?: string(name='SSLPub', description='sslPub'),
  SSLPri?: string(name='SSLPri', description='sslPri'),
  region?: string(name='Region', description='region'),
}

model SetVodDomainCertificateResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setVodDomainCertificateWithOptions(request: SetVodDomainCertificateRequest, runtime: Util.RuntimeOptions): SetVodDomainCertificateResponse {
  Util.validateModel(request);
  return doRequest('SetVodDomainCertificate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setVodDomainCertificate(request: SetVodDomainCertificateRequest): SetVodDomainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setVodDomainCertificateWithOptions(request, runtime);
}

model RefreshVodObjectCachesRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  objectPath: string(name='ObjectPath', description='objectPath'),
  objectType?: string(name='ObjectType', description='objectType'),
}

model RefreshVodObjectCachesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  refreshTaskId: string(name='RefreshTaskId', description='data'),
}

async function refreshVodObjectCachesWithOptions(request: RefreshVodObjectCachesRequest, runtime: Util.RuntimeOptions): RefreshVodObjectCachesResponse {
  Util.validateModel(request);
  return doRequest('RefreshVodObjectCaches', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function refreshVodObjectCaches(request: RefreshVodObjectCachesRequest): RefreshVodObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshVodObjectCachesWithOptions(request, runtime);
}

model PreloadVodObjectCachesRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  objectPath: string(name='ObjectPath', description='objectPath'),
}

model PreloadVodObjectCachesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  preloadTaskId: string(name='PreloadTaskId', description='data'),
}

async function preloadVodObjectCachesWithOptions(request: PreloadVodObjectCachesRequest, runtime: Util.RuntimeOptions): PreloadVodObjectCachesResponse {
  Util.validateModel(request);
  return doRequest('PreloadVodObjectCaches', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function preloadVodObjectCaches(request: PreloadVodObjectCachesRequest): PreloadVodObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return preloadVodObjectCachesWithOptions(request, runtime);
}

model DescribeVodUserResourcePackageRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
}

model DescribeVodUserResourcePackageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  resourcePackageInfos: {
    resourcePackageInfo: [
      {
        currCapacity: string(name='CurrCapacity', description='currCapacity'),
        initCapacity: string(name='InitCapacity', description='initCapacity'),
        commodityCode: string(name='CommodityCode', description='commodityCode'),
        displayName: string(name='DisplayName', description='displayName'),
        instanceId: string(name='InstanceId', description='instanceName'),
        status: string(name='Status', description='status'),
      }
    ](name='ResourcePackageInfo', description='ResourcePackageInfo'),
  }(name='ResourcePackageInfos', description='data'),
}

async function describeVodUserResourcePackageWithOptions(request: DescribeVodUserResourcePackageRequest, runtime: Util.RuntimeOptions): DescribeVodUserResourcePackageResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodUserResourcePackage', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodUserResourcePackage(request: DescribeVodUserResourcePackageRequest): DescribeVodUserResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodUserResourcePackageWithOptions(request, runtime);
}

model DescribeVodUserQuotaRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
}

model DescribeVodUserQuotaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainQuota: integer(name='DomainQuota', description='data.maxDomainNum'),
  refreshUrlQuota: integer(name='RefreshUrlQuota', description='data.maxUrlTaskNum'),
  refreshDirQuota: integer(name='RefreshDirQuota', description='data.maxPathTaskNum'),
  refreshUrlRemain: integer(name='RefreshUrlRemain', description='data.leftUrlTaskNum'),
  refreshDirRemain: integer(name='RefreshDirRemain', description='data.leftPathTaskNum'),
  preloadQuota: integer(name='PreloadQuota', description='data.maxPreloadTaskNum'),
  preloadRemain: integer(name='PreloadRemain', description='data.leftPreloadTaskNum'),
  blockQuota: integer(name='BlockQuota', description='data.maxBlockTaskNum'),
  blockRemain: integer(name='BlockRemain', description='data.leftBlockTaskNum'),
}

async function describeVodUserQuotaWithOptions(request: DescribeVodUserQuotaRequest, runtime: Util.RuntimeOptions): DescribeVodUserQuotaResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodUserQuota', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodUserQuota(request: DescribeVodUserQuotaRequest): DescribeVodUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodUserQuotaWithOptions(request, runtime);
}

model DescribeVodUserDomainsRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  domainName?: string(name='DomainName', description='domainName'),
  domainStatus?: string(name='DomainStatus', description='domainStatus'),
  domainSearchType?: string(name='DomainSearchType', description='domainSearchType'),
  cdnType?: string(name='CdnType', description='webSiteType'),
  checkDomainShow?: boolean(name='CheckDomainShow', description='checkDomainShow'),
  resourceGroupId?: string(name='ResourceGroupId', description='resourceGroupId'),
  funcId?: string(name='FuncId', description='funcId'),
  funcFilter?: string(name='FuncFilter', description='funcFilter'),
}

model DescribeVodUserDomainsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: long(name='PageNumber', description='data.pageNumber'),
  pageSize: long(name='PageSize', description='data.pageSize'),
  totalCount: long(name='TotalCount', description='data.totalCount'),
  domains: {
    pageData: [
      {
        domainName: string(name='DomainName', description='model.domainNameReal'),
        cname: string(name='Cname', description='model.cname'),
        cdnType: string(name='CdnType', description='websiteTypeStr'),
        domainStatus: string(name='DomainStatus', description='domainStatusStr'),
        gmtCreated: string(name='GmtCreated', description='gmtCreatedStr'),
        gmtModified: string(name='GmtModified', description='gmtModifiedStr'),
        description: string(name='Description', description='model.remark'),
        sslProtocol: string(name='SslProtocol', description='sslProtocol'),
        weight: string(name='Weight', description='weight'),
        resourceGroupId: string(name='ResourceGroupId', description='model.resourceGroupId'),
        sandbox: string(name='Sandbox', description='model.sandbox'),
        sources: {
          source: [
            {
              type: string(name='Type', description='type'),
              content: string(name='Content', description='content'),
              port: integer(name='Port', description='port'),
              priority: string(name='Priority', description='priority'),
            }
          ](name='Source', description='Source'),
        }(name='Sources', description='sources'),
      }
    ](name='PageData', description='PageData'),
  }(name='Domains', description='data.data'),
}

async function describeVodUserDomainsWithOptions(request: DescribeVodUserDomainsRequest, runtime: Util.RuntimeOptions): DescribeVodUserDomainsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodUserDomains', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodUserDomains(request: DescribeVodUserDomainsRequest): DescribeVodUserDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodUserDomainsWithOptions(request, runtime);
}

model DescribeVodServiceRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
}

model DescribeVodServiceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  instanceId: string(name='InstanceId', description='data.instanceId'),
  internetChargeType: string(name='InternetChargeType', description='data.internetChargeType'),
  openingTime: string(name='OpeningTime', description='data.openingTime'),
  changingChargeType: string(name='ChangingChargeType', description='data.changingChargeType'),
  changingAffectTime: string(name='ChangingAffectTime', description='data.changingAfterTime'),
  operationLocks: {
    lockReason: [
      {
        lockReason: string(name='LockReason', description='lockReason'),
      }
    ](name='LockReason', description='LockReason'),
  }(name='OperationLocks', description='data.operationLocks'),
}

async function describeVodServiceWithOptions(request: DescribeVodServiceRequest, runtime: Util.RuntimeOptions): DescribeVodServiceResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodService', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodService(request: DescribeVodServiceRequest): DescribeVodServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodServiceWithOptions(request, runtime);
}

model DescribeVodRefreshTasksRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  taskId?: string(name='TaskId', description='taskId'),
  objectPath?: string(name='ObjectPath', description='content'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  objectType?: string(name='ObjectType', description='taskType'),
  domainName?: string(name='DomainName', description='domainName'),
  status?: string(name='Status', description='taskStatusStr'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  resourceGroupId?: string(name='ResourceGroupId', description='resourceGroupId'),
}

model DescribeVodRefreshTasksResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageNumber: long(name='PageNumber', description='data.pageNumber'),
  pageSize: long(name='PageSize', description='data.pageSize'),
  totalCount: long(name='TotalCount', description='data.totalCount'),
  tasks: {
    task: [
      {
        taskId: string(name='TaskId', description='taskIdStr'),
        objectPath: string(name='ObjectPath', description='model.content'),
        process: string(name='Process', description='model.process'),
        status: string(name='Status', description='statusStr'),
        creationTime: string(name='CreationTime', description='model.gmtCreatedStr'),
        description: string(name='Description', description='model.description'),
        objectType: string(name='ObjectType', description='model.taskType'),
      }
    ](name='Task', description='Task'),
  }(name='Tasks', description='data.data'),
}

async function describeVodRefreshTasksWithOptions(request: DescribeVodRefreshTasksRequest, runtime: Util.RuntimeOptions): DescribeVodRefreshTasksResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodRefreshTasks', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodRefreshTasks(request: DescribeVodRefreshTasksRequest): DescribeVodRefreshTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodRefreshTasksWithOptions(request, runtime);
}

model DescribeVodRefreshQuotaRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
}

model DescribeVodRefreshQuotaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  urlQuota: string(name='UrlQuota', description='data.urlQuota'),
  dirQuota: string(name='DirQuota', description='data.dirQuota'),
  urlRemain: string(name='UrlRemain', description='data.urlRemain'),
  dirRemain: string(name='DirRemain', description='data.dirRemain'),
  preloadQuota: string(name='PreloadQuota', description='data.preloadQuota'),
  blockQuota: string(name='BlockQuota', description='data.blockQuota'),
  preloadRemain: string(name='PreloadRemain', description='data.preloadRemain'),
  blockRemain: string(name='blockRemain', description='data.blockRemain'),
}

async function describeVodRefreshQuotaWithOptions(request: DescribeVodRefreshQuotaRequest, runtime: Util.RuntimeOptions): DescribeVodRefreshQuotaResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodRefreshQuota', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodRefreshQuota(request: DescribeVodRefreshQuotaRequest): DescribeVodRefreshQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodRefreshQuotaWithOptions(request, runtime);
}

model DescribeVodDomainDetailRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
}

model DescribeVodDomainDetailResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainDetail: {
    gmtCreated: string(name='GmtCreated', description='gmtCreated'),
    gmtModified: string(name='GmtModified', description='gmtModified'),
    domainStatus: string(name='DomainStatus', description='domainStatus'),
    cname: string(name='Cname', description='cname'),
    domainName: string(name='DomainName', description='domainName'),
    description: string(name='Description', description='remark'),
    SSLProtocol: string(name='SSLProtocol', description='sslProtocol'),
    SSLPub: string(name='SSLPub', description='sslPub'),
    scope: string(name='Scope', description='scope'),
    certName: string(name='CertName', description='certName'),
    resourceGroupId: string(name='ResourceGroupId', description='resourceGroupId'),
    weight: string(name='Weight', description='weight'),
    sources: {
      source: [
        {
          content: string(name='Content', description='content'),
          type: string(name='Type', description='type'),
          port: integer(name='Port', description='port'),
          enabled: string(name='Enabled', description='enabled'),
          priority: string(name='Priority', description='priority'),
        }
      ](name='Source', description='Source'),
    }(name='Sources', description='sources'),
  }(name='DomainDetail', description='data'),
}

async function describeVodDomainDetailWithOptions(request: DescribeVodDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeVodDomainDetailResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainDetail', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainDetail(request: DescribeVodDomainDetailRequest): DescribeVodDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainDetailWithOptions(request, runtime);
}

model DescribeVodDomainConfigsRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  functionNames: string(name='FunctionNames', description='functionNames'),
}

model DescribeVodDomainConfigsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainConfigs: {
    domainConfig: [
      {
        functionName: string(name='FunctionName', description='functionName'),
        configId: string(name='ConfigId', description='configId'),
        status: string(name='Status', description='status'),
        functionArgs: {
          functionArg: [
            {
              argName: string(name='ArgName', description='argName'),
              argValue: string(name='ArgValue', description='argValue'),
            }
          ](name='FunctionArg', description='FunctionArg'),
        }(name='FunctionArgs', description='functionArgs'),
      }
    ](name='DomainConfig', description='DomainConfig'),
  }(name='DomainConfigs', description='data'),
}

async function describeVodDomainConfigsWithOptions(request: DescribeVodDomainConfigsRequest, runtime: Util.RuntimeOptions): DescribeVodDomainConfigsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainConfigs', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainConfigs(request: DescribeVodDomainConfigsRequest): DescribeVodDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainConfigsWithOptions(request, runtime);
}

model DescribeVodCertificateListRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName?: string(name='DomainName', description='domainName'),
}

model DescribeVodCertificateListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  certificateListModel: {
    count: integer(name='Count', description='count'),
    certList: {
      cert: [
        {
          certName: string(name='CertName', description='name'),
          certId: long(name='CertId', description='id'),
          fingerprint: string(name='Fingerprint', description='fingerprint'),
          common: string(name='Common', description='common'),
          issuer: string(name='Issuer', description='issuer'),
          lastTime: long(name='LastTime', description='lastTime'),
        }
      ](name='Cert', description='Cert'),
    }(name='CertList', description='certList'),
  }(name='CertificateListModel', description='data'),
}

async function describeVodCertificateListWithOptions(request: DescribeVodCertificateListRequest, runtime: Util.RuntimeOptions): DescribeVodCertificateListResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodCertificateList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodCertificateList(request: DescribeVodCertificateListRequest): DescribeVodCertificateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodCertificateListWithOptions(request, runtime);
}

model DescribeUserVodStatusRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
}

model DescribeUserVodStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  enabled: boolean(name='Enabled', description='data.enabled'),
  onService: boolean(name='OnService', description='data.onService'),
  inDebt: boolean(name='InDebt', description='data.inDebt'),
  inDebtOverdue: boolean(name='InDebtOverdue', description='data.inDebtOverdue'),
}

async function describeUserVodStatusWithOptions(request: DescribeUserVodStatusRequest, runtime: Util.RuntimeOptions): DescribeUserVodStatusResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserVodStatus', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserVodStatus(request: DescribeUserVodStatusRequest): DescribeUserVodStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserVodStatusWithOptions(request, runtime);
}

model DeleteVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  resourceGroupId?: string(name='ResourceGroupId', description='resourceGroupId'),
}

model DeleteVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteVodDomainWithOptions(request: DeleteVodDomainRequest, runtime: Util.RuntimeOptions): DeleteVodDomainResponse {
  Util.validateModel(request);
  return doRequest('DeleteVodDomain', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteVodDomain(request: DeleteVodDomainRequest): DeleteVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVodDomainWithOptions(request, runtime);
}

model AddVodDomainRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  domainName: string(name='DomainName', description='domainName'),
  sources: string(name='Sources', description='sources'),
  checkUrl?: string(name='CheckUrl', description='checkUrl'),
  scope?: string(name='Scope', description='scope'),
}

model AddVodDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addVodDomainWithOptions(request: AddVodDomainRequest, runtime: Util.RuntimeOptions): AddVodDomainResponse {
  Util.validateModel(request);
  return doRequest('AddVodDomain', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addVodDomain(request: AddVodDomainRequest): AddVodDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVodDomainWithOptions(request, runtime);
}

model DescribeVodDomainLogRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
  pageSize?: long(name='PageSize', description='pageSize'),
  pageNumber?: long(name='PageNumber', description='pageIndex'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model DescribeVodDomainLogResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainLogDetails: {
    domainLogDetail: [
      {
        domainName: string(name='DomainName', description='domainName'),
        logCount: long(name='LogCount', description='logCount'),
        logInfos: {
          logInfoDetail: [
            {
              logName: string(name='LogName', description='logName'),
              logPath: string(name='LogPath', description='logPath'),
              logSize: long(name='LogSize', description='logSize'),
              startTime: string(name='StartTime', description='logDate'),
              endTime: string(name='EndTime', description='logEndDate'),
            }
          ](name='LogInfoDetail', description='LogInfoDetail'),
        }(name='LogInfos', description='logInfo'),
        pageInfos: {
          pageNumber: long(name='PageNumber', description='pageIndex'),
          pageSize: long(name='PageSize', description='pageSize'),
          total: long(name='Total', description='total'),
        }(name='PageInfos', description='pageInfo'),
      }
    ](name='DomainLogDetail', description='DomainLogDetail'),
  }(name='DomainLogDetails', description='data.content'),
}

async function describeVodDomainLogWithOptions(request: DescribeVodDomainLogRequest, runtime: Util.RuntimeOptions): DescribeVodDomainLogResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainLog', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainLog(request: DescribeVodDomainLogRequest): DescribeVodDomainLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainLogWithOptions(request, runtime);
}

model DescribeVodDomainCnameRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domainName'),
}

model DescribeVodDomainCnameResponse = {
  requestId: string(name='RequestId', description='requestId'),
  cnameDatas: {
    data: [
      {
        domain: string(name='Domain', description='domain'),
        cname: string(name='Cname', description='cname'),
        status: integer(name='Status', description='status'),
      }
    ](name='Data', description='Data'),
  }(name='CnameDatas', description='data.content'),
}

async function describeVodDomainCnameWithOptions(request: DescribeVodDomainCnameRequest, runtime: Util.RuntimeOptions): DescribeVodDomainCnameResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainCname', 'HTTPS', 'GET', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainCname(request: DescribeVodDomainCnameRequest): DescribeVodDomainCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainCnameWithOptions(request, runtime);
}

model DescribeVodDomainCertificateInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  domainName: string(name='DomainName', description='domain'),
}

model DescribeVodDomainCertificateInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  certInfos: {
    certInfo: [
      {
        domainName: string(name='DomainName', description='domain'),
        certName: string(name='CertName', description='cert_name'),
        certDomainName: string(name='CertDomainName', description='cert_domain'),
        certExpireTime: string(name='CertExpireTime', description='cert_expire_time'),
        certLife: string(name='CertLife', description='cert_life'),
        certOrg: string(name='CertOrg', description='cert_org'),
        certType: string(name='CertType', description='cert_type'),
        serverCertificateStatus: string(name='ServerCertificateStatus', description='https'),
        status: string(name='Status', description='status'),
      }
    ](name='CertInfo', description='CertInfo'),
  }(name='CertInfos', description='data.content'),
}

async function describeVodDomainCertificateInfoWithOptions(request: DescribeVodDomainCertificateInfoRequest, runtime: Util.RuntimeOptions): DescribeVodDomainCertificateInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeVodDomainCertificateInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeVodDomainCertificateInfo(request: DescribeVodDomainCertificateInfoRequest): DescribeVodDomainCertificateInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVodDomainCertificateInfoWithOptions(request, runtime);
}

model UploadMediaByURLRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  uploadURLs: string(name='UploadURLs', description='uploadURLs'),
  templateGroupId?: string(name='TemplateGroupId', description='templateGroupId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  uploadMetadatas?: string(name='UploadMetadatas', description='uploadMetadatas'),
  priority?: string(name='Priority', description='priority'),
  messageCallback?: string(name='MessageCallback', description='messageCallback'),
}

model UploadMediaByURLResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadJobs: {
    uploadJob: [
      {
        jobId: string(name='JobId', description='jobId'),
        sourceURL: string(name='SourceURL', description='sourceUrl'),
      }
    ](name='UploadJob', description='UploadJob'),
  }(name='UploadJobs', description='data.uploadJobs'),
}

async function uploadMediaByURLWithOptions(request: UploadMediaByURLRequest, runtime: Util.RuntimeOptions): UploadMediaByURLResponse {
  Util.validateModel(request);
  return doRequest('UploadMediaByURL', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function uploadMediaByURL(request: UploadMediaByURLRequest): UploadMediaByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMediaByURLWithOptions(request, runtime);
}

model GetAIServiceRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  types: string(name='Types', description='types'),
}

model GetAIServiceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIList: [
    {
      type: string(name='Type', description='type'),
      status: string(name='Status', description='status'),
    }
  ](name='AIList', description='data.aiList'),
}

async function getAIServiceWithOptions(request: GetAIServiceRequest, runtime: Util.RuntimeOptions): GetAIServiceResponse {
  Util.validateModel(request);
  return doRequest('GetAIService', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAIService(request: GetAIServiceRequest): GetAIServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAIServiceWithOptions(request, runtime);
}

model SetAIServiceRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  operation: string(name='Operation', description='operation'),
  types: string(name='Types', description='types'),
}

model SetAIServiceResponse = {
  requestId: string(name='RequestId', description='requestId'),
  successTypes: string(name='SuccessTypes', description='data.successTypes'),
  failedTypes: string(name='FailedTypes', description='data.failedTypes'),
}

async function setAIServiceWithOptions(request: SetAIServiceRequest, runtime: Util.RuntimeOptions): SetAIServiceResponse {
  Util.validateModel(request);
  return doRequest('SetAIService', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setAIService(request: SetAIServiceRequest): SetAIServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAIServiceWithOptions(request, runtime);
}

model SetL2OssKeyConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  domainName: string(name='DomainName', description='domainName'),
  privateOssAuth: string(name='PrivateOssAuth', description='privateOssAuth'),
}

model SetL2OssKeyConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setL2OssKeyConfigWithOptions(request: SetL2OssKeyConfigRequest, runtime: Util.RuntimeOptions): SetL2OssKeyConfigResponse {
  Util.validateModel(request);
  return doRequest('SetL2OssKeyConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setL2OssKeyConfig(request: SetL2OssKeyConfigRequest): SetL2OssKeyConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setL2OssKeyConfigWithOptions(request, runtime);
}

model SetDefaultUploadStorageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  storageLocation: string(name='StorageLocation', description='storageLocation'),
}

model SetDefaultUploadStorageResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setDefaultUploadStorageWithOptions(request: SetDefaultUploadStorageRequest, runtime: Util.RuntimeOptions): SetDefaultUploadStorageResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultUploadStorage', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setDefaultUploadStorage(request: SetDefaultUploadStorageRequest): SetDefaultUploadStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultUploadStorageWithOptions(request, runtime);
}

model SearchMediaRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  searchType?: string(name='SearchType', description='searchType'),
  fields?: string(name='Fields', description='fields'),
  match?: string(name='Match', description='match'),
  sortBy?: string(name='SortBy', description='sortBy'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  scrollToken?: string(name='ScrollToken', description='scrollToken'),
  resultTypes?: string(name='ResultTypes', description='resultTypes'),
  sessionId?: string(name='SessionId', description='sessionId'),
}

model SearchMediaResponse = {
  requestId: string(name='RequestId', description='requestId'),
  scrollToken: string(name='ScrollToken', description='data.scrollToken'),
  total: long(name='Total', description='data.total'),
  mediaList: [
    {
      mediaType: string(name='MediaType', description='mediaType'),
      creationTime: string(name='CreationTime', description='creationTime'),
      mediaId: string(name='MediaId', description='mediaId'),
      video: {
        videoId: string(name='VideoId', description='mediaId'),
        mediaSource: string(name='MediaSource', description='source'),
        mediaType: string(name='MediaType', description='type'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        downloadSwitch: string(name='DownloadSwitch', description='download'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
        auditStatus: string(name='AuditStatus', description='auditStatus'),
        auditAIStatus: string(name='AuditAIStatus', description='auditAIStatus'),
        auditManualStatus: string(name='AuditManualStatus', description='auditManualStatus'),
        auditAIResult: string(name='AuditAIResult', description='auditAIResult'),
        auditTemplateId: string(name='AuditTemplateId', description='auditTemplateId'),
        customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
        playInfoList: [
          {
            width: long(name='Width', description='width'),
            height: long(name='Height', description='height'),
            size: long(name='Size', description='size'),
            playURL: string(name='PlayURL', description='playURL'),
            bitrate: string(name='Bitrate', description='bitrate'),
            definition: string(name='Definition', description='definition'),
            duration: string(name='Duration', description='duration'),
            format: string(name='Format', description='format'),
            fps: string(name='Fps', description='fps'),
            encrypt: long(name='Encrypt', description='encrypt'),
            plaintext: string(name='Plaintext', description='plaintext'),
            complexity: string(name='Complexity', description='complexity'),
            streamType: string(name='StreamType', description='streamType'),
            rand: string(name='Rand', description='rand'),
            jobId: string(name='JobId', description='jobId'),
          }
        ](name='PlayInfoList', description='playInfoList'),
        snapshots: [ string ](name='Snapshots', description='snapshots'),
        spriteSnapshots: [ string ](name='SpriteSnapshots', description='spriteImages'),
      }(name='Video', description='video'),
      audio: {
        audioId: string(name='AudioId', description='mediaId'),
        mediaSource: string(name='MediaSource', description='source'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        downloadSwitch: string(name='DownloadSwitch', description='download'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
        auditStatus: string(name='AuditStatus', description='auditStatus'),
        auditAIStatus: string(name='AuditAIStatus', description='auditAIStatus'),
        auditManualStatus: string(name='AuditManualStatus', description='auditManualStatus'),
        auditAIResult: string(name='AuditAIResult', description='auditAIResult'),
        auditTemplateId: string(name='AuditTemplateId', description='auditTemplateId'),
        customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
        playInfoList: [
          {
            width: long(name='Width', description='width'),
            height: long(name='Height', description='height'),
            size: long(name='Size', description='size'),
            playURL: string(name='PlayURL', description='playURL'),
            bitrate: string(name='Bitrate', description='bitrate'),
            definition: string(name='Definition', description='definition'),
            duration: string(name='Duration', description='duration'),
            format: string(name='Format', description='format'),
            fps: string(name='Fps', description='fps'),
            encrypt: long(name='Encrypt', description='encrypt'),
            plaintext: string(name='Plaintext', description='plaintext'),
            complexity: string(name='Complexity', description='complexity'),
            streamType: string(name='StreamType', description='streamType'),
            rand: string(name='Rand', description='rand'),
            jobId: string(name='JobId', description='jobId'),
          }
        ](name='PlayInfoList', description='playInfoList'),
        snapshots: [ string ](name='Snapshots', description='snapshots'),
        spriteSnapshots: [ string ](name='SpriteSnapshots', description='spriteImages'),
      }(name='Audio', description='audio'),
      image: {
        title: string(name='Title', description='title'),
        imageId: string(name='ImageId', description='imageId'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        ext: string(name='Ext', description='ext'),
        creationTime: string(name='CreationTime', description='ct'),
        modificationTime: string(name='ModificationTime', description='mt'),
        tags: string(name='Tags', description='tags'),
        type: string(name='Type', description='type'),
        URL: string(name='URL', description='url'),
        status: string(name='Status', description='status'),
        description: string(name='Description', description='desc'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
      }(name='Image', description='image'),
    }
  ](name='MediaList', description='data.mediaDTOList'),
}

async function searchMediaWithOptions(request: SearchMediaRequest, runtime: Util.RuntimeOptions): SearchMediaResponse {
  Util.validateModel(request);
  return doRequest('SearchMedia', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWithOptions(request, runtime);
}

model UpdateVideoInfosRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  updateContent: string(name='UpdateContent', description='updateContent'),
}

model UpdateVideoInfosResponse = {
  requestId: string(name='RequestId', description='requestId'),
  nonExistVideoIds: [ string ] (name='NonExistVideoIds', description='data.nonExistVideoIds'),
}

async function updateVideoInfosWithOptions(request: UpdateVideoInfosRequest, runtime: Util.RuntimeOptions): UpdateVideoInfosResponse {
  Util.validateModel(request);
  return doRequest('UpdateVideoInfos', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateVideoInfos(request: UpdateVideoInfosRequest): UpdateVideoInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVideoInfosWithOptions(request, runtime);
}

model GenerateDownloadSecretKeyRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  appIdentification: string(name='AppIdentification', description='appIdentification'),
  appDecryptKey: string(name='AppDecryptKey', description='appDecryptKey'),
}

model GenerateDownloadSecretKeyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  appEncryptKey: string(name='AppEncryptKey', description='data.appEncryptKey'),
}

async function generateDownloadSecretKeyWithOptions(request: GenerateDownloadSecretKeyRequest, runtime: Util.RuntimeOptions): GenerateDownloadSecretKeyResponse {
  Util.validateModel(request);
  return doRequest('GenerateDownloadSecretKey', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function generateDownloadSecretKey(request: GenerateDownloadSecretKeyRequest): GenerateDownloadSecretKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDownloadSecretKeyWithOptions(request, runtime);
}

model AssumeSlsRoleRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  clientId: string(name='ClientId', description='clientId'),
  businessType: string(name='BusinessType', description='businessType'),
  terminalType: string(name='TerminalType', description='terminalType'),
  deviceModel: string(name='DeviceModel', description='deviceModel'),
  appVersion: string(name='AppVersion', description='appVersion'),
  authTimestamp: long(name='AuthTimestamp', description='authTimestamp'),
  authInfo: string(name='AuthInfo', description='authInfo'),
}

model AssumeSlsRoleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  slsAuthResult: string(name='SlsAuthResult', description='data.slsAuthResult'),
}

async function assumeSlsRoleWithOptions(request: AssumeSlsRoleRequest, runtime: Util.RuntimeOptions): AssumeSlsRoleResponse {
  Util.validateModel(request);
  return doRequest('AssumeSlsRole', 'HTTPS', 'POST', '2017-03-14', 'Anonymous', request, null, runtime);
}

async function assumeSlsRole(request: AssumeSlsRoleRequest): AssumeSlsRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return assumeSlsRoleWithOptions(request, runtime);
}

model GetPersonalStorageListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  storageRegion?: string(name='StorageRegion', description='storageRegion'),
  prefix?: string(name='Prefix', description='prefix'),
  maxKeys?: string(name='MaxKeys', description='maxKeys'),
}

model GetPersonalStorageListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  storageInfoList: {
    storageInfo: [
      {
        location: string(name='Location', description='location'),
        gmtCreate: string(name='GmtCreate', description='gmtCreate'),
        ownerId: long(name='OwnerId', description='ownerId'),
        storageClass: string(name='StorageClass', description='storageClass'),
        extranetEndpoint: string(name='ExtranetEndpoint', description='extranetEndpoint'),
        intranetEndpoint: string(name='IntranetEndpoint', description='intranetEndpoint'),
        storageACL: string(name='StorageACL', description='storageACL'),
      }
    ](name='StorageInfo', description='StorageInfo'),
  }(name='StorageInfoList', description='data.storageInfoList'),
}

async function getPersonalStorageListWithOptions(request: GetPersonalStorageListRequest, runtime: Util.RuntimeOptions): GetPersonalStorageListResponse {
  Util.validateModel(request);
  return doRequest('GetPersonalStorageList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getPersonalStorageList(request: GetPersonalStorageListRequest): GetPersonalStorageListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPersonalStorageListWithOptions(request, runtime);
}

model GetStorageRegionListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetStorageRegionListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  regionList: {
    region: [
      {
        regionID: string(name='RegionID', description='regionID'),
      }
    ](name='Region', description='Region'),
  }(name='RegionList', description='data.regionList'),
}

async function getStorageRegionListWithOptions(request: GetStorageRegionListRequest, runtime: Util.RuntimeOptions): GetStorageRegionListResponse {
  Util.validateModel(request);
  return doRequest('GetStorageRegionList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getStorageRegionList(request: GetStorageRegionListRequest): GetStorageRegionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStorageRegionListWithOptions(request, runtime);
}

model SetStorageACLRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  storageLocation: string(name='StorageLocation', description='storageLocation'),
  storageACL: string(name='StorageACL', description='storageACL'),
}

model SetStorageACLResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setStorageACLWithOptions(request: SetStorageACLRequest, runtime: Util.RuntimeOptions): SetStorageACLResponse {
  Util.validateModel(request);
  return doRequest('SetStorageACL', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setStorageACL(request: SetStorageACLRequest): SetStorageACLResponse {
  var runtime = new Util.RuntimeOptions{};
  return setStorageACLWithOptions(request, runtime);
}

model GetMessageCallbackEventListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetMessageCallbackEventListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  eventList: string(name='EventList', description='data.eventList'),
}

async function getMessageCallbackEventListWithOptions(request: GetMessageCallbackEventListRequest, runtime: Util.RuntimeOptions): GetMessageCallbackEventListResponse {
  Util.validateModel(request);
  return doRequest('GetMessageCallbackEventList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMessageCallbackEventList(request: GetMessageCallbackEventListRequest): GetMessageCallbackEventListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMessageCallbackEventListWithOptions(request, runtime);
}

model GetStorageInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
}

model GetStorageInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  storageACL: string(name='StorageACL', description='data.storageACL'),
  domainInfoList: {
    domainInfo: [
      {
        domainName: string(name='DomainName', description='domainName'),
        domainStatus: string(name='DomainStatus', description='domainStatus'),
        domainCname: string(name='DomainCname', description='domainCname'),
        defaultPlay: boolean(name='DefaultPlay', description='defaultPlay'),
      }
    ](name='DomainInfo', description='DomainInfo'),
  }(name='DomainInfoList', description='data.domainDTOList'),
  storage: {
    gmtCreate: string(name='GmtCreate', description='utcCreate'),
    gmtModified: string(name='GmtModified', description='utcModified'),
    groupId: string(name='GroupId', description='groupId'),
    location: string(name='Location', description='location'),
    type: integer(name='Type', description='type'),
    region: string(name='Region', description='region'),
    status: integer(name='Status', description='status'),
    storageUsage: integer(name='StorageUsage', description='storageUsage'),
    defaultUpload: boolean(name='DefaultUpload', description='defaultUpload'),
  }(name='Storage', description='data.storage'),
}

async function getStorageInfoWithOptions(request: GetStorageInfoRequest, runtime: Util.RuntimeOptions): GetStorageInfoResponse {
  Util.validateModel(request);
  return doRequest('GetStorageInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getStorageInfo(request: GetStorageInfoRequest): GetStorageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStorageInfoWithOptions(request, runtime);
}

model DeleteStorageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  storageLocation: string(name='StorageLocation', description='storageLocation'),
}

model DeleteStorageResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteStorageWithOptions(request: DeleteStorageRequest, runtime: Util.RuntimeOptions): DeleteStorageResponse {
  Util.validateModel(request);
  return doRequest('DeleteStorage', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteStorage(request: DeleteStorageRequest): DeleteStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStorageWithOptions(request, runtime);
}

model AddStorageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  storageType: string(name='StorageType', description='storageType'),
  storageRegion: string(name='StorageRegion', description='storageRegion'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
}

model AddStorageResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addStorageWithOptions(request: AddStorageRequest, runtime: Util.RuntimeOptions): AddStorageResponse {
  Util.validateModel(request);
  return doRequest('AddStorage', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addStorage(request: AddStorageRequest): AddStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return addStorageWithOptions(request, runtime);
}

model GetStorageListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  pageNumber?: integer(name='PageNumber', description='pageNumber'),
  storageRegion?: string(name='StorageRegion', description='storageRegion'),
  storageType?: string(name='StorageType', description='storageType'),
  storageStatus?: string(name='StorageStatus', description='storageStatus'),
  division?: string(name='Division', description='division'),
}

model GetStorageListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageSize: integer(name='PageSize', description='data.pageSize'),
  pageNumber: integer(name='PageNumber', description='data.pageNumber'),
  totalCount: integer(name='TotalCount', description='data.totalCount'),
  storageList: {
    storage: [
      {
        gmtCreate: string(name='GmtCreate', description='utcCreate'),
        gmtModified: string(name='GmtModified', description='utcModified'),
        groupId: string(name='GroupId', description='groupId'),
        location: string(name='Location', description='location'),
        type: integer(name='Type', description='type'),
        region: string(name='Region', description='region'),
        status: integer(name='Status', description='status'),
        storageUsage: integer(name='StorageUsage', description='storageUsage'),
        defaultUpload: boolean(name='DefaultUpload', description='defaultUpload'),
      }
    ](name='Storage', description='Storage'),
  }(name='StorageList', description='data.storageDTOList'),
}

async function getStorageListWithOptions(request: GetStorageListRequest, runtime: Util.RuntimeOptions): GetStorageListResponse {
  Util.validateModel(request);
  return doRequest('GetStorageList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getStorageList(request: GetStorageListRequest): GetStorageListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStorageListWithOptions(request, runtime);
}

model GetThirdPartPlayPolicyRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  contentId: string(name='ContentId', description='contentId'),
  source: string(name='Source', description='source'),
  authTimestamp: long(name='AuthTimestamp', description='authTimestamp'),
  authInfo: string(name='AuthInfo', description='authInfo'),
}

model GetThirdPartPlayPolicyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  policyInfo: string(name='PolicyInfo', description='data.policyInfo'),
}

async function getThirdPartPlayPolicyWithOptions(request: GetThirdPartPlayPolicyRequest, runtime: Util.RuntimeOptions): GetThirdPartPlayPolicyResponse {
  Util.validateModel(request);
  return doRequest('GetThirdPartPlayPolicy', 'HTTPS', 'POST', '2017-03-14', 'Anonymous', request, null, runtime);
}

async function getThirdPartPlayPolicy(request: GetThirdPartPlayPolicyRequest): GetThirdPartPlayPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThirdPartPlayPolicyWithOptions(request, runtime);
}

model AddThirdPartPlayPolicyRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  policyInfoList: string(name='PolicyInfoList', description='policyInfoList'),
  source: string(name='Source', description='source'),
  authTimestamp: long(name='AuthTimestamp', description='authTimestamp'),
  authInfo: string(name='AuthInfo', description='authInfo'),
}

model AddThirdPartPlayPolicyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  count: string(name='Count', description='data.count'),
}

async function addThirdPartPlayPolicyWithOptions(request: AddThirdPartPlayPolicyRequest, runtime: Util.RuntimeOptions): AddThirdPartPlayPolicyResponse {
  Util.validateModel(request);
  return doRequest('AddThirdPartPlayPolicy', 'HTTPS', 'POST', '2017-03-14', 'Anonymous', request, null, runtime);
}

async function addThirdPartPlayPolicy(request: AddThirdPartPlayPolicyRequest): AddThirdPartPlayPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return addThirdPartPlayPolicyWithOptions(request, runtime);
}

model AuthorizeAppLicenseRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  sdkCode?: long(name='SdkCode', description='sdkCode'),
  licenseVersion: long(name='LicenseVersion', description='licenseVersion'),
  platform: long(name='Platform', description='platform'),
  bundleId?: string(name='BundleId', description='bundleId'),
  packageName?: string(name='PackageName', description='packageName'),
  licenseSignature?: string(name='LicenseSignature', description='signature'),
  nonce: string(name='Nonce', description='nonce'),
  time: long(name='Time', description='time'),
  sign: string(name='Sign', description='sign'),
  sdkVersion?: string(name='SdkVersion', description='sdkVersion'),
  sdkVersionCode?: long(name='SdkVersionCode', description='sdkVersionCode'),
}

model AuthorizeAppLicenseResponse = {
  requestId: string(name='RequestId', description='requestId'),
  expireDate: string(name='ExpireDate', description='data.expireDate'),
  sign: string(name='Sign', description='data.sign'),
  feature: string(name='Feature', description='data.feature'),
}

async function authorizeAppLicenseWithOptions(request: AuthorizeAppLicenseRequest, runtime: Util.RuntimeOptions): AuthorizeAppLicenseResponse {
  Util.validateModel(request);
  return doRequest('AuthorizeAppLicense', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function authorizeAppLicense(request: AuthorizeAppLicenseRequest): AuthorizeAppLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeAppLicenseWithOptions(request, runtime);
}

model GetAppLicenseRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  licenseId: long(name='LicenseId', description='licenseId'),
}

model GetAppLicenseResponse = {
  requestId: string(name='RequestId', description='requestId'),
  appLicense: {
    licenseId: long(name='LicenseId', description='licenseId'),
    creationTime: string(name='CreationTime', description='creationTime'),
    contractNo: string(name='ContractNo', description='contractNo'),
    appName: string(name='AppName', description='appName'),
    bundleId: string(name='BundleId', description='bundleId'),
    packageName: string(name='PackageName', description='packageName'),
    licenseSignature: string(name='LicenseSignature', description='signature'),
    type: string(name='Type', description='type'),
    feature: string(name='Feature', description='feature'),
    expiredOn: string(name='ExpiredOn', description='expiredOn'),
    status: string(name='Status', description='status'),
    sdkIds: string(name='SdkIds', description='sdkIds'),
    accountId: long(name='AccountId', description='customerId'),
    customerId: long(name='CustomerId', description='userId'),
  }(name='AppLicense', description='data.appLicenseDTO'),
}

async function getAppLicenseWithOptions(request: GetAppLicenseRequest, runtime: Util.RuntimeOptions): GetAppLicenseResponse {
  Util.validateModel(request);
  return doRequest('GetAppLicense', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAppLicense(request: GetAppLicenseRequest): GetAppLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppLicenseWithOptions(request, runtime);
}

model UpdateAppLicenseRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  licenseId: long(name='LicenseId', description='licenseId'),
  contractNo?: string(name='ContractNo', description='contractNo'),
  appName?: string(name='AppName', description='appName'),
  bundleId?: string(name='BundleId', description='bundleId'),
  packageName?: string(name='PackageName', description='packageName'),
  licenseSignature?: string(name='LicenseSignature', description='signature'),
  type?: string(name='Type', description='type'),
  feature?: string(name='Feature', description='feature'),
  status?: string(name='Status', description='status'),
  expiredOn?: string(name='ExpiredOn', description='expiredOn'),
  sdkIds?: string(name='SdkIds', description='sdkIds'),
  customerId?: long(name='CustomerId', description='customerId'),
  accountId?: long(name='AccountId', description='accountId'),
}

model UpdateAppLicenseResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateAppLicenseWithOptions(request: UpdateAppLicenseRequest, runtime: Util.RuntimeOptions): UpdateAppLicenseResponse {
  Util.validateModel(request);
  return doRequest('UpdateAppLicense', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateAppLicense(request: UpdateAppLicenseRequest): UpdateAppLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppLicenseWithOptions(request, runtime);
}

model AddAppLicenseRequest = {
  appName?: string(name='AppName', description='appName'),
  contractNo?: string(name='ContractNo', description='contractNo'),
  bundleId?: string(name='BundleId', description='bundleId'),
  packageName?: string(name='PackageName', description='packageName'),
  licenseSignature?: string(name='LicenseSignature', description='signature'),
  type: string(name='Type', description='type'),
  feature?: string(name='Feature', description='feature'),
  expiredOn: string(name='ExpiredOn', description='expiredOn'),
  sdkIds?: string(name='SdkIds', description='sdkIds'),
  customerId?: long(name='CustomerId', description='customerId'),
  accountId?: long(name='AccountId', description='accountId'),
  licenseId?: long(name='LicenseId', description='licenseId'),
  createTime?: string(name='CreateTime', description='createTime'),
  status?: string(name='Status', description='status'),
}

model AddAppLicenseResponse = {
  requestId: string(name='RequestId', description='requestId'),
  licenseId: long(name='LicenseId', description='data.licenseId'),
}

async function addAppLicenseWithOptions(request: AddAppLicenseRequest, runtime: Util.RuntimeOptions): AddAppLicenseResponse {
  Util.validateModel(request);
  return doRequest('AddAppLicense', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addAppLicense(request: AddAppLicenseRequest): AddAppLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAppLicenseWithOptions(request, runtime);
}

model GetAppLicenseListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  customerId?: long(name='CustomerId', description='customerId'),
  accountId?: long(name='AccountId', description='accountId'),
  contractNo?: string(name='ContractNo', description='contractNo'),
  appName?: string(name='AppName', description='appName'),
  bundleId?: string(name='BundleId', description='bundleId'),
  packageName?: string(name='PackageName', description='packageName'),
  type?: string(name='Type', description='type'),
  sdkIds?: string(name='SdkIds', description='sdkIds'),
  feature?: string(name='Feature', description='feature'),
  status?: string(name='Status', description='status'),
  pageNo?: long(name='PageNo', description='pageNo'),
  pageSize?: long(name='PageSize', description='pageSize'),
  startCreationTime?: string(name='StartCreationTime', description='startCreationTime'),
  endCreationTime?: string(name='EndCreationTime', description='endCreationTime'),
  startExpiredTime?: string(name='StartExpiredTime', description='startExpiredTime'),
  endExpiredTime?: string(name='EndExpiredTime', description='endExpiredTime'),
  sortBy?: string(name='SortBy', description='sortBy'),
}

model GetAppLicenseListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: long(name='Total', description='data.total'),
  appLicenseList: {
    appLicense: [
      {
        licenseId: long(name='LicenseId', description='licenseId'),
        creationTime: string(name='CreationTime', description='creationTime'),
        contractNo: string(name='ContractNo', description='contractNo'),
        appName: string(name='AppName', description='appName'),
        bundleId: string(name='BundleId', description='bundleId'),
        packageName: string(name='PackageName', description='packageName'),
        licenseSignature: string(name='LicenseSignature', description='signature'),
        type: string(name='Type', description='type'),
        feature: string(name='Feature', description='feature'),
        expiredOn: string(name='ExpiredOn', description='expiredOn'),
        status: string(name='Status', description='status'),
        sdkIds: string(name='SdkIds', description='sdkIds'),
        accountId: long(name='AccountId', description='customerId'),
        customerId: long(name='CustomerId', description='userId'),
      }
    ](name='AppLicense', description='AppLicense'),
  }(name='AppLicenseList', description='data.appLicenseDTO'),
}

async function getAppLicenseListWithOptions(request: GetAppLicenseListRequest, runtime: Util.RuntimeOptions): GetAppLicenseListResponse {
  Util.validateModel(request);
  return doRequest('GetAppLicenseList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAppLicenseList(request: GetAppLicenseListRequest): GetAppLicenseListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppLicenseListWithOptions(request, runtime);
}

model SPIPhysicalDeleteResourceActionRequest = {
  accessKeyId?: string(name='AccessKeyId', description='accessKeyId'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  pk: string(name='Pk', description='pk'),
  bid: string(name='Bid', description='bid'),
  hid: long(name='Hid', description='hid'),
  country: string(name='Country', description='country'),
  taskIdentifier: string(name='TaskIdentifier', description='taskIdentifier'),
  taskExtraData: string(name='TaskExtraData', description='taskExtraData'),
  gmtWakeup: string(name='GmtWakeup', description='gmtWakeup'),
  success?: boolean(name='Success', description='success'),
  message?: string(name='Message', description='message'),
  level?: long(name='Level', description='level'),
  url?: string(name='Url', description='url'),
  prompt?: string(name='Prompt', description='prompt'),
}

model SPIPhysicalDeleteResourceActionResponse = {
  interrupt: boolean(name='Interrupt', description='interrupt'),
  invoker: string(name='Invoker', description='invoker'),
  pk: string(name='Pk', description='pk'),
  bid: string(name='Bid', description='bid'),
  hid: long(name='Hid', description='hid'),
  country: string(name='Country', description='country'),
  taskIdentifier: string(name='TaskIdentifier', description='taskIdentifier'),
  taskExtraData: string(name='TaskExtraData', description='taskExtraData'),
  gmtWakeup: string(name='GmtWakeup', description='gmtWakeup'),
  success: boolean(name='Success', description='success'),
  message: string(name='Message', description='message'),
  level: long(name='Level', description='level'),
  url: string(name='Url', description='url'),
  prompt: string(name='Prompt', description='prompt'),
}

async function SPIPhysicalDeleteResourceActionWithOptions(request: SPIPhysicalDeleteResourceActionRequest, runtime: Util.RuntimeOptions): SPIPhysicalDeleteResourceActionResponse {
  Util.validateModel(request);
  return doRequest('SPIPhysicalDeleteResourceAction', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function SPIPhysicalDeleteResourceAction(request: SPIPhysicalDeleteResourceActionRequest): SPIPhysicalDeleteResourceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return SPIPhysicalDeleteResourceActionWithOptions(request, runtime);
}

model SPICheckResourceActionRequest = {
  accessKeyId?: string(name='AccessKeyId', description='accessKeyId'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  pk: string(name='Pk', description='pk'),
  bid: string(name='Bid', description='bid'),
  hid: long(name='Hid', description='hid'),
  country: string(name='Country', description='country'),
  taskIdentifier: string(name='TaskIdentifier', description='taskIdentifier'),
  taskExtraData: string(name='TaskExtraData', description='taskExtraData'),
  gmtWakeup: string(name='GmtWakeup', description='gmtWakeup'),
  success?: boolean(name='Success', description='success'),
  message?: string(name='Message', description='message'),
  level?: long(name='Level', description='level'),
  url?: string(name='Url', description='url'),
  prompt?: string(name='Prompt', description='prompt'),
}

model SPICheckResourceActionResponse = {
  interrupt: boolean(name='Interrupt', description='interrupt'),
  invoker: string(name='Invoker', description='invoker'),
  pk: string(name='Pk', description='pk'),
  bid: string(name='Bid', description='bid'),
  hid: long(name='Hid', description='hid'),
  country: string(name='Country', description='country'),
  taskIdentifier: string(name='TaskIdentifier', description='taskIdentifier'),
  taskExtraData: string(name='TaskExtraData', description='taskExtraData'),
  gmtWakeup: string(name='GmtWakeup', description='gmtWakeup'),
  success: boolean(name='Success', description='success'),
  message: string(name='Message', description='message'),
  level: long(name='Level', description='level'),
  url: string(name='Url', description='url'),
  prompt: string(name='Prompt', description='prompt'),
}

async function SPICheckResourceActionWithOptions(request: SPICheckResourceActionRequest, runtime: Util.RuntimeOptions): SPICheckResourceActionResponse {
  Util.validateModel(request);
  return doRequest('SPICheckResourceAction', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function SPICheckResourceAction(request: SPICheckResourceActionRequest): SPICheckResourceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return SPICheckResourceActionWithOptions(request, runtime);
}

model SPILogicalDeleteResourceActionRequest = {
  accessKeyId?: string(name='AccessKeyId', description='accessKeyId'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  securityToken?: string(name='SecurityToken', description='securityToken'),
  pk: string(name='Pk', description='pk'),
  bid: string(name='Bid', description='bid'),
  hid: long(name='Hid', description='hid'),
  country: string(name='Country', description='country'),
  taskIdentifier: string(name='TaskIdentifier', description='taskIdentifier'),
  taskExtraData: string(name='TaskExtraData', description='taskExtraData'),
  gmtWakeup: string(name='GmtWakeup', description='gmtWakeup'),
  success?: boolean(name='Success', description='success'),
  message?: string(name='Message', description='message'),
  level?: long(name='Level', description='level'),
  url?: string(name='Url', description='url'),
  prompt?: string(name='Prompt', description='prompt'),
}

model SPILogicalDeleteResourceActionResponse = {
  interrupt: boolean(name='Interrupt', description='interrupt'),
  invoker: string(name='Invoker', description='invoker'),
  pk: string(name='Pk', description='pk'),
  bid: string(name='Bid', description='bid'),
  hid: long(name='Hid', description='hid'),
  country: string(name='Country', description='country'),
  taskIdentifier: string(name='TaskIdentifier', description='taskIdentifier'),
  taskExtraData: string(name='TaskExtraData', description='taskExtraData'),
  gmtWakeup: string(name='GmtWakeup', description='gmtWakeup'),
  success: boolean(name='Success', description='success'),
  message: string(name='Message', description='message'),
  level: long(name='Level', description='level'),
  url: string(name='Url', description='url'),
  prompt: string(name='Prompt', description='prompt'),
}

async function SPILogicalDeleteResourceActionWithOptions(request: SPILogicalDeleteResourceActionRequest, runtime: Util.RuntimeOptions): SPILogicalDeleteResourceActionResponse {
  Util.validateModel(request);
  return doRequest('SPILogicalDeleteResourceAction', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function SPILogicalDeleteResourceAction(request: SPILogicalDeleteResourceActionRequest): SPILogicalDeleteResourceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return SPILogicalDeleteResourceActionWithOptions(request, runtime);
}

model SubmitPreprocessJobsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  preprocessType: string(name='PreprocessType', description='preprocessType'),
}

model SubmitPreprocessJobsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeJobs: {
    transcodeJob: [
      {
        jobId: string(name='JobId', description='jobId'),
      }
    ](name='TranscodeJob', description='TranscodeJob'),
  }(name='TranscodeJobs', description='data.transcodeJobs'),
}

async function submitPreprocessJobsWithOptions(request: SubmitPreprocessJobsRequest, runtime: Util.RuntimeOptions): SubmitPreprocessJobsResponse {
  Util.validateModel(request);
  return doRequest('SubmitPreprocessJobs', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitPreprocessJobs(request: SubmitPreprocessJobsRequest): SubmitPreprocessJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitPreprocessJobsWithOptions(request, runtime);
}

model QueryOrderParamRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  data: string(name='data', description='data'),
}

model QueryOrderParamResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
  data: string(name='data', description='data'),
}

async function queryOrderParamWithOptions(request: QueryOrderParamRequest, runtime: Util.RuntimeOptions): QueryOrderParamResponse {
  Util.validateModel(request);
  return doRequest('QueryOrderParam', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function queryOrderParam(request: QueryOrderParamRequest): QueryOrderParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrderParamWithOptions(request, runtime);
}

model AssumeExperienceRoleRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  data: string(name='Data', description='data'),
  cookie?: string(name='Cookie', description='cookie'),
}

model AssumeExperienceRoleResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: string(name='Result', description='data.result'),
}

async function assumeExperienceRoleWithOptions(request: AssumeExperienceRoleRequest, runtime: Util.RuntimeOptions): AssumeExperienceRoleResponse {
  Util.validateModel(request);
  return doRequest('AssumeExperienceRole', 'HTTPS', 'POST', '2017-03-14', 'Anonymous', request, null, runtime);
}

async function assumeExperienceRole(request: AssumeExperienceRoleRequest): AssumeExperienceRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return assumeExperienceRoleWithOptions(request, runtime);
}

model ListSnapshotsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  snapshotType?: string(name='SnapshotType', description='snapshotType'),
  authTimeout?: string(name='AuthTimeout', description='authTimeout'),
  pageSize?: string(name='PageSize', description='pageSize'),
  pageNo?: string(name='PageNo', description='pageNo'),
}

model ListSnapshotsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaSnapshot: {
    total: long(name='Total', description='total'),
    regular: string(name='Regular', description='regular'),
    creationTime: string(name='CreationTime', description='creationTime'),
    jobId: string(name='JobId', description='jobId'),
    snapshots: {
      snapshot: [
        {
          index: long(name='Index', description='index'),
          url: string(name='Url', description='url'),
        }
      ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshots'),
  }(name='MediaSnapshot', description='data.mediaSnapshot'),
}

async function listSnapshotsWithOptions(request: ListSnapshotsRequest, runtime: Util.RuntimeOptions): ListSnapshotsResponse {
  Util.validateModel(request);
  return doRequest('ListSnapshots', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listSnapshots(request: ListSnapshotsRequest): ListSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSnapshotsWithOptions(request, runtime);
}

model SetDefaultPlayDomainRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  domainName: string(name='DomainName', description='domainName'),
}

model SetDefaultPlayDomainResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setDefaultPlayDomainWithOptions(request: SetDefaultPlayDomainRequest, runtime: Util.RuntimeOptions): SetDefaultPlayDomainResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultPlayDomain', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setDefaultPlayDomain(request: SetDefaultPlayDomainRequest): SetDefaultPlayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultPlayDomainWithOptions(request, runtime);
}

model EditVideoIndexFileRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  editType: string(name='EditType', description='editType'),
  editConfig: string(name='EditConfig', description='editConfig'),
}

model EditVideoIndexFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function editVideoIndexFileWithOptions(request: EditVideoIndexFileRequest, runtime: Util.RuntimeOptions): EditVideoIndexFileResponse {
  Util.validateModel(request);
  return doRequest('EditVideoIndexFile', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function editVideoIndexFile(request: EditVideoIndexFileRequest): EditVideoIndexFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return editVideoIndexFileWithOptions(request, runtime);
}

model SetCDNDomainServerCertificateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  productCode: string(name='ProductCode', description='productCode'),
  APIProxyName: string(name='APIProxyName', description='apiProxyName'),
  APIProxyParam: string(name='APIProxyParam', description='apiProxyParam'),
}

model SetCDNDomainServerCertificateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  response: string(name='Response', description='data.response'),
}

async function setCDNDomainServerCertificateWithOptions(request: SetCDNDomainServerCertificateRequest, runtime: Util.RuntimeOptions): SetCDNDomainServerCertificateResponse {
  Util.validateModel(request);
  return doRequest('SetCDNDomainServerCertificate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setCDNDomainServerCertificate(request: SetCDNDomainServerCertificateRequest): SetCDNDomainServerCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCDNDomainServerCertificateWithOptions(request, runtime);
}

model SetCDNForceRedirectConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  productCode: string(name='ProductCode', description='productCode'),
  APIProxyName: string(name='APIProxyName', description='apiProxyName'),
  APIProxyParam: string(name='APIProxyParam', description='apiProxyParam'),
}

model SetCDNForceRedirectConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  response: string(name='Response', description='data.response'),
}

async function setCDNForceRedirectConfigWithOptions(request: SetCDNForceRedirectConfigRequest, runtime: Util.RuntimeOptions): SetCDNForceRedirectConfigResponse {
  Util.validateModel(request);
  return doRequest('SetCDNForceRedirectConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setCDNForceRedirectConfig(request: SetCDNForceRedirectConfigRequest): SetCDNForceRedirectConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCDNForceRedirectConfigWithOptions(request, runtime);
}

model SubmitTranscodeJobsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  templateGroupId: string(name='TemplateGroupId', description='groupId'),
  pipelineId?: string(name='PipelineId', description='pipelineId'),
  encryptConfig?: string(name='EncryptConfig', description='encryptConfig'),
  overrideParams?: string(name='OverrideParams', description='overrideParams'),
}

model SubmitTranscodeJobsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeJobs: {
    transcodeJob: [
      {
        jobId: string(name='JobId', description='jobId'),
      }
    ](name='TranscodeJob', description='TranscodeJob'),
  }(name='TranscodeJobs', description='data.transcodeJobs'),
}

async function submitTranscodeJobsWithOptions(request: SubmitTranscodeJobsRequest, runtime: Util.RuntimeOptions): SubmitTranscodeJobsResponse {
  Util.validateModel(request);
  return doRequest('SubmitTranscodeJobs', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitTranscodeJobs(request: SubmitTranscodeJobsRequest): SubmitTranscodeJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTranscodeJobsWithOptions(request, runtime);
}

model GetAuditResultRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  videoId: string(name='VideoId', description='videoId'),
}

model GetAuditResultResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIAuditResult: {
    abnormalModules: string(name='AbnormalModules', description='abnormalModules'),
    label: string(name='Label', description='label'),
    pornResult: string(name='PornResult', description='pornResult'),
    terrorismResult: string(name='TerrorismResult', description='terrorismResult'),
    titleResult: string(name='TitleResult', description='titleResult'),
    coverResult: string(name='CoverResult', description='coverResult'),
  }(name='AIAuditResult', description='data.resultDTO'),
}

async function getAuditResultWithOptions(request: GetAuditResultRequest, runtime: Util.RuntimeOptions): GetAuditResultResponse {
  Util.validateModel(request);
  return doRequest('GetAuditResult', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAuditResult(request: GetAuditResultRequest): GetAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuditResultWithOptions(request, runtime);
}

model CreateAuditRequest = {
  auditContent: string(name='AuditContent', description='auditContent'),
}

model CreateAuditResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function createAuditWithOptions(request: CreateAuditRequest, runtime: Util.RuntimeOptions): CreateAuditResponse {
  Util.validateModel(request);
  return doRequest('CreateAudit', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createAudit(request: CreateAuditRequest): CreateAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAuditWithOptions(request, runtime);
}

model GetAuditHistoryRequest = {
  videoId: string(name='VideoId', description='mediaId'),
  pageNo?: long(name='PageNo', description='pageNo'),
  pageSize?: long(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
}

model GetAuditHistoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  status: string(name='Status', description='data.status'),
  total: long(name='Total', description='data.total'),
  histories: [
    {
      creationTime: string(name='CreationTime', description='timestamp'),
      status: string(name='Status', description='status'),
      reason: string(name='Reason', description='reason'),
      comment: string(name='Comment', description='comment'),
      auditor: string(name='Auditor', description='auditor'),
    }
  ](name='Histories', description='data.auditHistoryList'),
}

async function getAuditHistoryWithOptions(request: GetAuditHistoryRequest, runtime: Util.RuntimeOptions): GetAuditHistoryResponse {
  Util.validateModel(request);
  return doRequest('GetAuditHistory', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAuditHistory(request: GetAuditHistoryRequest): GetAuditHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuditHistoryWithOptions(request, runtime);
}

model FinishLiveStreamRecordRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  customerId: long(name='CustomerId', description='customerId'),
  streamName: string(name='StreamName', description='streamName'),
  domainName: string(name='DomainName', description='domainName'),
  appName: string(name='AppName', description='appName'),
  autoCompose?: string(name='AutoCompose', description='autoCompose'),
  transcodeGroupId?: string(name='TranscodeGroupId', description='transcodeGroupId'),
}

model FinishLiveStreamRecordResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function finishLiveStreamRecordWithOptions(request: FinishLiveStreamRecordRequest, runtime: Util.RuntimeOptions): FinishLiveStreamRecordResponse {
  Util.validateModel(request);
  return doRequest('FinishLiveStreamRecord', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function finishLiveStreamRecord(request: FinishLiveStreamRecordRequest): FinishLiveStreamRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return finishLiveStreamRecordWithOptions(request, runtime);
}

model ListLiveRecordVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  streamName?: string(name='StreamName', description='streamName'),
  domainName?: string(name='DomainName', description='domainName'),
  appName?: string(name='AppName', description='appName'),
  queryType?: string(name='QueryType', description='queryType'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model ListLiveRecordVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  liveRecordVideoList: {
    liveRecordVideo: [
      {
        streamName: string(name='StreamName', description='streamName'),
        domainName: string(name='DomainName', description='domainName'),
        appName: string(name='AppName', description='appName'),
        playlistId: string(name='PlaylistId', description='playlistId'),
        recordStartTime: string(name='RecordStartTime', description='recordStartTime'),
        recordEndTime: string(name='RecordEndTime', description='recordEndTime'),
        playInfoList: {
          playInfo: [
            {
              width: long(name='Width', description='width'),
              height: long(name='Height', description='height'),
              size: long(name='Size', description='size'),
              playURL: string(name='PlayURL', description='playURL'),
              bitrate: string(name='Bitrate', description='bitrate'),
              definition: string(name='Definition', description='definition'),
              duration: string(name='Duration', description='duration'),
              format: string(name='Format', description='format'),
              fps: string(name='Fps', description='fps'),
              encrypt: long(name='Encrypt', description='encrypt'),
              plaintext: string(name='Plaintext', description='plaintext'),
              complexity: string(name='Complexity', description='complexity'),
              streamType: string(name='StreamType', description='streamType'),
              rand: string(name='Rand', description='rand'),
              jobId: string(name='JobId', description='jobId'),
            }
          ](name='PlayInfo', description='PlayInfo'),
        }(name='PlayInfoList', description='playInfoList'),
        video: {
          videoId: string(name='VideoId', description='mediaId'),
          title: string(name='Title', description='title'),
          tags: string(name='Tags', description='tags'),
          status: string(name='Status', description='state'),
          size: long(name='Size', description='fileSize'),
          privilege: integer(name='Privilege', description='publicType'),
          duration: float(name='Duration', description='duration'),
          description: string(name='Description', description='description'),
          customerId: long(name='CustomerId', description='userId'),
          createTime: string(name='CreateTime', description='gmtCreate'),
          modifyTime: string(name='ModifyTime', description='gmtModified'),
          coverURL: string(name='CoverURL', description='coverUrl'),
          cateId: integer(name='CateId', description='cateId'),
          cateName: string(name='CateName', description='cateName'),
          downloadSwitch: string(name='DownloadSwitch', description='download'),
          templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
          snapshots: {
            snapshot: [ string ](name='Snapshot', description='Snapshot'),
          }(name='Snapshots', description='snapshots'),
        }(name='Video', description='mediaInfo'),
      }
    ](name='LiveRecordVideo', description='LiveRecordVideo'),
  }(name='LiveRecordVideoList', description='data.liveRecordVideoList'),
}

async function listLiveRecordVideoWithOptions(request: ListLiveRecordVideoRequest, runtime: Util.RuntimeOptions): ListLiveRecordVideoResponse {
  Util.validateModel(request);
  return doRequest('ListLiveRecordVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listLiveRecordVideo(request: ListLiveRecordVideoRequest): ListLiveRecordVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLiveRecordVideoWithOptions(request, runtime);
}

model AddLiveStreamVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  customerId: long(name='CustomerId', description='customerId'),
  streamName: string(name='StreamName', description='streamName'),
  domainName: string(name='DomainName', description='domainName'),
  appName: string(name='AppName', description='appName'),
  transcodeGroupId?: string(name='TranscodeGroupId', description='transcodeGroupId'),
  resourceInfo?: string(name='ResourceInfo', description='resourceInfo'),
  fileUrl: string(name='FileUrl', description='fileUrl'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
  title?: string(name='Title', description='title'),
  tags?: string(name='Tags', description='tags'),
}

model AddLiveStreamVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
  playlistId: string(name='PlaylistId', description='data.playlistId'),
}

async function addLiveStreamVideoWithOptions(request: AddLiveStreamVideoRequest, runtime: Util.RuntimeOptions): AddLiveStreamVideoResponse {
  Util.validateModel(request);
  return doRequest('AddLiveStreamVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addLiveStreamVideo(request: AddLiveStreamVideoRequest): AddLiveStreamVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLiveStreamVideoWithOptions(request, runtime);
}

model SetTemplateGroupPropertyRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId: string(name='GroupId', description='groupId'),
  propertyName: string(name='PropertyName', description='propertyName'),
  propertyValue: string(name='PropertyValue', description='propertyValue'),
}

model SetTemplateGroupPropertyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function setTemplateGroupPropertyWithOptions(request: SetTemplateGroupPropertyRequest, runtime: Util.RuntimeOptions): SetTemplateGroupPropertyResponse {
  Util.validateModel(request);
  return doRequest('SetTemplateGroupProperty', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setTemplateGroupProperty(request: SetTemplateGroupPropertyRequest): SetTemplateGroupPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setTemplateGroupPropertyWithOptions(request, runtime);
}

model QueryUploadInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  customerId: long(name='CustomerId', description='customerId'),
  transcodeGroupId: string(name='TranscodeGroupId', description='transcodeGroupId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  liveRegionId?: string(name='LiveRegionId', description='liveRegionId'),
  composeTranscodeGroupId?: string(name='ComposeTranscodeGroupId', description='composeTranscodeGroupId'),
}

model QueryUploadInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  bucket: string(name='Bucket', description='data.bucket'),
  endpoint: string(name='Endpoint', description='data.endpoint'),
  fileDir: string(name='FileDir', description='data.fileDir'),
  resourceOwnerId: long(name='ResourceOwnerId', description='data.resourceOwnerId'),
}

async function queryUploadInfoWithOptions(request: QueryUploadInfoRequest, runtime: Util.RuntimeOptions): QueryUploadInfoResponse {
  Util.validateModel(request);
  return doRequest('QueryUploadInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function queryUploadInfo(request: QueryUploadInfoRequest): QueryUploadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUploadInfoWithOptions(request, runtime);
}

model FaceRegistrationRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  personName: string(name='PersonName', description='personName'),
  personId?: string(name='PersonId', description='personId'),
  personLibrary?: string(name='PersonLibrary', description='personLibrary'),
  category?: string(name='Category', description='category'),
  imageIds?: string(name='ImageIds', description='imageIds'),
}

model FaceRegistrationResponse = {
  requestId: string(name='RequestId', description='requestId'),
  registeredPerson: {
    personId: string(name='PersonId', description='personId'),
    personName: string(name='PersonName', description='personName'),
    faces: {
      face: [
        {
          imageId: string(name='ImageId', description='imageId'),
          quality: string(name='Quality', description='quality'),
          target: string(name='Target', description='target'),
        }
      ](name='Face', description='Face'),
    }(name='Faces', description='faceDTOs'),
  }(name='RegisteredPerson', description='data.personDTO'),
  nonExistImageIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistImageIds', description='data.nonExistImageIds'),
}

async function faceRegistrationWithOptions(request: FaceRegistrationRequest, runtime: Util.RuntimeOptions): FaceRegistrationResponse {
  Util.validateModel(request);
  return doRequest('FaceRegistration', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function faceRegistration(request: FaceRegistrationRequest): FaceRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceRegistrationWithOptions(request, runtime);
}

model ListAIJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  jobIds: string(name='JobIds', description='jobIds'),
}

model ListAIJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIJobList: {
    AIJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        type: string(name='Type', description='type'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        completeTime: string(name='CompleteTime', description='completeTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIJob', description='AIJob'),
  }(name='AIJobList', description='data.jobDTOs'),
  nonExistAIJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIJobIds', description='data.nonExistJobIds'),
}

async function listAIJobWithOptions(request: ListAIJobRequest, runtime: Util.RuntimeOptions): ListAIJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIJob(request: ListAIJobRequest): ListAIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIJobWithOptions(request, runtime);
}

model SubmitAIJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  types?: string(name='Types', description='types'),
  config?: string(name='Config', description='config'),
  userData?: string(name='UserData', description='userData'),
  mediaType?: string(name='MediaType', description='mediaType'),
}

model SubmitAIJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIJobList: {
    AIJob: [
      {
        jobId: string(name='JobId', description='id'),
        type: string(name='Type', description='type'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIJob', description='AIJob'),
  }(name='AIJobList', description='data.jobDTOs'),
}

async function submitAIJobWithOptions(request: SubmitAIJobRequest, runtime: Util.RuntimeOptions): SubmitAIJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIJob(request: SubmitAIJobRequest): SubmitAIJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIJobWithOptions(request, runtime);
}

model GetImageInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  imageId: string(name='ImageId', description='mediaId'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetImageInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  imageInfo: {
    imageId: string(name='ImageId', description='mediaId'),
    title: string(name='Title', description='title'),
    creationTime: string(name='CreationTime', description='createTime'),
    imageType: string(name='ImageType', description='imageType'),
    tags: string(name='Tags', description='tags'),
    URL: string(name='URL', description='url'),
    cateId: integer(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    description: string(name='Description', description='desc'),
    storageLocation: string(name='StorageLocation', description='storageLocation'),
    regionId: string(name='RegionId', description='regionId'),
    modificationTime: string(name='ModificationTime', description='modifyTime'),
    mezzanine: {
      fileURL: string(name='FileURL', description='fileUrl'),
      originalFileName: string(name='OriginalFileName', description='originalFileName'),
      fileSize: long(name='FileSize', description='fileSize'),
      width: integer(name='Width', description='width'),
      height: integer(name='Height', description='height'),
    }(name='Mezzanine', description='mezzanineDTO'),
  }(name='ImageInfo', description='data.image'),
}

async function getImageInfoWithOptions(request: GetImageInfoRequest, runtime: Util.RuntimeOptions): GetImageInfoResponse {
  Util.validateModel(request);
  return doRequest('GetImageInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getImageInfo(request: GetImageInfoRequest): GetImageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageInfoWithOptions(request, runtime);
}

model UpdateWatermarkInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkType: string(name='WatermarkType', description='watermarkType'),
  watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  watermarkId: string(name='WatermarkId', description='watermarkId'),
  mediaFileId?: string(name='MediaFileId', description='watermarkFileId'),
  watermarkName?: string(name='WatermarkName', description='watermarkName'),
}

model UpdateWatermarkInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function updateWatermarkInfoWithOptions(request: UpdateWatermarkInfoRequest, runtime: Util.RuntimeOptions): UpdateWatermarkInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateWatermarkInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateWatermarkInfo(request: UpdateWatermarkInfoRequest): UpdateWatermarkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatermarkInfoWithOptions(request, runtime);
}

model UpdateWatermarkGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  watermarkGroupId: string(name='WatermarkGroupId', description='watermarkGroupId'),
  watermarkGroupName?: string(name='WatermarkGroupName', description='watermarkGroupName'),
  isDefault?: boolean(name='IsDefault', description='isDefault'),
}

model UpdateWatermarkGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateWatermarkGroupWithOptions(request: UpdateWatermarkGroupRequest, runtime: Util.RuntimeOptions): UpdateWatermarkGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateWatermarkGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateWatermarkGroup(request: UpdateWatermarkGroupRequest): UpdateWatermarkGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatermarkGroupWithOptions(request, runtime);
}

model ListWatermarkInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkType: string(name='WatermarkType', description='watermarkType'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageNo?: string(name='PageNo', description='pageNo'),
  pageSize?: string(name='PageSize', description='pageSize'),
}

model ListWatermarkInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarkInfos: {
    watermarkInfo: [
      {
        watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
        watermarkId: string(name='WatermarkId', description='watermarkId'),
        watermarkType: string(name='WatermarkType', description='watermarkType'),
        watermarkName: string(name='WatermarkName', description='watermarkName'),
        watermarkFileUrl: string(name='WatermarkFileUrl', description='watermarkFileUrl'),
      }
    ](name='WatermarkInfo', description='WatermarkInfo'),
  }(name='WatermarkInfos', description='data.watermarkInfos'),
}

async function listWatermarkInfoWithOptions(request: ListWatermarkInfoRequest, runtime: Util.RuntimeOptions): ListWatermarkInfoResponse {
  Util.validateModel(request);
  return doRequest('ListWatermarkInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listWatermarkInfo(request: ListWatermarkInfoRequest): ListWatermarkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWatermarkInfoWithOptions(request, runtime);
}

model ListCompanionresourceInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  companionResourceType: string(name='CompanionResourceType', description='companionResourceType'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageNo?: string(name='PageNo', description='pageNo'),
  pageSize?: string(name='PageSize', description='pageSize'),
}

model ListCompanionresourceInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  companionResourceInfos: {
    companionResourceInfo: [
      {
        companionResourceId: string(name='CompanionResourceId', description='companionResourceId'),
        companionResourceType: string(name='CompanionResourceType', description='companionResourceType'),
        creationTime: string(name='CreationTime', description='creationTime'),
        mediaFileUrl: string(name='MediaFileUrl', description='mediaFileUrl'),
        resourceName: string(name='ResourceName', description='resourceName'),
        resourceTags: string(name='ResourceTags', description='resourceTags'),
        companionResourceConfig: string(name='CompanionResourceConfig', description='companionResourceConfig'),
      }
    ](name='CompanionResourceInfo', description='CompanionResourceInfo'),
  }(name='CompanionResourceInfos', description='data.companionResourceInfos'),
}

async function listCompanionresourceInfoWithOptions(request: ListCompanionresourceInfoRequest, runtime: Util.RuntimeOptions): ListCompanionresourceInfoResponse {
  Util.validateModel(request);
  return doRequest('ListCompanionresourceInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listCompanionresourceInfo(request: ListCompanionresourceInfoRequest): ListCompanionresourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCompanionresourceInfoWithOptions(request, runtime);
}

model GetWatermarkInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watermarkId'),
}

model GetWatermarkInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarkInfo: {
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    watermarkType: string(name='WatermarkType', description='watermarkType'),
    watermarkName: string(name='WatermarkName', description='watermarkName'),
    watermarkFileUrl: string(name='WatermarkFileUrl', description='watermarkFileUrl'),
  }(name='WatermarkInfo', description='data.watermarkInfo'),
}

async function getWatermarkInfoWithOptions(request: GetWatermarkInfoRequest, runtime: Util.RuntimeOptions): GetWatermarkInfoResponse {
  Util.validateModel(request);
  return doRequest('GetWatermarkInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getWatermarkInfo(request: GetWatermarkInfoRequest): GetWatermarkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkInfoWithOptions(request, runtime);
}

model GetWatermarkGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  pageNo?: long(name='PageNo', description='pageNo'),
  pageSize?: long(name='PageSize', description='pageSize'),
}

model GetWatermarkGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: string(name='Total', description='data.total'),
  watermarkGroupList: {
    watermarkGroup: [
      {
        watermarkId: string(name='WatermarkId', description='watermarkId'),
        watermarkGroupId: string(name='WatermarkGroupId', description='watermarkGroupId'),
        watermarkFileURL: string(name='WatermarkFileURL', description='watermarkFileURL'),
        watermarkType: string(name='WatermarkType', description='watermarkType'),
        watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
      }
    ](name='WatermarkGroup', description='WatermarkGroup'),
  }(name='WatermarkGroupList', description='data.watermarkGroupDTOS'),
}

async function getWatermarkGroupWithOptions(request: GetWatermarkGroupRequest, runtime: Util.RuntimeOptions): GetWatermarkGroupResponse {
  Util.validateModel(request);
  return doRequest('GetWatermarkGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getWatermarkGroup(request: GetWatermarkGroupRequest): GetWatermarkGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkGroupWithOptions(request, runtime);
}

model GetCompanionresourceInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  companionResourceId: string(name='CompanionResourceId', description='companionResourceId'),
}

model GetCompanionresourceInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  companionResourceInfo: {
    companionResourceId: string(name='CompanionResourceId', description='companionResourceId'),
    companionResourceType: string(name='CompanionResourceType', description='companionResourceType'),
    creationTime: string(name='CreationTime', description='creationTime'),
    mediaFileUrl: string(name='MediaFileUrl', description='mediaFileUrl'),
    resourceName: string(name='ResourceName', description='resourceName'),
    resourceTags: string(name='ResourceTags', description='resourceTags'),
    companionResourceConfig: string(name='CompanionResourceConfig', description='companionResourceConfig'),
  }(name='CompanionResourceInfo', description='data.companionResourceInfo'),
}

async function getCompanionresourceInfoWithOptions(request: GetCompanionresourceInfoRequest, runtime: Util.RuntimeOptions): GetCompanionresourceInfoResponse {
  Util.validateModel(request);
  return doRequest('GetCompanionresourceInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCompanionresourceInfo(request: GetCompanionresourceInfoRequest): GetCompanionresourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCompanionresourceInfoWithOptions(request, runtime);
}

model DeleteWatermarkRelationRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  watermarkGroupId: string(name='WatermarkGroupId', description='watermarkGroupId'),
  watermarkIds: string(name='WatermarkIds', description='watermarkIds'),
}

model DeleteWatermarkRelationResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteWatermarkRelationWithOptions(request: DeleteWatermarkRelationRequest, runtime: Util.RuntimeOptions): DeleteWatermarkRelationResponse {
  Util.validateModel(request);
  return doRequest('DeleteWatermarkRelation', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteWatermarkRelation(request: DeleteWatermarkRelationRequest): DeleteWatermarkRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatermarkRelationWithOptions(request, runtime);
}

model DeleteWatermarkInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkIds: string(name='WatermarkIds', description='watermarkIds'),
  delEmptyGroup?: string(name='DelEmptyGroup', description='delEmptyGroup'),
}

model DeleteWatermarkInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function deleteWatermarkInfoWithOptions(request: DeleteWatermarkInfoRequest, runtime: Util.RuntimeOptions): DeleteWatermarkInfoResponse {
  Util.validateModel(request);
  return doRequest('DeleteWatermarkInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteWatermarkInfo(request: DeleteWatermarkInfoRequest): DeleteWatermarkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatermarkInfoWithOptions(request, runtime);
}

model DeleteWatermarkGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  watermarkGroupId: string(name='WatermarkGroupId', description='watermarkGroupId'),
}

model DeleteWatermarkGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteWatermarkGroupWithOptions(request: DeleteWatermarkGroupRequest, runtime: Util.RuntimeOptions): DeleteWatermarkGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteWatermarkGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteWatermarkGroup(request: DeleteWatermarkGroupRequest): DeleteWatermarkGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatermarkGroupWithOptions(request, runtime);
}

model DeleteCompanionresourceInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  companionResourceIds: string(name='CompanionResourceIds', description='companionResourceIds'),
}

model DeleteCompanionresourceInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function deleteCompanionresourceInfoWithOptions(request: DeleteCompanionresourceInfoRequest, runtime: Util.RuntimeOptions): DeleteCompanionresourceInfoResponse {
  Util.validateModel(request);
  return doRequest('DeleteCompanionresourceInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteCompanionresourceInfo(request: DeleteCompanionresourceInfoRequest): DeleteCompanionresourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCompanionresourceInfoWithOptions(request, runtime);
}

model CreateUploadMediaFileRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  businessType: string(name='BusinessType', description='businessType'),
  fileExtension: string(name='FileExtension', description='fileExtension'),
  mediaId?: string(name='MediaId', description='mediaId'),
  userData?: string(name='UserData', description='userData'),
}

model CreateUploadMediaFileResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaFileInfo: {
    mediaFileId: string(name='MediaFileId', description='mediaFileId'),
    mediaId: string(name='MediaId', description='mediaId'),
    userData: string(name='UserData', description='userData'),
    mediaFilePath: string(name='MediaFilePath', description='mediaFilePath'),
    mediaFileAuth: string(name='MediaFileAuth', description='mediaFileAuth'),
    mediaFileURL: string(name='MediaFileURL', description='mediaFileURL'),
  }(name='MediaFileInfo', description='data.mediaFileInfo'),
}

async function createUploadMediaFileWithOptions(request: CreateUploadMediaFileRequest, runtime: Util.RuntimeOptions): CreateUploadMediaFileResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadMediaFile', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createUploadMediaFile(request: CreateUploadMediaFileRequest): CreateUploadMediaFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadMediaFileWithOptions(request, runtime);
}

model AddWatermarkRelationRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  watermarkGroupId: string(name='WatermarkGroupId', description='watermarkGroupId'),
  watermarkIds: string(name='WatermarkIds', description='watermarkIds'),
}

model AddWatermarkRelationResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addWatermarkRelationWithOptions(request: AddWatermarkRelationRequest, runtime: Util.RuntimeOptions): AddWatermarkRelationResponse {
  Util.validateModel(request);
  return doRequest('AddWatermarkRelation', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addWatermarkRelation(request: AddWatermarkRelationRequest): AddWatermarkRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWatermarkRelationWithOptions(request, runtime);
}

model AddWatermarkInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkType: string(name='WatermarkType', description='watermarkType'),
  watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  watermarkName?: string(name='WatermarkName', description='watermarkName'),
  mediaFileId?: string(name='MediaFileId', description='watermarkFileId'),
}

model AddWatermarkInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
  watermarkId: string(name='WatermarkId', description='data.watermarkId'),
}

async function addWatermarkInfoWithOptions(request: AddWatermarkInfoRequest, runtime: Util.RuntimeOptions): AddWatermarkInfoResponse {
  Util.validateModel(request);
  return doRequest('AddWatermarkInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addWatermarkInfo(request: AddWatermarkInfoRequest): AddWatermarkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWatermarkInfoWithOptions(request, runtime);
}

model AddWatermarkGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  watermarkGroupName: string(name='WatermarkGroupName', description='watermarkGroupName'),
}

model AddWatermarkGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addWatermarkGroupWithOptions(request: AddWatermarkGroupRequest, runtime: Util.RuntimeOptions): AddWatermarkGroupResponse {
  Util.validateModel(request);
  return doRequest('AddWatermarkGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addWatermarkGroup(request: AddWatermarkGroupRequest): AddWatermarkGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWatermarkGroupWithOptions(request, runtime);
}

model AddCompanionresourceInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  mediaFileId: string(name='MediaFileId', description='mediaFileId'),
  companionResourceType: string(name='CompanionResourceType', description='companionResourceType'),
  companionResourceConfig: string(name='CompanionResourceConfig', description='companionResourceConfig'),
  resourceName?: string(name='ResourceName', description='resourceName'),
  resourceTags?: string(name='ResourceTags', description='resourceTags'),
}

model AddCompanionresourceInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
  companionresourceId: string(name='CompanionresourceId', description='data.companionresourceId'),
}

async function addCompanionresourceInfoWithOptions(request: AddCompanionresourceInfoRequest, runtime: Util.RuntimeOptions): AddCompanionresourceInfoResponse {
  Util.validateModel(request);
  return doRequest('AddCompanionresourceInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addCompanionresourceInfo(request: AddCompanionresourceInfoRequest): AddCompanionresourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCompanionresourceInfoWithOptions(request, runtime);
}

model OpenVodServiceRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model OpenVodServiceResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
}

async function openVodServiceWithOptions(request: OpenVodServiceRequest, runtime: Util.RuntimeOptions): OpenVodServiceResponse {
  Util.validateModel(request);
  return doRequest('OpenVodService', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function openVodService(request: OpenVodServiceRequest): OpenVodServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openVodServiceWithOptions(request, runtime);
}

model SubmitAIVideoCategoryJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIVideoCategoryConfig?: string(name='AIVideoCategoryConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIVideoCategoryJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoCategoryJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIVideoCategoryJob', description='data.jobDTO'),
}

async function submitAIVideoCategoryJobWithOptions(request: SubmitAIVideoCategoryJobRequest, runtime: Util.RuntimeOptions): SubmitAIVideoCategoryJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIVideoCategoryJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIVideoCategoryJob(request: SubmitAIVideoCategoryJobRequest): SubmitAIVideoCategoryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIVideoCategoryJobWithOptions(request, runtime);
}

model ListAIVideoCategoryJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIVideoCategoryJobIds: string(name='AIVideoCategoryJobIds', description='jobIds'),
}

model ListAIVideoCategoryJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoCategoryJobList: {
    AIVideoCategoryJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIVideoCategoryJob', description='AIVideoCategoryJob'),
  }(name='AIVideoCategoryJobList', description='data.jobDTOs'),
  nonExistAIVideoCategoryJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIVideoCategoryJobIds', description='data.nonExistJobIds'),
}

async function listAIVideoCategoryJobWithOptions(request: ListAIVideoCategoryJobRequest, runtime: Util.RuntimeOptions): ListAIVideoCategoryJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIVideoCategoryJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIVideoCategoryJob(request: ListAIVideoCategoryJobRequest): ListAIVideoCategoryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIVideoCategoryJobWithOptions(request, runtime);
}

model CreateOrderRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model CreateOrderResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
}

async function createOrderWithOptions(request: CreateOrderRequest, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  return doRequest('CreateOrder', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrderWithOptions(request, runtime);
}

model GetBatchPlayInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoIds: string(name='VideoIds', description='videoIds'),
  formats?: string(name='Formats', description='formats'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  rand?: string(name='Rand', description='rand'),
  authInfo?: string(name='AuthInfo', description='authInfo'),
  channel?: string(name='Channel', description='channel'),
  playerVersion?: string(name='PlayerVersion', description='playerVersion'),
  outputType?: string(name='OutputType', description='outputType'),
  streamType?: string(name='StreamType', description='streamType'),
  reAuthInfo?: string(name='ReAuthInfo', description='reAuthInfo'),
}

model GetBatchPlayInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  batchPlayInfoList: [
    {
      videoId: string(name='VideoId', description='videoId'),
      errorCode: string(name='ErrorCode', description='code'),
      errorMessage: string(name='ErrorMessage', description='message'),
      httpStatusCode: long(name='HttpStatusCode', description='httpStatusCode'),
      playInfoList: [
        {
          width: long(name='Width', description='width'),
          height: long(name='Height', description='height'),
          size: long(name='Size', description='size'),
          playURL: string(name='PlayURL', description='playURL'),
          bitrate: string(name='Bitrate', description='bitrate'),
          definition: string(name='Definition', description='definition'),
          duration: string(name='Duration', description='duration'),
          format: string(name='Format', description='format'),
          fps: string(name='Fps', description='fps'),
          encrypt: long(name='Encrypt', description='encrypt'),
          plaintext: string(name='Plaintext', description='plaintext'),
          complexity: string(name='Complexity', description='complexity'),
          streamType: string(name='StreamType', description='streamType'),
          rand: string(name='Rand', description='rand'),
          jobId: string(name='JobId', description='jobId'),
        }
      ](name='PlayInfoList', description='playInfoList'),
    }
  ](name='BatchPlayInfoList', description='data.batchPlayInfo'),
}

async function getBatchPlayInfoWithOptions(request: GetBatchPlayInfoRequest, runtime: Util.RuntimeOptions): GetBatchPlayInfoResponse {
  Util.validateModel(request);
  return doRequest('GetBatchPlayInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getBatchPlayInfo(request: GetBatchPlayInfoRequest): GetBatchPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBatchPlayInfoWithOptions(request, runtime);
}

model SubmitAIVideoTerrorismRecogJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIVideoTerrorismRecogConfig?: string(name='AIVideoTerrorismRecogConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIVideoTerrorismRecogJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoTerrorismRecogJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIVideoTerrorismRecogJob', description='data.jobDTO'),
}

async function submitAIVideoTerrorismRecogJobWithOptions(request: SubmitAIVideoTerrorismRecogJobRequest, runtime: Util.RuntimeOptions): SubmitAIVideoTerrorismRecogJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIVideoTerrorismRecogJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIVideoTerrorismRecogJob(request: SubmitAIVideoTerrorismRecogJobRequest): SubmitAIVideoTerrorismRecogJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIVideoTerrorismRecogJobWithOptions(request, runtime);
}

model SubmitAIVideoCensorJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIVideoCensorConfig?: string(name='AIVideoCensorConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIVideoCensorJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoCensorJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIVideoCensorJob', description='data.jobDTO'),
}

async function submitAIVideoCensorJobWithOptions(request: SubmitAIVideoCensorJobRequest, runtime: Util.RuntimeOptions): SubmitAIVideoCensorJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIVideoCensorJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIVideoCensorJob(request: SubmitAIVideoCensorJobRequest): SubmitAIVideoCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIVideoCensorJobWithOptions(request, runtime);
}

model ListAIVideoTerrorismRecogJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIVideoTerrorismRecogJobIds: string(name='AIVideoTerrorismRecogJobIds', description='jobIds'),
}

model ListAIVideoTerrorismRecogJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoTerrorismRecogJobList: {
    AIVideoTerrorismRecogJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIVideoTerrorismRecogJob', description='AIVideoTerrorismRecogJob'),
  }(name='AIVideoTerrorismRecogJobList', description='data.jobDTOs'),
  nonExistTerrorismRecogJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistTerrorismRecogJobIds', description='data.nonExistJobIds'),
}

async function listAIVideoTerrorismRecogJobWithOptions(request: ListAIVideoTerrorismRecogJobRequest, runtime: Util.RuntimeOptions): ListAIVideoTerrorismRecogJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIVideoTerrorismRecogJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIVideoTerrorismRecogJob(request: ListAIVideoTerrorismRecogJobRequest): ListAIVideoTerrorismRecogJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIVideoTerrorismRecogJobWithOptions(request, runtime);
}

model ListAIVideoCensorJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIVideoCensorJobIds: string(name='AIVideoCensorJobIds', description='jobIds'),
}

model ListAIVideoCensorJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoCensorJobList: {
    AIVideoCensorJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIVideoCensorJob', description='AIVideoCensorJob'),
  }(name='AIVideoCensorJobList', description='data.jobDTOs'),
  nonExistAIVideoCensorJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIVideoCensorJobIds', description='data.nonExistJobIds'),
}

async function listAIVideoCensorJobWithOptions(request: ListAIVideoCensorJobRequest, runtime: Util.RuntimeOptions): ListAIVideoCensorJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIVideoCensorJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIVideoCensorJob(request: ListAIVideoCensorJobRequest): ListAIVideoCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIVideoCensorJobWithOptions(request, runtime);
}

model DeleteStreamRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  jobIds: string(name='JobIds', description='jobIds'),
  videoId: string(name='VideoId', description='mediaId'),
}

model DeleteStreamResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteStreamWithOptions(request: DeleteStreamRequest, runtime: Util.RuntimeOptions): DeleteStreamResponse {
  Util.validateModel(request);
  return doRequest('DeleteStream', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteStream(request: DeleteStreamRequest): DeleteStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStreamWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  specifiedOffsetTime?: long(name='SpecifiedOffsetTime', description='time'),
  width?: string(name='Width', description='width'),
  height?: string(name='Height', description='height'),
  count?: long(name='Count', description='num'),
  interval?: long(name='Interval', description='interval'),
  spriteSnapshotConfig?: string(name='SpriteSnapshotConfig', description='spriteConfig'),
  snapshotTemplateId?: string(name='SnapshotTemplateId', description='snapshotTemplateId'),
}

model SubmitSnapshotJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  snapshotJob: {
    jobId: string(name='JobId', description='jobId'),
  }(name='SnapshotJob', description='data.submitSnapshotJobDTO'),
}

async function submitSnapshotJobWithOptions(request: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitSnapshotJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model DescribeDomainFlowDataRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  timeMerge?: string(name='TimeMerge', description='timeMerge'),
  interval?: string(name='Interval', description='interval'),
  locationNameEn?: string(name='LocationNameEn', description='locationNameEn'),
  ispNameEn?: string(name='IspNameEn', description='ispNameEn'),
}

model DescribeDomainFlowDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  dataInterval: string(name='DataInterval', description='data.dataInterval'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  flowDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='timeStamp'),
        value: string(name='Value', description='value'),
        domesticValue: string(name='DomesticValue', description='domesticValue'),
        overseasValue: string(name='OverseasValue', description='overseasValue'),
        dynamicValue: string(name='DynamicValue', description='dynamicValue'),
        dynamicDomesticValue: string(name='DynamicDomesticValue', description='dynamicDomesticValue'),
        dynamicOverseasValue: string(name='DynamicOverseasValue', description='dynamicOverseasValue'),
        staticValue: string(name='StaticValue', description='staticValue'),
        staticDomesticValue: string(name='StaticDomesticValue', description='staticDomesticValue'),
        staticOverseasValue: string(name='StaticOverseasValue', description='staticOverseasValue'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='FlowDataPerInterval', description='data.flowDataPerIntervals'),
}

async function describeDomainFlowDataWithOptions(request: DescribeDomainFlowDataRequest, runtime: Util.RuntimeOptions): DescribeDomainFlowDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeDomainFlowData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeDomainFlowData(request: DescribeDomainFlowDataRequest): DescribeDomainFlowDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainFlowDataWithOptions(request, runtime);
}

model DescribeDomainBpsDataRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  domainName?: string(name='DomainName', description='domainName'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  timeMerge?: string(name='TimeMerge', description='timeMerge'),
  interval?: string(name='Interval', description='interval'),
  locationNameEn?: string(name='LocationNameEn', description='locationNameEn'),
  ispNameEn?: string(name='IspNameEn', description='ispNameEn'),
}

model DescribeDomainBpsDataResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainName: string(name='DomainName', description='data.domainName'),
  dataInterval: string(name='DataInterval', description='data.dataInterval'),
  startTime: string(name='StartTime', description='data.startTime'),
  endTime: string(name='EndTime', description='data.endTime'),
  bpsDataPerInterval: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='timeStamp'),
        value: string(name='Value', description='value'),
        domesticValue: string(name='DomesticValue', description='domesticValue'),
        overseasValue: string(name='OverseasValue', description='overseasValue'),
        l2Value: string(name='L2Value', description='l2Value'),
        domesticL2Value: string(name='DomesticL2Value', description='domesticL2Value'),
        overseasL2Value: string(name='OverseasL2Value', description='overseasL2Value'),
        dynamicValue: long(name='DynamicValue', description='dynamicValue'),
        dynamicDomesticValue: string(name='DynamicDomesticValue', description='dynamicDomesticValue'),
        dynamicOverseasValue: string(name='DynamicOverseasValue', description='dynamicOverseasValue'),
        staticValue: string(name='StaticValue', description='staticValue'),
        staticDomesticValue: string(name='StaticDomesticValue', description='staticDomesticValue'),
        staticOverseasValue: string(name='StaticOverseasValue', description='staticOverseasValue'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='BpsDataPerInterval', description='data.bpsDataPerIntervals'),
  supplyBpsDatas: {
    dataModule: [
      {
        timeStamp: string(name='TimeStamp', description='timeStamp'),
        value: string(name='Value', description='value'),
      }
    ](name='DataModule', description='DataModule'),
  }(name='SupplyBpsDatas', description='data.supplyBpsDatas'),
}

async function describeDomainBpsDataWithOptions(request: DescribeDomainBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDomainBpsDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeDomainBpsData', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeDomainBpsData(request: DescribeDomainBpsDataRequest): DescribeDomainBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainBpsDataWithOptions(request, runtime);
}

model DescribeCdnDomainLogsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  domainName: string(name='DomainName', description='domainName'),
  logDay?: string(name='LogDay', description='logDay'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageSize?: long(name='PageSize', description='pageSize'),
  pageNo?: long(name='PageNo', description='pageNumber'),
}

model DescribeCdnDomainLogsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pageNo: long(name='PageNo', description='data.pageNumber'),
  pageSize: long(name='PageSize', description='data.pageSize'),
  total: long(name='Total', description='data.totalCount'),
  domainLogModel: {
    domainName: string(name='DomainName', description='domainName'),
    domainLogDetails: {
      domainLogDetail: [
        {
          logPath: string(name='LogPath', description='logPath'),
          startTime: string(name='StartTime', description='startTime'),
          endTime: string(name='EndTime', description='endTime'),
          logSize: long(name='LogSize', description='logSize'),
          logName: string(name='LogName', description='logName'),
        }
      ](name='DomainLogDetail', description='DomainLogDetail'),
    }(name='DomainLogDetails', description='domainLogDetails'),
  }(name='DomainLogModel', description='data.domainLogModel'),
}

async function describeCdnDomainLogsWithOptions(request: DescribeCdnDomainLogsRequest, runtime: Util.RuntimeOptions): DescribeCdnDomainLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeCdnDomainLogs', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeCdnDomainLogs(request: DescribeCdnDomainLogsRequest): DescribeCdnDomainLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCdnDomainLogsWithOptions(request, runtime);
}

model SubmitAIVideoSummaryJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIVideoSummaryConfig?: string(name='AIVideoSummaryConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIVideoSummaryJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoSummaryJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIVideoSummaryJob', description='data.jobDTO'),
}

async function submitAIVideoSummaryJobWithOptions(request: SubmitAIVideoSummaryJobRequest, runtime: Util.RuntimeOptions): SubmitAIVideoSummaryJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIVideoSummaryJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIVideoSummaryJob(request: SubmitAIVideoSummaryJobRequest): SubmitAIVideoSummaryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIVideoSummaryJobWithOptions(request, runtime);
}

model ListAIVideoSummaryJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIVideoSummaryJobIds: string(name='AIVideoSummaryJobIds', description='jobIds'),
}

model ListAIVideoSummaryJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoSummaryJobList: {
    AIVideoSummaryJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIVideoSummaryJob', description='AIVideoSummaryJob'),
  }(name='AIVideoSummaryJobList', description='data.jobDTOs'),
  nonExistAIVideoSummaryJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIVideoSummaryJobIds', description='data.nonExistJobIds'),
}

async function listAIVideoSummaryJobWithOptions(request: ListAIVideoSummaryJobRequest, runtime: Util.RuntimeOptions): ListAIVideoSummaryJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIVideoSummaryJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIVideoSummaryJob(request: ListAIVideoSummaryJobRequest): ListAIVideoSummaryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIVideoSummaryJobWithOptions(request, runtime);
}

model DescribeUserVvTopByDayRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoType: string(name='VideoType', description='videoType'),
  bizdate: string(name='Bizdate', description='bizdate'),
}

model DescribeUserVvTopByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        count: string(name='Count', description='count'),
        videoid: string(name='Videoid', description='videoid'),
        videoName: string(name='VideoName', description='videoName'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserVvTopByDayWithOptions(request: DescribeUserVvTopByDayRequest, runtime: Util.RuntimeOptions): DescribeUserVvTopByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserVvTopByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserVvTopByDay(request: DescribeUserVvTopByDayRequest): DescribeUserVvTopByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserVvTopByDayWithOptions(request, runtime);
}

model DescribeUserVvByVideoidRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoid: string(name='Videoid', description='videoid'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribeUserVvByVideoidResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        date: string(name='Date', description='date'),
        all: string(name='All', description='all'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserVvByVideoidWithOptions(request: DescribeUserVvByVideoidRequest, runtime: Util.RuntimeOptions): DescribeUserVvByVideoidResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserVvByVideoid', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserVvByVideoid(request: DescribeUserVvByVideoidRequest): DescribeUserVvByVideoidResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserVvByVideoidWithOptions(request, runtime);
}

model DescribeUserVvByDayRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoType: string(name='VideoType', description='videoType'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribeUserVvByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        date: string(name='Date', description='date'),
        android: string(name='Android', description='android'),
        ios: string(name='Ios', description='ios'),
        h5: string(name='H5', description='h5'),
        flash: string(name='Flash', description='flash'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserVvByDayWithOptions(request: DescribeUserVvByDayRequest, runtime: Util.RuntimeOptions): DescribeUserVvByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserVvByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserVvByDay(request: DescribeUserVvByDayRequest): DescribeUserVvByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserVvByDayWithOptions(request, runtime);
}

model DescribeUserUvByDayRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoType: string(name='VideoType', description='videoType'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribeUserUvByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        date: string(name='Date', description='date'),
        android: string(name='Android', description='android'),
        ios: string(name='Ios', description='ios'),
        h5: string(name='H5', description='h5'),
        flash: string(name='Flash', description='flash'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserUvByDayWithOptions(request: DescribeUserUvByDayRequest, runtime: Util.RuntimeOptions): DescribeUserUvByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserUvByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserUvByDay(request: DescribeUserUvByDayRequest): DescribeUserUvByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserUvByDayWithOptions(request, runtime);
}

model DescribeUserTimeRangeByDayRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoType: string(name='VideoType', description='videoType'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribeUserTimeRangeByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        date: string(name='Date', description='date'),
        all: string(name='All', description='all'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserTimeRangeByDayWithOptions(request: DescribeUserTimeRangeByDayRequest, runtime: Util.RuntimeOptions): DescribeUserTimeRangeByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserTimeRangeByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserTimeRangeByDay(request: DescribeUserTimeRangeByDayRequest): DescribeUserTimeRangeByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserTimeRangeByDayWithOptions(request, runtime);
}

model DescribeUserAvgTimeByDayRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoType: string(name='VideoType', description='videoType'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribeUserAvgTimeByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        date: string(name='Date', description='date'),
        all: string(name='All', description='all'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserAvgTimeByDayWithOptions(request: DescribeUserAvgTimeByDayRequest, runtime: Util.RuntimeOptions): DescribeUserAvgTimeByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserAvgTimeByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserAvgTimeByDay(request: DescribeUserAvgTimeByDayRequest): DescribeUserAvgTimeByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserAvgTimeByDayWithOptions(request, runtime);
}

model DescribeUserAvgCountByDayRequest = {
  securityToken?: string(name='SecurityToken', description='securityToken'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  videoType: string(name='VideoType', description='videoType'),
  startTime: string(name='StartTime', description='startTime'),
  endTime: string(name='EndTime', description='endTime'),
}

model DescribeUserAvgCountByDayResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userPlayStatisticsInfos: {
    userPlayStatisticsInfo: [
      {
        date: string(name='Date', description='date'),
        all: string(name='All', description='all'),
      }
    ](name='UserPlayStatisticsInfo', description='UserPlayStatisticsInfo'),
  }(name='UserPlayStatisticsInfos', description='userPlayStatisticsInfos'),
}

async function describeUserAvgCountByDayWithOptions(request: DescribeUserAvgCountByDayRequest, runtime: Util.RuntimeOptions): DescribeUserAvgCountByDayResponse {
  Util.validateModel(request);
  return doRequest('DescribeUserAvgCountByDay', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function describeUserAvgCountByDay(request: DescribeUserAvgCountByDayRequest): DescribeUserAvgCountByDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserAvgCountByDayWithOptions(request, runtime);
}

model SetDefaultTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId: string(name='GroupId', description='groupId'),
}

model SetDefaultTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function setDefaultTemplateGroupWithOptions(request: SetDefaultTemplateGroupRequest, runtime: Util.RuntimeOptions): SetDefaultTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setDefaultTemplateGroup(request: SetDefaultTemplateGroupRequest): SetDefaultTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultTemplateGroupWithOptions(request, runtime);
}

model SubmitAIASRJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIASRConfig?: string(name='AIASRConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIASRJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIASRJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIASRJob', description='data.jobDTO'),
}

async function submitAIASRJobWithOptions(request: SubmitAIASRJobRequest, runtime: Util.RuntimeOptions): SubmitAIASRJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIASRJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIASRJob(request: SubmitAIASRJobRequest): SubmitAIASRJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIASRJobWithOptions(request, runtime);
}

model ListAIASRJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIASRJobIds: string(name='AIASRJobIds', description='jobIds'),
}

model ListAIASRJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIASRJobList: {
    AIASRJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIASRJob', description='AIASRJob'),
  }(name='AIASRJobList', description='data.jobDTOs'),
  nonExistAIASRJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIASRJobIds', description='data.nonExistJobIds'),
}

async function listAIASRJobWithOptions(request: ListAIASRJobRequest, runtime: Util.RuntimeOptions): ListAIASRJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIASRJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIASRJob(request: ListAIASRJobRequest): ListAIASRJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIASRJobWithOptions(request, runtime);
}

model GetMezzanineInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  outputType?: string(name='OutputType', description='outputType'),
  additionType?: string(name='AdditionType', description='additionType'),
}

model GetMezzanineInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mezzanine: {
    videoId: string(name='VideoId', description='mediaId'),
    bitrate: string(name='Bitrate', description='bitrate'),
    creationTime: string(name='CreationTime', description='createTime'),
    duration: string(name='Duration', description='durationStr'),
    fps: string(name='Fps', description='fps'),
    height: long(name='Height', description='height'),
    width: long(name='Width', description='width'),
    size: long(name='Size', description='size'),
    status: string(name='Status', description='status'),
    fileURL: string(name='FileURL', description='fileURL'),
    fileName: string(name='FileName', description='fileName'),
    CRC64: string(name='CRC64', description='crc64'),
    preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
    outputType: string(name='OutputType', description='outputType'),
    audioStreamList: [
      {
        index: string(name='Index', description='index'),
        codecName: string(name='CodecName', description='codecName'),
        codecLongName: string(name='CodecLongName', description='codecLongName'),
        codecTimeBase: string(name='CodecTimeBase', description='codecTimeBase'),
        codecTagString: string(name='CodecTagString', description='codecTagString'),
        codecTag: string(name='CodecTag', description='codecTag'),
        sampleFmt: string(name='SampleFmt', description='sampleFmt'),
        sampleRate: string(name='SampleRate', description='sampleRate'),
        channels: string(name='Channels', description='channels'),
        channelLayout: string(name='ChannelLayout', description='channelLayout'),
        timebase: string(name='Timebase', description='timebase'),
        startTime: string(name='StartTime', description='startTime'),
        duration: string(name='Duration', description='duration'),
        bitrate: string(name='Bitrate', description='bitrate'),
        numFrames: string(name='NumFrames', description='numFrames'),
        lang: string(name='Lang', description='lang'),
      }
    ](name='AudioStreamList', description='audioStreamList'),
    videoStreamList: [
      {
        index: string(name='Index', description='index'),
        codecName: string(name='CodecName', description='codecName'),
        codecLongName: string(name='CodecLongName', description='codecLongName'),
        profile: string(name='Profile', description='profile'),
        codecTimeBase: string(name='CodecTimeBase', description='codecTimeBase'),
        codecTagString: string(name='CodecTagString', description='codecTagString'),
        codecTag: string(name='CodecTag', description='codecTag'),
        width: string(name='Width', description='width'),
        height: string(name='Height', description='height'),
        hasBFrames: string(name='HasBFrames', description='hasBFrames'),
        sar: string(name='Sar', description='sar'),
        dar: string(name='Dar', description='dar'),
        pixFmt: string(name='PixFmt', description='pixFmt'),
        level: string(name='Level', description='level'),
        fps: string(name='Fps', description='fps'),
        avgFPS: string(name='AvgFPS', description='avgFPS'),
        timebase: string(name='Timebase', description='timebase'),
        startTime: string(name='StartTime', description='startTime'),
        duration: string(name='Duration', description='duration'),
        numFrames: string(name='NumFrames', description='numFrames'),
        lang: string(name='Lang', description='lang'),
      }
    ](name='VideoStreamList', description='videoStreamList'),
  }(name='Mezzanine', description='data.fileInfo'),
}

async function getMezzanineInfoWithOptions(request: GetMezzanineInfoRequest, runtime: Util.RuntimeOptions): GetMezzanineInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMezzanineInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMezzanineInfo(request: GetMezzanineInfoRequest): GetMezzanineInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMezzanineInfoWithOptions(request, runtime);
}

model UpdateTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name: string(name='Name', description='name'),
  groupId: string(name='GroupId', description='groupId'),
  toNeedTranscode?: string(name='ToNeedTranscode', description='toNeedTranscode'),
}

model UpdateTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function updateTemplateGroupWithOptions(request: UpdateTemplateGroupRequest, runtime: Util.RuntimeOptions): UpdateTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateTemplateGroup(request: UpdateTemplateGroupRequest): UpdateTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateGroupWithOptions(request, runtime);
}

model UpdateCustomTemplateAndGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  configs?: string(name='Configs', description='configs'),
}

model UpdateCustomTemplateAndGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function updateCustomTemplateAndGroupWithOptions(request: UpdateCustomTemplateAndGroupRequest, runtime: Util.RuntimeOptions): UpdateCustomTemplateAndGroupResponse {
  Util.validateModel(request);
  return doRequest('UpdateCustomTemplateAndGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateCustomTemplateAndGroup(request: UpdateCustomTemplateAndGroupRequest): UpdateCustomTemplateAndGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomTemplateAndGroupWithOptions(request, runtime);
}

model UpdateCustomTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId?: string(name='GroupId', description='groupId'),
  video: string(name='Video', description='video'),
  audio: string(name='Audio', description='audio'),
  transConfig?: string(name='TransConfig', description='transConfig'),
  muxConfig?: string(name='MuxConfig', description='muxConfig'),
  container: string(name='Container', description='container'),
  definition: string(name='Definition', description='definition'),
  useWaterMark?: string(name='UseWaterMark', description='useWaterMark'),
  encrypt?: string(name='Encrypt', description='encrypt'),
  condition?: string(name='Condition', description='templateCondition'),
  templateId: string(name='TemplateId', description='templateId'),
  narrowBand?: string(name='NarrowBand', description='narrowBand'),
}

model UpdateCustomTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function updateCustomTemplateWithOptions(request: UpdateCustomTemplateRequest, runtime: Util.RuntimeOptions): UpdateCustomTemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateCustomTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateCustomTemplate(request: UpdateCustomTemplateRequest): UpdateCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCustomTemplateWithOptions(request, runtime);
}

model ListTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  isContainsTemplates?: boolean(name='IsContainsTemplates', description='containTemplates'),
}

model ListTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateGroups: {
    templateGroup: [
      {
        groupId: string(name='GroupId', description='groupId'),
        defaultGroup: string(name='DefaultGroup', description='defaultGroup'),
        status: string(name='Status', description='status'),
        groupSymbol: string(name='GroupSymbol', description='groupFlag'),
        groupType: string(name='GroupType', description='type'),
        name: string(name='Name', description='name'),
        transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
        isLocked: string(name='IsLocked', description='isLocked'),
      }
    ](name='TemplateGroup', description='TemplateGroup'),
  }(name='TemplateGroups', description='data.groups'),
}

async function listTemplateGroupWithOptions(request: ListTemplateGroupRequest, runtime: Util.RuntimeOptions): ListTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('ListTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listTemplateGroup(request: ListTemplateGroupRequest): ListTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplateGroupWithOptions(request, runtime);
}

model ListCustomTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId: string(name='GroupId', description='groupId'),
}

model ListCustomTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templates: {
    template: [
      {
        definition: string(name='Definition', description='definition'),
        condition: string(name='Condition', description='transcodeCondition'),
        templateId: string(name='TemplateId', description='templateId'),
        status: string(name='Status', description='status'),
        userWaterMark: string(name='UserWaterMark', description='waterMark'),
        narrowBand: string(name='NarrowBand', description='narrowBand'),
        encrypt: string(name='Encrypt', description='encrypt'),
        video: {
          codec: string(name='Codec', description='codec'),
          profile: string(name='Profile', description='profile'),
          bitrate: string(name='Bitrate', description='bitrate'),
          crf: string(name='Crf', description='crf'),
          width: string(name='Width', description='width'),
          height: string(name='Height', description='height'),
          fps: string(name='Fps', description='fps'),
          gop: string(name='Gop', description='gop'),
          preset: string(name='Preset', description='preset'),
          scanMode: string(name='ScanMode', description='scanMode'),
          pixFmt: string(name='PixFmt', description='pixFmt'),
          remove: string(name='Remove', description='remove'),
          crop: string(name='Crop', description='crop'),
          pad: string(name='Pad', description='pad'),
        }(name='Video', description='video'),
        audio: {
          codec: string(name='Codec', description='codec'),
          profile: string(name='Profile', description='profile'),
          bitrate: string(name='Bitrate', description='bitrate'),
          samplerate: string(name='Samplerate', description='samplerate'),
          channels: string(name='Channels', description='channels'),
          remove: string(name='Remove', description='remove'),
        }(name='Audio', description='audio'),
        container: {
          format: string(name='Format', description='format'),
        }(name='Container', description='container'),
        transConfig: {
          transMode: string(name='TransMode', description='transMode'),
          isCheckReso: string(name='IsCheckReso', description='isCheckReso'),
          isCheckResoFail: string(name='IsCheckResoFail', description='isCheckResoFail'),
          isCheckVideoBitrate: string(name='IsCheckVideoBitrate', description='isCheckVideoBitrate'),
          isCheckAudioBitrate: string(name='IsCheckAudioBitrate', description='isCheckAudioBitrate'),
          isCheckAudioBitrateFail: string(name='isCheckAudioBitrateFail', description='isCheckAudioBitrateFail'),
          isCheckVideoBitrateFail: string(name='isCheckVideoBitrateFail', description='isCheckVideoBitrateFail'),
        }(name='TransConfig', description='transConfig'),
        muxConfig: {
          segment: {
            duration: string(name='Duration', description='duration'),
          }(name='Segment', description='segment'),
        }(name='MuxConfig', description='muxConfig'),
      }
    ](name='Template', description='Template'),
  }(name='Templates', description='data.templates'),
}

async function listCustomTemplateWithOptions(request: ListCustomTemplateRequest, runtime: Util.RuntimeOptions): ListCustomTemplateResponse {
  Util.validateModel(request);
  return doRequest('ListCustomTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listCustomTemplate(request: ListCustomTemplateRequest): ListCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomTemplateWithOptions(request, runtime);
}

model InitSystemTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  userId: long(name='UserId', description='customerId'),
}

model InitSystemTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function initSystemTemplateGroupWithOptions(request: InitSystemTemplateGroupRequest, runtime: Util.RuntimeOptions): InitSystemTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('InitSystemTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function initSystemTemplateGroup(request: InitSystemTemplateGroupRequest): InitSystemTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return initSystemTemplateGroupWithOptions(request, runtime);
}

model InitCustomerWorkFlowRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  userId: long(name='UserId', description='userId'),
  flushConfig?: boolean(name='FlushConfig', description='flushConfig'),
}

model InitCustomerWorkFlowResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function initCustomerWorkFlowWithOptions(request: InitCustomerWorkFlowRequest, runtime: Util.RuntimeOptions): InitCustomerWorkFlowResponse {
  Util.validateModel(request);
  return doRequest('InitCustomerWorkFlow', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function initCustomerWorkFlow(request: InitCustomerWorkFlowRequest): InitCustomerWorkFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return initCustomerWorkFlowWithOptions(request, runtime);
}

model InitCustomerWithSystemTemplateAndGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  userId: long(name='UserId', description='customerId'),
  groupId?: string(name='GroupId', description='groupId'),
  workFlowId?: string(name='WorkFlowId', description='workFlowId'),
}

model InitCustomerWithSystemTemplateAndGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function initCustomerWithSystemTemplateAndGroupWithOptions(request: InitCustomerWithSystemTemplateAndGroupRequest, runtime: Util.RuntimeOptions): InitCustomerWithSystemTemplateAndGroupResponse {
  Util.validateModel(request);
  return doRequest('InitCustomerWithSystemTemplateAndGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function initCustomerWithSystemTemplateAndGroup(request: InitCustomerWithSystemTemplateAndGroupRequest): InitCustomerWithSystemTemplateAndGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return initCustomerWithSystemTemplateAndGroupWithOptions(request, runtime);
}

model GetTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  groupId: string(name='GroupId', description='groupId'),
}

model GetTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templateGroup: {
    groupId: string(name='GroupId', description='groupId'),
    defaultGroup: string(name='DefaultGroup', description='defaultGroup'),
    status: string(name='Status', description='status'),
    groupType: string(name='GroupType', description='type'),
    name: string(name='Name', description='name'),
    transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
    groupSymbol: string(name='GroupSymbol', description='groupFlag'),
    isLocked: string(name='IsLocked', description='isLocked'),
    templates: {
      template: [
        {
          definition: string(name='Definition', description='definition'),
          mediaDefinition: string(name='MediaDefinition', description='definition'),
          condition: string(name='Condition', description='transcodeCondition'),
          templateId: string(name='TemplateId', description='templateId'),
          status: string(name='Status', description='status'),
          userWaterMark: string(name='UserWaterMark', description='waterMark'),
          useWaterMark: string(name='UseWaterMark', description='waterMark'),
          narrowBand: string(name='NarrowBand', description='narrowBand'),
          encrypt: string(name='Encrypt', description='encrypt'),
          isLocked: string(name='IsLocked', description='isLocked'),
          name: string(name='Name', description='name'),
          video: {
            codec: string(name='Codec', description='codec'),
            profile: string(name='Profile', description='profile'),
            bitrate: string(name='Bitrate', description='bitrate'),
            crf: string(name='Crf', description='crf'),
            width: string(name='Width', description='width'),
            height: string(name='Height', description='height'),
            fps: string(name='Fps', description='fps'),
            gop: string(name='Gop', description='gop'),
            preset: string(name='Preset', description='preset'),
            scanMode: string(name='ScanMode', description='scanMode'),
            pixFmt: string(name='PixFmt', description='pixFmt'),
            remove: string(name='Remove', description='remove'),
            crop: string(name='Crop', description='crop'),
            pad: string(name='Pad', description='pad'),
            longShortMode: string(name='LongShortMode', description='longShortMode'),
          }(name='Video', description='video'),
          audio: {
            codec: string(name='Codec', description='codec'),
            profile: string(name='Profile', description='profile'),
            bitrate: string(name='Bitrate', description='bitrate'),
            samplerate: string(name='Samplerate', description='samplerate'),
            channels: string(name='Channels', description='channels'),
            remove: string(name='Remove', description='remove'),
          }(name='Audio', description='audio'),
          container: {
            format: string(name='Format', description='format'),
          }(name='Container', description='container'),
          transConfig: {
            transMode: string(name='TransMode', description='transMode'),
            isCheckReso: string(name='IsCheckReso', description='isCheckReso'),
            isCheckResoFail: string(name='IsCheckResoFail', description='isCheckResoFail'),
            isCheckVideoBitrate: string(name='IsCheckVideoBitrate', description='isCheckVideoBitrate'),
            isCheckAudioBitrate: string(name='IsCheckAudioBitrate', description='isCheckAudioBitrate'),
            isCheckAudioBitrateFail: string(name='IsCheckAudioBitrateFail', description='isCheckAudioBitrateFail'),
            isCheckVideoBitrateFail: string(name='IsCheckVideoBitrateFail', description='isCheckVideoBitrateFail'),
          }(name='TransConfig', description='transConfig'),
          muxConfig: {
            segment: {
              duration: string(name='Duration', description='duration'),
            }(name='Segment', description='segment'),
          }(name='MuxConfig', description='muxConfig'),
        }
      ](name='Template', description='Template'),
    }(name='Templates', description='templates'),
  }(name='TemplateGroup', description='data.group'),
}

async function getTemplateGroupWithOptions(request: GetTemplateGroupRequest, runtime: Util.RuntimeOptions): GetTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('GetTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getTemplateGroup(request: GetTemplateGroupRequest): GetTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateGroupWithOptions(request, runtime);
}

model GetCustomTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model GetCustomTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  template: {
    definition: string(name='Definition', description='definition'),
    condition: string(name='Condition', description='transcodeCondition'),
    templateId: string(name='TemplateId', description='templateId'),
    status: string(name='Status', description='status'),
    userWaterMark: string(name='UserWaterMark', description='waterMark'),
    narrowBand: string(name='NarrowBand', description='narrowBand'),
    encrypt: string(name='Encrypt', description='encrypt'),
    video: {
      codec: string(name='Codec', description='codec'),
      profile: string(name='Profile', description='profile'),
      bitrate: string(name='Bitrate', description='bitrate'),
      crf: string(name='Crf', description='crf'),
      width: string(name='Width', description='width'),
      height: string(name='Height', description='height'),
      fps: string(name='Fps', description='fps'),
      gop: string(name='Gop', description='gop'),
      preset: string(name='Preset', description='preset'),
      scanMode: string(name='ScanMode', description='scanMode'),
      pixFmt: string(name='PixFmt', description='pixFmt'),
      remove: string(name='Remove', description='remove'),
      crop: string(name='Crop', description='crop'),
      pad: string(name='Pad', description='pad'),
    }(name='Video', description='video'),
    audio: {
      codec: string(name='Codec', description='codec'),
      profile: string(name='Profile', description='profile'),
      bitrate: string(name='Bitrate', description='bitrate'),
      samplerate: string(name='Samplerate', description='samplerate'),
      channels: string(name='Channels', description='channels'),
      remove: string(name='Remove', description='remove'),
    }(name='Audio', description='audio'),
    container: {
      format: string(name='Format', description='format'),
    }(name='Container', description='container'),
    transConfig: {
      transMode: string(name='TransMode', description='transMode'),
      isCheckReso: string(name='IsCheckReso', description='isCheckReso'),
      isCheckResoFail: string(name='IsCheckResoFail', description='isCheckResoFail'),
      isCheckVideoBitrate: string(name='IsCheckVideoBitrate', description='isCheckVideoBitrate'),
      isCheckAudioBitrate: string(name='IsCheckAudioBitrate', description='isCheckAudioBitrate'),
      isCheckAudioBitrateFail: string(name='isCheckAudioBitrateFail', description='isCheckAudioBitrateFail'),
      isCheckVideoBitrateFail: string(name='isCheckVideoBitrateFail', description='isCheckVideoBitrateFail'),
    }(name='TransConfig', description='transConfig'),
    muxConfig: {
      segment: {
        duration: string(name='Duration', description='duration'),
      }(name='Segment', description='segment'),
    }(name='MuxConfig', description='muxConfig'),
  }(name='Template', description='data.template'),
}

async function getCustomTemplateWithOptions(request: GetCustomTemplateRequest, runtime: Util.RuntimeOptions): GetCustomTemplateResponse {
  Util.validateModel(request);
  return doRequest('GetCustomTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCustomTemplate(request: GetCustomTemplateRequest): GetCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomTemplateWithOptions(request, runtime);
}

model DeleteTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId: string(name='GroupId', description='groupId'),
}

model DeleteTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function deleteTemplateGroupWithOptions(request: DeleteTemplateGroupRequest, runtime: Util.RuntimeOptions): DeleteTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteTemplateGroup(request: DeleteTemplateGroupRequest): DeleteTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateGroupWithOptions(request, runtime);
}

model DeleteInitCustomTemplateInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  userId: string(name='UserId', description='customerId'),
}

model DeleteInitCustomTemplateInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='result'),
}

async function deleteInitCustomTemplateInfoWithOptions(request: DeleteInitCustomTemplateInfoRequest, runtime: Util.RuntimeOptions): DeleteInitCustomTemplateInfoResponse {
  Util.validateModel(request);
  return doRequest('DeleteInitCustomTemplateInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteInitCustomTemplateInfo(request: DeleteInitCustomTemplateInfoRequest): DeleteInitCustomTemplateInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInitCustomTemplateInfoWithOptions(request, runtime);
}

model DeleteCustomTemplateAndGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  userId: string(name='UserId', description='customerId'),
}

model DeleteCustomTemplateAndGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function deleteCustomTemplateAndGroupWithOptions(request: DeleteCustomTemplateAndGroupRequest, runtime: Util.RuntimeOptions): DeleteCustomTemplateAndGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteCustomTemplateAndGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteCustomTemplateAndGroup(request: DeleteCustomTemplateAndGroupRequest): DeleteCustomTemplateAndGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomTemplateAndGroupWithOptions(request, runtime);
}

model DeleteCustomTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId?: string(name='GroupId', description='groupId'),
  templateIds: string(name='TemplateIds', description='templateIds'),
}

model DeleteCustomTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function deleteCustomTemplateWithOptions(request: DeleteCustomTemplateRequest, runtime: Util.RuntimeOptions): DeleteCustomTemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteCustomTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteCustomTemplate(request: DeleteCustomTemplateRequest): DeleteCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomTemplateWithOptions(request, runtime);
}

model AddTemplateGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  name: string(name='Name', description='name'),
  toNeedTranscode: string(name='ToNeedTranscode', description='toNeedTranscode'),
}

model AddTemplateGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function addTemplateGroupWithOptions(request: AddTemplateGroupRequest, runtime: Util.RuntimeOptions): AddTemplateGroupResponse {
  Util.validateModel(request);
  return doRequest('AddTemplateGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addTemplateGroup(request: AddTemplateGroupRequest): AddTemplateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTemplateGroupWithOptions(request, runtime);
}

model AddCustomTemplateAndGroupRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  configs?: string(name='Configs', description='configs'),
}

model AddCustomTemplateAndGroupResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
  templateGroup: {
    templateGroupId: string(name='TemplateGroupId', description='groupId'),
  }(name='TemplateGroup', description='data.templateGroups'),
}

async function addCustomTemplateAndGroupWithOptions(request: AddCustomTemplateAndGroupRequest, runtime: Util.RuntimeOptions): AddCustomTemplateAndGroupResponse {
  Util.validateModel(request);
  return doRequest('AddCustomTemplateAndGroup', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addCustomTemplateAndGroup(request: AddCustomTemplateAndGroupRequest): AddCustomTemplateAndGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCustomTemplateAndGroupWithOptions(request, runtime);
}

model AddCustomTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  groupId?: string(name='GroupId', description='groupId'),
  video: string(name='Video', description='video'),
  audio: string(name='Audio', description='audio'),
  transConfig?: string(name='TransConfig', description='transConfig'),
  muxConfig?: string(name='MuxConfig', description='muxConfig'),
  container: string(name='Container', description='container'),
  definition: string(name='Definition', description='definition'),
  useWaterMark?: string(name='UseWaterMark', description='useWaterMark'),
  encrypt?: string(name='Encrypt', description='encrypt'),
  condition?: string(name='Condition', description='templateCondition'),
  narrowBand?: string(name='NarrowBand', description='narrowBand'),
}

model AddCustomTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function addCustomTemplateWithOptions(request: AddCustomTemplateRequest, runtime: Util.RuntimeOptions): AddCustomTemplateResponse {
  Util.validateModel(request);
  return doRequest('AddCustomTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addCustomTemplate(request: AddCustomTemplateRequest): AddCustomTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCustomTemplateWithOptions(request, runtime);
}

model SubmitAIVideoPornRecogJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIVideoPornRecogConfig?: string(name='AIVideoPornRecogConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIVideoPornRecogJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoPornRecogJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIVideoPornRecogJob', description='data.jobDTO'),
}

async function submitAIVideoPornRecogJobWithOptions(request: SubmitAIVideoPornRecogJobRequest, runtime: Util.RuntimeOptions): SubmitAIVideoPornRecogJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIVideoPornRecogJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIVideoPornRecogJob(request: SubmitAIVideoPornRecogJobRequest): SubmitAIVideoPornRecogJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIVideoPornRecogJobWithOptions(request, runtime);
}

model ListAIVideoPornRecogJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIVideoPornRecogJobIds: string(name='AIVideoPornRecogJobIds', description='jobIds'),
}

model ListAIVideoPornRecogJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoPornRecogJobList: {
    AIVideoPornRecogJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIVideoPornRecogJob', description='AIVideoPornRecogJob'),
  }(name='AIVideoPornRecogJobList', description='data.jobDTOs'),
  nonExistPornRecogJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistPornRecogJobIds', description='data.nonExistJobIds'),
}

async function listAIVideoPornRecogJobWithOptions(request: ListAIVideoPornRecogJobRequest, runtime: Util.RuntimeOptions): ListAIVideoPornRecogJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIVideoPornRecogJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIVideoPornRecogJob(request: ListAIVideoPornRecogJobRequest): ListAIVideoPornRecogJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIVideoPornRecogJobWithOptions(request, runtime);
}

model SubmitAIVideoCoverJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  AIVideoCoverConfig?: string(name='AIVideoCoverConfig', description='config'),
  userData?: string(name='UserData', description='userData'),
}

model SubmitAIVideoCoverJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoCoverJob: {
    jobId: string(name='JobId', description='id'),
    mediaId: string(name='MediaId', description='mediaId'),
    status: string(name='Status', description='status'),
    code: string(name='Code', description='code'),
    message: string(name='Message', description='message'),
    creationTime: string(name='CreationTime', description='creationTime'),
    data: string(name='Data', description='data'),
  }(name='AIVideoCoverJob', description='data.jobDTO'),
}

async function submitAIVideoCoverJobWithOptions(request: SubmitAIVideoCoverJobRequest, runtime: Util.RuntimeOptions): SubmitAIVideoCoverJobResponse {
  Util.validateModel(request);
  return doRequest('SubmitAIVideoCoverJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function submitAIVideoCoverJob(request: SubmitAIVideoCoverJobRequest): SubmitAIVideoCoverJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAIVideoCoverJobWithOptions(request, runtime);
}

model ListAIVideoCoverJobRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  AIVideoCoverJobIds: string(name='AIVideoCoverJobIds', description='jobIds'),
}

model ListAIVideoCoverJobResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AIVideoCoverJobList: {
    AIVideoCoverJob: [
      {
        jobId: string(name='JobId', description='id'),
        mediaId: string(name='MediaId', description='mediaId'),
        status: string(name='Status', description='status'),
        code: string(name='Code', description='code'),
        message: string(name='Message', description='message'),
        creationTime: string(name='CreationTime', description='creationTime'),
        data: string(name='Data', description='data'),
      }
    ](name='AIVideoCoverJob', description='AIVideoCoverJob'),
  }(name='AIVideoCoverJobList', description='data.jobDTOs'),
  nonExistAIVideoCoverJobIds: {
    string: [ string ](name='String', description='String'),
  }(name='NonExistAIVideoCoverJobIds', description='data.nonExistJobIds'),
}

async function listAIVideoCoverJobWithOptions(request: ListAIVideoCoverJobRequest, runtime: Util.RuntimeOptions): ListAIVideoCoverJobResponse {
  Util.validateModel(request);
  return doRequest('ListAIVideoCoverJob', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAIVideoCoverJob(request: ListAIVideoCoverJobRequest): ListAIVideoCoverJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAIVideoCoverJobWithOptions(request, runtime);
}

model DeleteAudioTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model DeleteAudioTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='result'),
}

async function deleteAudioTemplateWithOptions(request: DeleteAudioTemplateRequest, runtime: Util.RuntimeOptions): DeleteAudioTemplateResponse {
  Util.validateModel(request);
  return doRequest('DeleteAudioTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteAudioTemplate(request: DeleteAudioTemplateRequest): DeleteAudioTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAudioTemplateWithOptions(request, runtime);
}

model DeleteAudioConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model DeleteAudioConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='result'),
}

async function deleteAudioConfigWithOptions(request: DeleteAudioConfigRequest, runtime: Util.RuntimeOptions): DeleteAudioConfigResponse {
  Util.validateModel(request);
  return doRequest('DeleteAudioConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteAudioConfig(request: DeleteAudioConfigRequest): DeleteAudioConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAudioConfigWithOptions(request, runtime);
}

model AddOriginTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model AddOriginTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addOriginTemplateWithOptions(request: AddOriginTemplateRequest, runtime: Util.RuntimeOptions): AddOriginTemplateResponse {
  Util.validateModel(request);
  return doRequest('AddOriginTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addOriginTemplate(request: AddOriginTemplateRequest): AddOriginTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addOriginTemplateWithOptions(request, runtime);
}

model UpdateMaterialStatusRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  materialIds: string(name='MaterialIds', description='materialIds'),
  status: string(name='Status', description='state'),
}

model UpdateMaterialStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateMaterialStatusWithOptions(request: UpdateMaterialStatusRequest, runtime: Util.RuntimeOptions): UpdateMaterialStatusResponse {
  Util.validateModel(request);
  return doRequest('UpdateMaterialStatus', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateMaterialStatus(request: UpdateMaterialStatusRequest): UpdateMaterialStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMaterialStatusWithOptions(request, runtime);
}

model UpdateMaterialRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  materialId: string(name='MaterialId', description='materialId'),
  title?: string(name='Title', description='title'),
  description?: string(name='Description', description='description'),
  tags?: string(name='Tags', description='tags'),
  coverUrl?: string(name='CoverUrl', description='coverUrl'),
  cateId?: integer(name='CateId', description='cateId'),
}

model UpdateMaterialResponse = {
  requestId: string(name='RequestId', description='requestId'),
  material: {
    materialId: string(name='MaterialId', description='materialId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
    status: string(name='Status', description='stateStr'),
    size: long(name='Size', description='fileSize'),
    duration: float(name='Duration', description='duration'),
    description: string(name='Description', description='description'),
    customerId: long(name='CustomerId', description='userId'),
    createTime: string(name='CreateTime', description='gmtCreateStr'),
    modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
    coverURL: string(name='CoverURL', description='coverUrl'),
    cateId: integer(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    source: string(name='Source', description='source'),
    snapshots: {
      snapshot: [ string ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshotList'),
    tiles: {
      tile: [ string ](name='Tile', description='Tile'),
    }(name='Tiles', description='tileList'),
  }(name='Material', description='data.material'),
}

async function updateMaterialWithOptions(request: UpdateMaterialRequest, runtime: Util.RuntimeOptions): UpdateMaterialResponse {
  Util.validateModel(request);
  return doRequest('UpdateMaterial', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateMaterial(request: UpdateMaterialRequest): UpdateMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMaterialWithOptions(request, runtime);
}

model UpdateEditingProjectStatusRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectIds: string(name='ProjectIds', description='editingProjectIds'),
  status: string(name='Status', description='state'),
}

model UpdateEditingProjectStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateEditingProjectStatusWithOptions(request: UpdateEditingProjectStatusRequest, runtime: Util.RuntimeOptions): UpdateEditingProjectStatusResponse {
  Util.validateModel(request);
  return doRequest('UpdateEditingProjectStatus', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateEditingProjectStatus(request: UpdateEditingProjectStatusRequest): UpdateEditingProjectStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEditingProjectStatusWithOptions(request, runtime);
}

model UpdateEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
  title?: string(name='Title', description='title'),
  timeline?: string(name='Timeline', description='timeline'),
  description?: string(name='Description', description='description'),
  coverUrl?: string(name='CoverUrl', description='coverUrl'),
  duration?: float(name='Duration', description='duration'),
}

model UpdateEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  project: {
    projectId: string(name='ProjectId', description='projectId'),
    createTime: string(name='CreateTime', description='gmtCreateStr'),
    modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
    customerId: string(name='CustomerId', description='userId'),
    status: string(name='Status', description='stateStr'),
    description: string(name='Description', description='description'),
    title: string(name='Title', description='title'),
    timeline: string(name='Timeline', description='timeline'),
    producedMediaId: string(name='ProducedMediaId', description='producedMediaId'),
    duration: float(name='Duration', description='duration'),
    coverUrl: string(name='CoverUrl', description='coverUrl'),
  }(name='Project', description='data.project'),
}

async function updateEditingProjectWithOptions(request: UpdateEditingProjectRequest, runtime: Util.RuntimeOptions): UpdateEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('UpdateEditingProject', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateEditingProject(request: UpdateEditingProjectRequest): UpdateEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEditingProjectWithOptions(request, runtime);
}

model SyncMaterialRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='videoIds'),
}

model SyncMaterialResponse = {
  requestId: string(name='RequestId', description='requestId'),
  successVideoIds: {
    string: [ string ](name='String', description='String'),
  }(name='SuccessVideoIds', description='successVideoIds'),
  failedVideoIds: {
    string: [ string ](name='String', description='String'),
  }(name='FailedVideoIds', description='failedVideoIds'),
}

async function syncMaterialWithOptions(request: SyncMaterialRequest, runtime: Util.RuntimeOptions): SyncMaterialResponse {
  Util.validateModel(request);
  return doRequest('SyncMaterial', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function syncMaterial(request: SyncMaterialRequest): SyncMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncMaterialWithOptions(request, runtime);
}

model SetEditingProjectMaterialsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
  materialIds: string(name='MaterialIds', description='materialIds'),
}

model SetEditingProjectMaterialsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  materialList: {
    material: [
      {
        materialId: string(name='MaterialId', description='materialId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='stateStr'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreateStr'),
        modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshotList'),
        tiles: {
          tile: [ string ](name='Tile', description='Tile'),
        }(name='Tiles', description='tileList'),
      }
    ](name='Material', description='Material'),
  }(name='MaterialList', description='data.materialDOs'),
}

async function setEditingProjectMaterialsWithOptions(request: SetEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): SetEditingProjectMaterialsResponse {
  Util.validateModel(request);
  return doRequest('SetEditingProjectMaterials', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setEditingProjectMaterials(request: SetEditingProjectMaterialsRequest): SetEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setEditingProjectMaterialsWithOptions(request, runtime);
}

model SearchMaterialRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  cateId?: integer(name='CateId', description='cateId'),
  endTime?: string(name='EndTime', description='endTime'),
  startTime?: string(name='StartTime', description='startTime'),
  status?: string(name='Status', description='state'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  type?: string(name='Type', description='type'),
  source?: string(name='Source', description='source'),
  title?: string(name='Title', description='title'),
}

model SearchMaterialResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  materialList: {
    material: [
      {
        materialId: string(name='MaterialId', description='materialId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='stateStr'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreateStr'),
        modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        source: string(name='Source', description='source'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshotList'),
        tiles: {
          tile: [ string ](name='Tile', description='Tile'),
        }(name='Tiles', description='tileList'),
      }
    ](name='Material', description='Material'),
  }(name='MaterialList', description='data.materialList'),
}

async function searchMaterialWithOptions(request: SearchMaterialRequest, runtime: Util.RuntimeOptions): SearchMaterialResponse {
  Util.validateModel(request);
  return doRequest('SearchMaterial', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function searchMaterial(request: SearchMaterialRequest): SearchMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMaterialWithOptions(request, runtime);
}

model SearchEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  endTime?: string(name='EndTime', description='endTime'),
  startTime?: string(name='StartTime', description='startTime'),
  status?: string(name='Status', description='state'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  title?: string(name='Title', description='title'),
}

model SearchEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  projectList: {
    project: [
      {
        projectId: string(name='ProjectId', description='projectId'),
        createTime: string(name='CreateTime', description='gmtCreateStr'),
        modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
        customerId: string(name='CustomerId', description='userId'),
        status: string(name='Status', description='stateStr'),
        description: string(name='Description', description='description'),
        title: string(name='Title', description='title'),
        producedMediaId: string(name='ProducedMediaId', description='producedMediaId'),
        duration: float(name='Duration', description='duration'),
        coverUrl: string(name='CoverUrl', description='coverUrl'),
      }
    ](name='Project', description='Project'),
  }(name='ProjectList', description='data.projectDOList'),
}

async function searchEditingProjectWithOptions(request: SearchEditingProjectRequest, runtime: Util.RuntimeOptions): SearchEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('SearchEditingProject', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function searchEditingProject(request: SearchEditingProjectRequest): SearchEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchEditingProjectWithOptions(request, runtime);
}

model RefreshUploadMaterialTokenRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  materialId: string(name='MaterialId', description='materialId'),
}

model RefreshUploadMaterialTokenResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
}

async function refreshUploadMaterialTokenWithOptions(request: RefreshUploadMaterialTokenRequest, runtime: Util.RuntimeOptions): RefreshUploadMaterialTokenResponse {
  Util.validateModel(request);
  return doRequest('RefreshUploadMaterialToken', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function refreshUploadMaterialToken(request: RefreshUploadMaterialTokenRequest): RefreshUploadMaterialTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshUploadMaterialTokenWithOptions(request, runtime);
}

model ProduceEditingProjectVideoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  projectId: string(name='ProjectId', description='projectId'),
}

model ProduceEditingProjectVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaId: string(name='MediaId', description='data.mediaId'),
}

async function produceEditingProjectVideoWithOptions(request: ProduceEditingProjectVideoRequest, runtime: Util.RuntimeOptions): ProduceEditingProjectVideoResponse {
  Util.validateModel(request);
  return doRequest('ProduceEditingProjectVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function produceEditingProjectVideo(request: ProduceEditingProjectVideoRequest): ProduceEditingProjectVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return produceEditingProjectVideoWithOptions(request, runtime);
}

model GetMaterialListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  cateId?: integer(name='CateId', description='cateId'),
  status?: string(name='Status', description='states'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  type?: string(name='Type', description='type'),
  source?: string(name='Source', description='source'),
}

model GetMaterialListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  materialList: {
    material: [
      {
        materialId: string(name='MaterialId', description='materialId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='stateStr'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreateStr'),
        modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        source: string(name='Source', description='source'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshotList'),
        tiles: {
          tile: [ string ](name='Tile', description='Tile'),
        }(name='Tiles', description='tileList'),
      }
    ](name='Material', description='Material'),
  }(name='MaterialList', description='data.materialList'),
}

async function getMaterialListWithOptions(request: GetMaterialListRequest, runtime: Util.RuntimeOptions): GetMaterialListResponse {
  Util.validateModel(request);
  return doRequest('GetMaterialList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMaterialList(request: GetMaterialListRequest): GetMaterialListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMaterialListWithOptions(request, runtime);
}

model GetMaterialRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  materialId: string(name='MaterialId', description='materialId'),
}

model GetMaterialResponse = {
  requestId: string(name='RequestId', description='requestId'),
  material: {
    materialId: string(name='MaterialId', description='materialId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
    status: string(name='Status', description='stateStr'),
    size: long(name='Size', description='fileSize'),
    duration: float(name='Duration', description='duration'),
    description: string(name='Description', description='description'),
    customerId: long(name='CustomerId', description='userId'),
    createTime: string(name='CreateTime', description='gmtCreateStr'),
    modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
    coverURL: string(name='CoverURL', description='coverUrl'),
    cateId: integer(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    source: string(name='Source', description='source'),
    snapshots: {
      snapshot: [ string ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshotList'),
    tiles: {
      tile: [ string ](name='Tile', description='Tile'),
    }(name='Tiles', description='tileList'),
  }(name='Material', description='data.material'),
}

async function getMaterialWithOptions(request: GetMaterialRequest, runtime: Util.RuntimeOptions): GetMaterialResponse {
  Util.validateModel(request);
  return doRequest('GetMaterial', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMaterial(request: GetMaterialRequest): GetMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMaterialWithOptions(request, runtime);
}

model GetEditingProjectMaterialsRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
  type: string(name='Type', description='type'),
}

model GetEditingProjectMaterialsResponse = {
  requestId: string(name='RequestId', description='requestId'),
  materialList: {
    material: [
      {
        materialId: string(name='MaterialId', description='mediaId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='stateStr'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreateStr'),
        modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        source: string(name='Source', description='source'),
        spriteConfig: string(name='SpriteConfig', description='spriteConfig'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshotList'),
        tiles: {
          tile: [ string ](name='Tile', description='Tile'),
        }(name='Tiles', description='tileList'),
      }
    ](name='Material', description='Material'),
  }(name='MaterialList', description='data.materialDOs'),
}

async function getEditingProjectMaterialsWithOptions(request: GetEditingProjectMaterialsRequest, runtime: Util.RuntimeOptions): GetEditingProjectMaterialsResponse {
  Util.validateModel(request);
  return doRequest('GetEditingProjectMaterials', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getEditingProjectMaterials(request: GetEditingProjectMaterialsRequest): GetEditingProjectMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectMaterialsWithOptions(request, runtime);
}

model GetEditingProjectListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  status?: string(name='Status', description='states'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
}

model GetEditingProjectListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  projectList: {
    project: [
      {
        projectId: string(name='ProjectId', description='projectId'),
        createTime: string(name='CreateTime', description='gmtCreateStr'),
        modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
        customerId: string(name='CustomerId', description='userId'),
        status: string(name='Status', description='stateStr'),
        description: string(name='Description', description='description'),
        title: string(name='Title', description='title'),
        producedMediaId: string(name='ProducedMediaId', description='producedMediaId'),
        duration: float(name='Duration', description='duration'),
        coverUrl: string(name='CoverUrl', description='coverUrl'),
      }
    ](name='Project', description='Project'),
  }(name='ProjectList', description='data.projectDOList'),
}

async function getEditingProjectListWithOptions(request: GetEditingProjectListRequest, runtime: Util.RuntimeOptions): GetEditingProjectListResponse {
  Util.validateModel(request);
  return doRequest('GetEditingProjectList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getEditingProjectList(request: GetEditingProjectListRequest): GetEditingProjectListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectListWithOptions(request, runtime);
}

model GetEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectId: string(name='ProjectId', description='projectId'),
}

model GetEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  project: {
    projectId: string(name='ProjectId', description='projectId'),
    createTime: string(name='CreateTime', description='gmtCreateStr'),
    modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
    customerId: string(name='CustomerId', description='userId'),
    status: string(name='Status', description='stateStr'),
    description: string(name='Description', description='description'),
    title: string(name='Title', description='title'),
    timeline: string(name='Timeline', description='timeline'),
    producedMediaId: string(name='ProducedMediaId', description='producedMediaId'),
    duration: float(name='Duration', description='duration'),
    coverUrl: string(name='CoverUrl', description='coverUrl'),
  }(name='Project', description='data.project'),
}

async function getEditingProjectWithOptions(request: GetEditingProjectRequest, runtime: Util.RuntimeOptions): GetEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('GetEditingProject', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getEditingProject(request: GetEditingProjectRequest): GetEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEditingProjectWithOptions(request, runtime);
}

model DeleteMaterialRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  materialIds: string(name='MaterialIds', description='materialIdStr'),
  force?: boolean(name='Force', description='force'),
}

model DeleteMaterialResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMaterialWithOptions(request: DeleteMaterialRequest, runtime: Util.RuntimeOptions): DeleteMaterialResponse {
  Util.validateModel(request);
  return doRequest('DeleteMaterial', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteMaterial(request: DeleteMaterialRequest): DeleteMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaterialWithOptions(request, runtime);
}

model DeleteEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  projectIds: string(name='ProjectIds', description='projectIdStr'),
}

model DeleteEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteEditingProjectWithOptions(request: DeleteEditingProjectRequest, runtime: Util.RuntimeOptions): DeleteEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('DeleteEditingProject', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteEditingProject(request: DeleteEditingProjectRequest): DeleteEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEditingProjectWithOptions(request, runtime);
}

model CreateUploadMaterialRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  description?: string(name='Description', description='description'),
  fileName: string(name='FileName', description='fileName'),
  fileSize: long(name='FileSize', description='fileSize'),
  title: string(name='Title', description='title'),
  createTime?: string(name='CreateTime', description='createTime'),
  cateId?: integer(name='CateId', description='cateId'),
  tags?: string(name='Tags', description='tags'),
}

model CreateUploadMaterialResponse = {
  requestId: string(name='RequestId', description='requestId'),
  materialId: string(name='MaterialId', description='data.material.materialId'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
}

async function createUploadMaterialWithOptions(request: CreateUploadMaterialRequest, runtime: Util.RuntimeOptions): CreateUploadMaterialResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadMaterial', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createUploadMaterial(request: CreateUploadMaterialRequest): CreateUploadMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadMaterialWithOptions(request, runtime);
}

model AddEditingProjectRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  title: string(name='Title', description='title'),
  description?: string(name='Description', description='description'),
  timeline?: string(name='Timeline', description='timeline'),
  coverUrl?: string(name='CoverUrl', description='coverUrl'),
  duration?: float(name='Duration', description='duration'),
}

model AddEditingProjectResponse = {
  requestId: string(name='RequestId', description='requestId'),
  project: {
    projectId: string(name='ProjectId', description='projectId'),
    createTime: string(name='CreateTime', description='gmtCreateStr'),
    modifyTime: string(name='ModifyTime', description='gmtModifiedStr'),
    customerId: string(name='CustomerId', description='userId'),
    status: string(name='Status', description='stateStr'),
    description: string(name='Description', description='description'),
    title: string(name='Title', description='title'),
  }(name='Project', description='data.project'),
}

async function addEditingProjectWithOptions(request: AddEditingProjectRequest, runtime: Util.RuntimeOptions): AddEditingProjectResponse {
  Util.validateModel(request);
  return doRequest('AddEditingProject', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addEditingProject(request: AddEditingProjectRequest): AddEditingProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEditingProjectWithOptions(request, runtime);
}

model GetCategoriesRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  cateId?: long(name='CateId', description='cateId'),
  pageNo?: long(name='PageNo', description='pageNo'),
  pageSize?: long(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  type?: string(name='Type', description='type'),
}

model GetCategoriesResponse = {
  requestId: string(name='RequestId', description='requestId'),
  subTotal: long(name='SubTotal', description='data.subTotal'),
  subCategories: {
    category: [
      {
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        level: long(name='Level', description='level'),
        parentId: long(name='ParentId', description='parentId'),
        subTotal: long(name='SubTotal', description='subTotal'),
        type: string(name='Type', description='type'),
      }
    ](name='Category', description='Category'),
  }(name='SubCategories', description='data.subCategories'),
  category: {
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    level: long(name='Level', description='level'),
    parentId: long(name='ParentId', description='parentId'),
    grandId: long(name='GrandId', description='grandId'),
    type: string(name='Type', description='type'),
  }(name='Category', description='data.category'),
}

async function getCategoriesWithOptions(request: GetCategoriesRequest, runtime: Util.RuntimeOptions): GetCategoriesResponse {
  Util.validateModel(request);
  return doRequest('GetCategories', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCategories(request: GetCategoriesRequest): GetCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCategoriesWithOptions(request, runtime);
}

model UpdateCategoryRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  cateName: string(name='CateName', description='cateName'),
  cateId: long(name='CateId', description='cateId'),
}

model UpdateCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateCategoryWithOptions(request: UpdateCategoryRequest, runtime: Util.RuntimeOptions): UpdateCategoryResponse {
  Util.validateModel(request);
  return doRequest('UpdateCategory', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateCategory(request: UpdateCategoryRequest): UpdateCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryWithOptions(request, runtime);
}

model GetAudioTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateId: string(name='TemplateId', description='templateId'),
}

model GetAudioTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  audio: {
    templateId: string(name='TemplateId', description='templateId'),
    codec: string(name='Codec', description='codec'),
    bitrate: string(name='Bitrate', description='bitrate'),
    channeles: string(name='Channeles', description='mapChannel'),
    remove: string(name='Remove', description='mapRemove'),
    name: string(name='Name', description='name'),
    format: string(name='Format', description='format'),
    status: string(name='Status', description='mapStatus'),
    type: string(name='Type', description='mapType'),
    isDefault: string(name='IsDefault', description='mapPreset'),
  }(name='Audio', description='data.audio'),
}

async function getAudioTemplateWithOptions(request: GetAudioTemplateRequest, runtime: Util.RuntimeOptions): GetAudioTemplateResponse {
  Util.validateModel(request);
  return doRequest('GetAudioTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getAudioTemplate(request: GetAudioTemplateRequest): GetAudioTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAudioTemplateWithOptions(request, runtime);
}

model ListAudioTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model ListAudioTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  audios: {
    audio: [
      {
        templateId: string(name='TemplateId', description='templateId'),
        codec: string(name='Codec', description='codec'),
        bitrate: string(name='Bitrate', description='bitrate'),
        channeles: string(name='Channeles', description='mapChannel'),
        remove: string(name='Remove', description='mapRemove'),
        name: string(name='Name', description='name'),
        format: string(name='Format', description='format'),
        status: string(name='Status', description='mapStatus'),
        type: string(name='Type', description='mapType'),
        isDefault: string(name='IsDefault', description='mapPreset'),
      }
    ](name='Audio', description='Audio'),
  }(name='Audios', description='data.audios'),
}

async function listAudioTemplateWithOptions(request: ListAudioTemplateRequest, runtime: Util.RuntimeOptions): ListAudioTemplateResponse {
  Util.validateModel(request);
  return doRequest('ListAudioTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAudioTemplate(request: ListAudioTemplateRequest): ListAudioTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAudioTemplateWithOptions(request, runtime);
}

model ListAudioConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model ListAudioConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  configs: {
    config: [
      {
        templateId: string(name='TemplateId', description='templateId'),
        status: string(name='Status', description='mapStatus'),
      }
    ](name='Config', description='Config'),
  }(name='Configs', description='data.configs'),
}

async function listAudioConfigWithOptions(request: ListAudioConfigRequest, runtime: Util.RuntimeOptions): ListAudioConfigResponse {
  Util.validateModel(request);
  return doRequest('ListAudioConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAudioConfig(request: ListAudioConfigRequest): ListAudioConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAudioConfigWithOptions(request, runtime);
}

model RefreshMaterialWorkFlowRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  customerId: string(name='CustomerId', description='customerId'),
}

model RefreshMaterialWorkFlowResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function refreshMaterialWorkFlowWithOptions(request: RefreshMaterialWorkFlowRequest, runtime: Util.RuntimeOptions): RefreshMaterialWorkFlowResponse {
  Util.validateModel(request);
  return doRequest('RefreshMaterialWorkFlow', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function refreshMaterialWorkFlow(request: RefreshMaterialWorkFlowRequest): RefreshMaterialWorkFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshMaterialWorkFlowWithOptions(request, runtime);
}

model UpdateAudioConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateIds: string(name='TemplateIds', description='templateIds'),
  status: string(name='Status', description='status'),
}

model UpdateAudioConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  configs: {
    config: [
      {
        templateId: string(name='TemplateId', description='templateId'),
        status: string(name='Status', description='mapStatus'),
      }
    ](name='Config', description='Config'),
  }(name='Configs', description='data.configs'),
}

async function updateAudioConfigWithOptions(request: UpdateAudioConfigRequest, runtime: Util.RuntimeOptions): UpdateAudioConfigResponse {
  Util.validateModel(request);
  return doRequest('UpdateAudioConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateAudioConfig(request: UpdateAudioConfigRequest): UpdateAudioConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAudioConfigWithOptions(request, runtime);
}

model UpdateAudioTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  codec: string(name='Codec', description='codec'),
  bitrate: string(name='Bitrate', description='bitrate'),
  channel?: string(name='Channel', description='channel'),
  remove?: string(name='Remove', description='remove'),
  name: string(name='Name', description='name'),
  muxer: string(name='Muxer', description='muxer'),
  status: string(name='Status', description='status'),
  type: string(name='Type', description='type'),
  isDefault: string(name='IsDefault', description='isDefault'),
  templateId: string(name='TemplateId', description='templateId'),
}

model UpdateAudioTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  audio: {
    templateId: string(name='TemplateId', description='templateId'),
    codec: string(name='Codec', description='codec'),
    bitrate: string(name='Bitrate', description='bitrate'),
    channeles: string(name='Channeles', description='mapChannel'),
    remove: string(name='Remove', description='mapRemove'),
    name: string(name='Name', description='name'),
    format: string(name='Format', description='format'),
    status: string(name='Status', description='mapStatus'),
    type: string(name='Type', description='mapType'),
    isDefault: string(name='IsDefault', description='mapPreset'),
  }(name='Audio', description='data.audio'),
}

async function updateAudioTemplateWithOptions(request: UpdateAudioTemplateRequest, runtime: Util.RuntimeOptions): UpdateAudioTemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateAudioTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateAudioTemplate(request: UpdateAudioTemplateRequest): UpdateAudioTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAudioTemplateWithOptions(request, runtime);
}

model AddAudioConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  templateIds: string(name='TemplateIds', description='templateIds'),
  status: string(name='Status', description='status'),
}

model AddAudioConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  configs: {
    config: [
      {
        templateId: string(name='TemplateId', description='templateId'),
        status: string(name='Status', description='mapStatus'),
      }
    ](name='Config', description='Config'),
  }(name='Configs', description='data.configs'),
}

async function addAudioConfigWithOptions(request: AddAudioConfigRequest, runtime: Util.RuntimeOptions): AddAudioConfigResponse {
  Util.validateModel(request);
  return doRequest('AddAudioConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addAudioConfig(request: AddAudioConfigRequest): AddAudioConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAudioConfigWithOptions(request, runtime);
}

model AddAudioTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  codec: string(name='Codec', description='codec'),
  bitrate: string(name='Bitrate', description='bitrate'),
  channel?: string(name='Channel', description='channel'),
  remove?: string(name='Remove', description='remove'),
  name: string(name='Name', description='name'),
  muxer: string(name='Muxer', description='muxer'),
  status: string(name='Status', description='status'),
  type: string(name='Type', description='type'),
  isDefault: string(name='IsDefault', description='isDefault'),
}

model AddAudioTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
  audio: {
    templateId: string(name='TemplateId', description='templateId'),
    codec: string(name='Codec', description='codec'),
    bitrate: string(name='Bitrate', description='bitrate'),
    channeles: string(name='Channeles', description='mapChannel'),
    remove: string(name='Remove', description='mapRemove'),
    name: string(name='Name', description='name'),
    format: string(name='Format', description='format'),
    status: string(name='Status', description='mapStatus'),
    type: string(name='Type', description='mapType'),
    isDefault: string(name='IsDefault', description='mapPreset'),
  }(name='Audio', description='data.audio'),
}

async function addAudioTemplateWithOptions(request: AddAudioTemplateRequest, runtime: Util.RuntimeOptions): AddAudioTemplateResponse {
  Util.validateModel(request);
  return doRequest('AddAudioTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addAudioTemplate(request: AddAudioTemplateRequest): AddAudioTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAudioTemplateWithOptions(request, runtime);
}

model UpdateSpecifyCustomerTemplateConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  transcodeIds: string(name='TranscodeIds', description='transcodeIds'),
  encryptTemplateIds?: string(name='EncryptTemplateIds', description='encryptIds'),
  customerId: string(name='CustomerId', description='customerId'),
}

model UpdateSpecifyCustomerTemplateConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  ret: boolean(name='Ret', description='data.ret'),
}

async function updateSpecifyCustomerTemplateConfigWithOptions(request: UpdateSpecifyCustomerTemplateConfigRequest, runtime: Util.RuntimeOptions): UpdateSpecifyCustomerTemplateConfigResponse {
  Util.validateModel(request);
  return doRequest('UpdateSpecifyCustomerTemplateConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateSpecifyCustomerTemplateConfig(request: UpdateSpecifyCustomerTemplateConfigRequest): UpdateSpecifyCustomerTemplateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSpecifyCustomerTemplateConfigWithOptions(request, runtime);
}

model GetPlayInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  formats?: string(name='Formats', description='formats'),
  authTimeout?: long(name='AuthTimeout', description='authTimeout'),
  rand?: string(name='Rand', description='rand'),
  authInfo?: string(name='AuthInfo', description='authInfo'),
  channel?: string(name='Channel', description='channel'),
  playerVersion?: string(name='PlayerVersion', description='playerVersion'),
  outputType?: string(name='OutputType', description='outputType'),
  streamType?: string(name='StreamType', description='streamType'),
  reAuthInfo?: string(name='ReAuthInfo', description='reAuthInfo'),
  definition?: string(name='Definition', description='definition'),
  resultType?: string(name='ResultType', description='resultType'),
  playConfig?: string(name='PlayConfig', description='playConfig'),
}

model GetPlayInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playInfoList: {
    playInfo: [
      {
        width: long(name='Width', description='width'),
        height: long(name='Height', description='height'),
        size: long(name='Size', description='size'),
        playURL: string(name='PlayURL', description='playURL'),
        bitrate: string(name='Bitrate', description='bitrate'),
        definition: string(name='Definition', description='definition'),
        duration: string(name='Duration', description='duration'),
        format: string(name='Format', description='format'),
        fps: string(name='Fps', description='fps'),
        encrypt: long(name='Encrypt', description='encrypt'),
        plaintext: string(name='Plaintext', description='plaintext'),
        complexity: string(name='Complexity', description='complexity'),
        streamType: string(name='StreamType', description='streamType'),
        rand: string(name='Rand', description='rand'),
        jobId: string(name='JobId', description='jobId'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        watermarkId: string(name='WatermarkId', description='watermarkId'),
        status: string(name='Status', description='status'),
        creationTime: string(name='CreationTime', description='creationTime'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        encryptType: string(name='EncryptType', description='encryptType'),
        narrowBandType: string(name='NarrowBandType', description='narrowBandType'),
      }
    ](name='PlayInfo', description='PlayInfo'),
  }(name='PlayInfoList', description='data.playInfoList'),
  videoBase: {
    outputType: string(name='OutputType', description='outputType'),
    coverURL: string(name='CoverURL', description='coverURL'),
    duration: string(name='Duration', description='duration'),
    status: string(name='Status', description='status'),
    title: string(name='Title', description='title'),
    videoId: string(name='VideoId', description='videoId'),
    mediaType: string(name='MediaType', description='mediaType'),
    creationTime: string(name='CreationTime', description='creationTime'),
    transcodeMode: string(name='TranscodeMode', description='transcodeMode'),
    thumbnailList: {
      thumbnail: [
        {
          URL: string(name='URL', description='url'),
        }
      ](name='Thumbnail', description='Thumbnail'),
    }(name='ThumbnailList', description='thumbnailList'),
  }(name='VideoBase', description='data.videoBase'),
}

async function getPlayInfoWithOptions(request: GetPlayInfoRequest, runtime: Util.RuntimeOptions): GetPlayInfoResponse {
  Util.validateModel(request);
  return doRequest('GetPlayInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getPlayInfo(request: GetPlayInfoRequest): GetPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayInfoWithOptions(request, runtime);
}

model GetVideoConfigRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  authInfo?: string(name='AuthInfo', description='authInfo'),
}

model GetVideoConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  downloadSwitch: string(name='DownloadSwitch', description='data.downloadSwitchDTO.downloadSwitch'),
}

async function getVideoConfigWithOptions(request: GetVideoConfigRequest, runtime: Util.RuntimeOptions): GetVideoConfigResponse {
  Util.validateModel(request);
  return doRequest('GetVideoConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoConfig(request: GetVideoConfigRequest): GetVideoConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoConfigWithOptions(request, runtime);
}

model SetCustomerConfigRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  downloadSwitch?: string(name='DownloadSwitch', description='downloadSwitch'),
  metricConfig?: string(name='MetricConfig', description='metricConfig'),
  AIConfig?: string(name='AIConfig', description='aIConfig'),
}

model SetCustomerConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setCustomerConfigWithOptions(request: SetCustomerConfigRequest, runtime: Util.RuntimeOptions): SetCustomerConfigResponse {
  Util.validateModel(request);
  return doRequest('SetCustomerConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setCustomerConfig(request: SetCustomerConfigRequest): SetCustomerConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCustomerConfigWithOptions(request, runtime);
}

model GetCustomerConfigRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model GetCustomerConfigResponse = {
  requestId: string(name='RequestId', description='requestId'),
  downloadSwitch: string(name='DownloadSwitch', description='data.downloadSwitchDTO.downloadSwitch'),
  metricConfig: string(name='MetricConfig', description='data.downloadSwitchDTO.metricConfig'),
}

async function getCustomerConfigWithOptions(request: GetCustomerConfigRequest, runtime: Util.RuntimeOptions): GetCustomerConfigResponse {
  Util.validateModel(request);
  return doRequest('GetCustomerConfig', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCustomerConfig(request: GetCustomerConfigRequest): GetCustomerConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomerConfigWithOptions(request, runtime);
}

model CreateUploadImageRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  title?: string(name='Title', description='title'),
  imageType: string(name='ImageType', description='imageType'),
  imageExt?: string(name='ImageExt', description='imageExt'),
  originalFileName?: string(name='OriginalFileName', description='originalFileName'),
  tags?: string(name='Tags', description='tags'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  cateId?: long(name='CateId', description='cateId'),
  userData?: string(name='UserData', description='userData'),
  description?: string(name='Description', description='description'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model CreateUploadImageResponse = {
  requestId: string(name='RequestId', description='requestId'),
  imageId: string(name='ImageId', description='data.mediaId'),
  imageURL: string(name='ImageURL', description='data.imageURL'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
}

async function createUploadImageWithOptions(request: CreateUploadImageRequest, runtime: Util.RuntimeOptions): CreateUploadImageResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadImage', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createUploadImage(request: CreateUploadImageRequest): CreateUploadImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadImageWithOptions(request, runtime);
}

model UpdateSnapshotRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  time: string(name='Time', description='time'),
  height?: string(name='Height', description='height'),
  width?: string(name='Width', description='width'),
  number: string(name='Number', description='num'),
  interval?: string(name='Interval', description='interval'),
  snapshotId: string(name='SnapshotId', description='snapshotId'),
}

model UpdateSnapshotResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='result'),
}

async function updateSnapshotWithOptions(request: UpdateSnapshotRequest, runtime: Util.RuntimeOptions): UpdateSnapshotResponse {
  Util.validateModel(request);
  return doRequest('UpdateSnapshot', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateSnapshot(request: UpdateSnapshotRequest): UpdateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSnapshotWithOptions(request, runtime);
}

model RefreshWorkFlowRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  customerId: string(name='CustomerId', description='customerId'),
}

model RefreshWorkFlowResponse = {
  requestId: string(name='RequestId', description='requestId'),
  result: boolean(name='Result', description='data.result'),
}

async function refreshWorkFlowWithOptions(request: RefreshWorkFlowRequest, runtime: Util.RuntimeOptions): RefreshWorkFlowResponse {
  Util.validateModel(request);
  return doRequest('RefreshWorkFlow', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function refreshWorkFlow(request: RefreshWorkFlowRequest): RefreshWorkFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshWorkFlowWithOptions(request, runtime);
}

model AddPipelineRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  customerId: string(name='CustomerId', description='customerId'),
}

model AddPipelineResponse = {
  requestId: string(name='RequestId', description='requestId'),
  pipelineId: string(name='PipelineId', description='data.pipelineId'),
}

async function addPipelineWithOptions(request: AddPipelineRequest, runtime: Util.RuntimeOptions): AddPipelineResponse {
  Util.validateModel(request);
  return doRequest('AddPipeline', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addPipeline(request: AddPipelineRequest): AddPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPipelineWithOptions(request, runtime);
}

model GetCheckChannelRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model GetCheckChannelResponse = {
  requestId: string(name='RequestId', description='requestId'),
  audit: {
    createTime: string(name='CreateTime', description='createTime'),
    updateTime: string(name='UpdateTime', description='updateTime'),
    channel: string(name='Channel', description='channel'),
    customerId: string(name='CustomerId', description='customerId'),
    legalSwitch: string(name='LegalSwitch', description='legalSwitch'),
  }(name='Audit', description='data.audit'),
}

async function getCheckChannelWithOptions(request: GetCheckChannelRequest, runtime: Util.RuntimeOptions): GetCheckChannelResponse {
  Util.validateModel(request);
  return doRequest('GetCheckChannel', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCheckChannel(request: GetCheckChannelRequest): GetCheckChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCheckChannelWithOptions(request, runtime);
}

model SetCheckChannelRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  channel: string(name='Channel', description='channel'),
  legalSwitch?: string(name='LegalSwitch', description='legalSwitch'),
}

model SetCheckChannelResponse = {
  requestId: string(name='RequestId', description='requestId'),
  audit: {
    createTime: string(name='CreateTime', description='createTime'),
    updateTime: string(name='UpdateTime', description='updateTime'),
    channel: string(name='Channel', description='channel'),
    customerId: string(name='CustomerId', description='customerId'),
    legalSwitch: string(name='LegalSwitch', description='legalSwitch'),
  }(name='Audit', description='data.audit'),
}

async function setCheckChannelWithOptions(request: SetCheckChannelRequest, runtime: Util.RuntimeOptions): SetCheckChannelResponse {
  Util.validateModel(request);
  return doRequest('SetCheckChannel', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setCheckChannel(request: SetCheckChannelRequest): SetCheckChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCheckChannelWithOptions(request, runtime);
}

model GetPlayStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime: long(name='StartTime', description='startTime'),
  endTime: long(name='EndTime', description='endTime'),
  type: string(name='Type', description='type'),
  level?: string(name='Level', description='level'),
}

model GetPlayStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playStatisByPlatformDOs: {
    playStatisByPlatform: [
      {
        platform: string(name='Platform', description='platform'),
        playStatisDOs: {
          playStatisDO: [
            {
              userId: string(name='UserId', description='userId'),
              platform: string(name='Platform', description='platform'),
              visitView: long(name='VisitView', description='visitView'),
              viewTime: long(name='ViewTime', description='viewTime'),
              statTime: string(name='StatTime', description='statTimeStr'),
            }
          ](name='PlayStatisDO', description='PlayStatisDO'),
        }(name='PlayStatisDOs', description='playStatisDOs'),
      }
    ](name='PlayStatisByPlatform', description='PlayStatisByPlatform'),
  }(name='PlayStatisByPlatformDOs', description='data.playStatisByPlatformDOs'),
}

async function getPlayStatisWithOptions(request: GetPlayStatisRequest, runtime: Util.RuntimeOptions): GetPlayStatisResponse {
  Util.validateModel(request);
  return doRequest('GetPlayStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getPlayStatis(request: GetPlayStatisRequest): GetPlayStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayStatisWithOptions(request, runtime);
}

model GetMTSStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
  startTimeUTC?: string(name='StartTimeUTC', description='startTimeUTC'),
  endTimeUTC?: string(name='EndTimeUTC', description='endTimeUTC'),
  level?: string(name='Level', description='level'),
  division?: string(name='Division', description='division'),
}

model GetMTSStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  MTSStatisBySpecList: {
    MTSStatisBySpec: [
      {
        specification: string(name='Specification', description='specification'),
        MTSStatisDOList: {
          MTSStatisDO: [
            {
              userId: string(name='UserId', description='userId'),
              specification: string(name='Specification', description='specification'),
              duration: long(name='Duration', description='duration'),
              statTime: string(name='StatTime', description='statTimeStr'),
              statTimeUTC: string(name='StatTimeUTC', description='statTimeUTC'),
            }
          ](name='MTSStatisDO', description='MTSStatisDO'),
        }(name='MTSStatisDOList', description='mtsStatisDOs'),
      }
    ](name='MTSStatisBySpec', description='MTSStatisBySpec'),
  }(name='MTSStatisBySpecList', description='data.mtsStatisBySpecDOs'),
}

async function getMTSStatisWithOptions(request: GetMTSStatisRequest, runtime: Util.RuntimeOptions): GetMTSStatisResponse {
  Util.validateModel(request);
  return doRequest('GetMTSStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMTSStatis(request: GetMTSStatisRequest): GetMTSStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMTSStatisWithOptions(request, runtime);
}

model ListDomainRefererRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  domainName: string(name='DomainName', description='domainName'),
  refererType: string(name='RefererType', description='refererType'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
}

model ListDomainRefererResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  allowEmpty: string(name='AllowEmpty', description='data.allowEmpty'),
  refererList: {
    refererItem: [
      {
        refererId: long(name='RefererId', description='id'),
        referer: string(name='Referer', description='referer'),
        createTime: string(name='CreateTime', description='gmtCreate'),
      }
    ](name='RefererItem', description='RefererItem'),
  }(name='RefererList', description='data.refererDtoList'),
}

async function listDomainRefererWithOptions(request: ListDomainRefererRequest, runtime: Util.RuntimeOptions): ListDomainRefererResponse {
  Util.validateModel(request);
  return doRequest('ListDomainReferer', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listDomainReferer(request: ListDomainRefererRequest): ListDomainRefererResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDomainRefererWithOptions(request, runtime);
}

model SetMessageCallbackRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  callbackSwitch?: string(name='CallbackSwitch', description='callbackSwitch'),
  callbackType?: string(name='CallbackType', description='callbackType'),
  callbackURL: string(name='CallbackURL', description='callbackURL'),
  eventTypeList?: string(name='EventTypeList', description='eventTypeList'),
  authSwitch?: string(name='AuthSwitch', description='authSwitch'),
  authKey?: string(name='AuthKey', description='authKey'),
  mnsEndpoint?: string(name='MnsEndpoint', description='mnsEndpoint'),
  mnsQueueName?: string(name='MnsQueueName', description='mnsQueueName'),
  appId?: string(name='AppId', description='appId'),
}

model SetMessageCallbackResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setMessageCallbackWithOptions(request: SetMessageCallbackRequest, runtime: Util.RuntimeOptions): SetMessageCallbackResponse {
  Util.validateModel(request);
  return doRequest('SetMessageCallback', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setMessageCallback(request: SetMessageCallbackRequest): SetMessageCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return setMessageCallbackWithOptions(request, runtime);
}

model GetMessageCallbackRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  appId?: string(name='AppId', description='appId'),
}

model GetMessageCallbackResponse = {
  requestId: string(name='RequestId', description='requestId'),
  messageCallback: {
    callbackType: string(name='CallbackType', description='callbackType'),
    callbackSwitch: string(name='CallbackSwitch', description='callbackSwitch'),
    callbackURL: string(name='CallbackURL', description='uri'),
    eventTypeList: string(name='EventTypeList', description='eventTypeList'),
    authSwitch: string(name='AuthSwitch', description='authSwitch'),
    authKey: string(name='AuthKey', description='httpAuthKey'),
    mnsEndpoint: string(name='MnsEndpoint', description='mnsEndpoint'),
    mnsQueueName: string(name='MnsQueueName', description='mnsQueueName'),
  }(name='MessageCallback', description='data.userMessageCallbackDTO'),
}

async function getMessageCallbackWithOptions(request: GetMessageCallbackRequest, runtime: Util.RuntimeOptions): GetMessageCallbackResponse {
  Util.validateModel(request);
  return doRequest('GetMessageCallback', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMessageCallback(request: GetMessageCallbackRequest): GetMessageCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMessageCallbackWithOptions(request, runtime);
}

model GetVideoPlayInfoForCloudRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  channel: string(name='Channel', description='channel'),
  clientTS: long(name='ClientTS', description='clientTS'),
  clientVersion: string(name='ClientVersion', description='clientVersion'),
  playSign: string(name='PlaySign', description='playSign'),
  signVersion: string(name='SignVersion', description='signVersion'),
  videoId: string(name='VideoId', description='mediaId'),
}

model GetVideoPlayInfoForCloudResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playInfo: {
    accessKeyId: string(name='AccessKeyId', description='accessKeyId'),
    accessKeySecret: string(name='AccessKeySecret', description='accessKeySecret'),
    authInfo: string(name='AuthInfo', description='authInfo'),
    securityToken: string(name='SecurityToken', description='securityToken'),
    region: string(name='Region', description='region'),
    playDomain: string(name='PlayDomain', description='playDomain'),
  }(name='PlayInfo', description='data.playInfo'),
  videoInfo: {
    coverURL: string(name='CoverURL', description='coverURL'),
    customerId: long(name='CustomerId', description='userId'),
    duration: float(name='Duration', description='duration'),
    status: string(name='Status', description='status'),
    title: string(name='Title', description='title'),
    videoId: string(name='VideoId', description='mediaId'),
  }(name='VideoInfo', description='data.videoInfo'),
}

async function getVideoPlayInfoForCloudWithOptions(request: GetVideoPlayInfoForCloudRequest, runtime: Util.RuntimeOptions): GetVideoPlayInfoForCloudResponse {
  Util.validateModel(request);
  return doRequest('GetVideoPlayInfoForCloud', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoPlayInfoForCloud(request: GetVideoPlayInfoForCloudRequest): GetVideoPlayInfoForCloudResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoPlayInfoForCloudWithOptions(request, runtime);
}

model GetVideoPlayAuthRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='videoId'),
  authInfoTimeout?: long(name='AuthInfoTimeout', description='authInfoTimeout'),
  playConfig?: string(name='PlayConfig', description='playConfig'),
}

model GetVideoPlayAuthResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playAuth: string(name='PlayAuth', description='data.playAuth'),
  videoMeta: {
    coverURL: string(name='CoverURL', description='coverURL'),
    duration: float(name='Duration', description='duration'),
    status: string(name='Status', description='status'),
    title: string(name='Title', description='title'),
    videoId: string(name='VideoId', description='mediaId'),
  }(name='VideoMeta', description='data.videoMeta'),
}

async function getVideoPlayAuthWithOptions(request: GetVideoPlayAuthRequest, runtime: Util.RuntimeOptions): GetVideoPlayAuthResponse {
  Util.validateModel(request);
  return doRequest('GetVideoPlayAuth', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoPlayAuth(request: GetVideoPlayAuthRequest): GetVideoPlayAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoPlayAuthWithOptions(request, runtime);
}

model GetMidYKVidRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  ykVid: string(name='YkVid', description='ykVid'),
}

model GetMidYKVidResponse = {
  requestId: string(name='RequestId', description='requestId'),
  midYKVidDO: {
    mediaId: string(name='MediaId', description='mediaId'),
    ykVid: string(name='YkVid', description='ykVid'),
  }(name='MidYKVidDO', description='data.midYKVidDO'),
}

async function getMidYKVidWithOptions(request: GetMidYKVidRequest, runtime: Util.RuntimeOptions): GetMidYKVidResponse {
  Util.validateModel(request);
  return doRequest('GetMidYKVid', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMidYKVid(request: GetMidYKVidRequest): GetMidYKVidResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMidYKVidWithOptions(request, runtime);
}

model DeleteMidYKVidRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  ykVid: string(name='YkVid', description='ykVid'),
}

model DeleteMidYKVidResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMidYKVidWithOptions(request: DeleteMidYKVidRequest, runtime: Util.RuntimeOptions): DeleteMidYKVidResponse {
  Util.validateModel(request);
  return doRequest('DeleteMidYKVid', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteMidYKVid(request: DeleteMidYKVidRequest): DeleteMidYKVidResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMidYKVidWithOptions(request, runtime);
}

model AddMidYKVidRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  YKCloudVid: string(name='YKCloudVid', description='ykCloudVid'),
  mediaId: string(name='MediaId', description='mediaId'),
  YKVideoId?: string(name='YKVideoId', description='ykVideoId'),
}

model AddMidYKVidResponse = {
  requestId: string(name='RequestId', description='requestId'),
  midYKVidDO: {
    mediaId: string(name='MediaId', description='mediaId'),
    YKCloudVid: string(name='YKCloudVid', description='ykVid'),
    YKVideoId: string(name='YKVideoId', description='ykVideoId'),
  }(name='MidYKVidDO', description='data.midYKVidDO'),
}

async function addMidYKVidWithOptions(request: AddMidYKVidRequest, runtime: Util.RuntimeOptions): AddMidYKVidResponse {
  Util.validateModel(request);
  return doRequest('AddMidYKVid', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addMidYKVid(request: AddMidYKVidRequest): AddMidYKVidResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMidYKVidWithOptions(request, runtime);
}

model UpdateVideoStatusRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  status: string(name='status', description='state'),
}

model UpdateVideoStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateVideoStatusWithOptions(request: UpdateVideoStatusRequest, runtime: Util.RuntimeOptions): UpdateVideoStatusResponse {
  Util.validateModel(request);
  return doRequest('UpdateVideoStatus', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateVideoStatus(request: UpdateVideoStatusRequest): UpdateVideoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVideoStatusWithOptions(request, runtime);
}

model UpdateVideoInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  title?: string(name='Title', description='title'),
  tags?: string(name='Tags', description='tags'),
  description?: string(name='Description', description='description'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  cateId?: long(name='CateId', description='cateId'),
  downloadSwitch?: string(name='DownloadSwitch', description='downloadSwitch'),
  fileSize?: long(name='FileSize', description='fileSize'),
  duration?: string(name='Duration', description='duration'),
  status?: string(name='Status', description='status'),
  mediaType?: string(name='MediaType', description='type'),
  source?: string(name='Source', description='source'),
}

model UpdateVideoInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateVideoInfoWithOptions(request: UpdateVideoInfoRequest, runtime: Util.RuntimeOptions): UpdateVideoInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateVideoInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateVideoInfo(request: UpdateVideoInfoRequest): UpdateVideoInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVideoInfoWithOptions(request, runtime);
}

model SearchVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  cateId?: integer(name='CateId', description='cateId'),
  title?: string(name='Title', description='title'),
  keyWord?: string(name='KeyWord', description='keyWord'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  status?: string(name='Status', description='state'),
  mediaType?: string(name='MediaType', description='type'),
  resultTypes?: string(name='ResultTypes', description='resultTypes'),
  playRand?: string(name='PlayRand', description='playRand'),
  source?: string(name='Source', description='source'),
  apiVersion?: string(name='ApiVersion', description='version'),
  scrollToken?: string(name='ScrollToken', description='lastItem'),
  preprocessStatus?: string(name='PreprocessStatus', description='preprocessStatus'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  videoId?: string(name='VideoId', description='videoId'),
}

model SearchVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  scrollToken: string(name='ScrollToken', description='data.lastItem'),
  total: integer(name='Total', description='data.total'),
  videoList: {
    video: [
      {
        videoId: string(name='VideoId', description='mediaId'),
        source: string(name='Source', description='source'),
        mediaType: string(name='MediaType', description='type'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreate'),
        modifyTime: string(name='ModifyTime', description='gmtModified'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        downloadSwitch: string(name='DownloadSwitch', description='download'),
        preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
        storageLocation: string(name='StorageLocation', description='storageLocation'),
        regionId: string(name='RegionId', description='regionId'),
        playInfoList: {
          playInfo: [
            {
              width: long(name='Width', description='width'),
              height: long(name='Height', description='height'),
              size: long(name='Size', description='size'),
              playURL: string(name='PlayURL', description='playURL'),
              bitrate: string(name='Bitrate', description='bitrate'),
              definition: string(name='Definition', description='definition'),
              duration: string(name='Duration', description='duration'),
              format: string(name='Format', description='format'),
              fps: string(name='Fps', description='fps'),
              encrypt: long(name='Encrypt', description='encrypt'),
              plaintext: string(name='Plaintext', description='plaintext'),
              complexity: string(name='Complexity', description='complexity'),
              streamType: string(name='StreamType', description='streamType'),
              rand: string(name='Rand', description='rand'),
              jobId: string(name='JobId', description='jobId'),
            }
          ](name='PlayInfo', description='PlayInfo'),
        }(name='PlayInfoList', description='playInfoList'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshots'),
        spriteSnapshots: {
          spriteSnapshot: [ string ](name='SpriteSnapshot', description='SpriteSnapshot'),
        }(name='SpriteSnapshots', description='spriteImages'),
      }
    ](name='Video', description='Video'),
  }(name='VideoList', description='data.aMediaList'),
}

async function searchVideoWithOptions(request: SearchVideoRequest, runtime: Util.RuntimeOptions): SearchVideoResponse {
  Util.validateModel(request);
  return doRequest('SearchVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function searchVideo(request: SearchVideoRequest): SearchVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchVideoWithOptions(request, runtime);
}

model RefreshUploadVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
}

model RefreshUploadVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  videoId: string(name='VideoId', description='data.videoId'),
}

async function refreshUploadVideoWithOptions(request: RefreshUploadVideoRequest, runtime: Util.RuntimeOptions): RefreshUploadVideoResponse {
  Util.validateModel(request);
  return doRequest('RefreshUploadVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function refreshUploadVideo(request: RefreshUploadVideoRequest): RefreshUploadVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshUploadVideoWithOptions(request, runtime);
}

model GetVideoListRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  cateId?: long(name='CateId', description='cateId'),
  status?: string(name='Status', description='status'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
}

model GetVideoListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  videoList: {
    video: [
      {
        videoId: string(name='VideoId', description='mediaId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        duration: float(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        createTime: string(name='CreateTime', description='gmtCreate'),
        modifyTime: string(name='ModifyTime', description='gmtModified'),
        modificationTime: string(name='ModificationTime', description='modificationTime'),
        creationTime: string(name='CreationTime', description='creationTime'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: long(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshots'),
      }
    ](name='Video', description='Video'),
  }(name='VideoList', description='data.aMediaList'),
}

async function getVideoListWithOptions(request: GetVideoListRequest, runtime: Util.RuntimeOptions): GetVideoListResponse {
  Util.validateModel(request);
  return doRequest('GetVideoList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoList(request: GetVideoListRequest): GetVideoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoListWithOptions(request, runtime);
}

model GetVideoInfoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  resultTypes?: string(name='ResultTypes', description='resultTypes'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetVideoInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  AI: string(name='AI', description='data.aiResult'),
  video: {
    videoId: string(name='VideoId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
    status: string(name='Status', description='state'),
    size: long(name='Size', description='fileSize'),
    duration: float(name='Duration', description='duration'),
    description: string(name='Description', description='description'),
    createTime: string(name='CreateTime', description='gmtCreate'),
    modifyTime: string(name='ModifyTime', description='gmtModified'),
    modificationTime: string(name='ModificationTime', description='modificationTime'),
    creationTime: string(name='CreationTime', description='creationTime'),
    coverURL: string(name='CoverURL', description='coverUrl'),
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    downloadSwitch: string(name='DownloadSwitch', description='download'),
    templateGroupId: string(name='TemplateGroupId', description='templateGroupId'),
    preprocessStatus: string(name='PreprocessStatus', description='preprocessStatus'),
    storageLocation: string(name='StorageLocation', description='storageLocation'),
    regionId: string(name='RegionId', description='regionId'),
    customMediaInfo: string(name='CustomMediaInfo', description='customMediaInfo'),
    customerId: long(name='CustomerId', description='userId'),
    thumbnailList: {
      thumbnail: [
        {
          URL: string(name='URL', description='url'),
        }
      ](name='Thumbnail', description='Thumbnail'),
    }(name='ThumbnailList', description='thumbnailList'),
    snapshots: {
      snapshot: [ string ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshots'),
  }(name='Video', description='data.mediaInfo'),
}

async function getVideoInfoWithOptions(request: GetVideoInfoRequest, runtime: Util.RuntimeOptions): GetVideoInfoResponse {
  Util.validateModel(request);
  return doRequest('GetVideoInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoInfo(request: GetVideoInfoRequest): GetVideoInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoInfoWithOptions(request, runtime);
}

model GetCategoryTreeRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model GetCategoryTreeResponse = {
  requestId: string(name='RequestId', description='requestId'),
  categoryTree: string(name='CategoryTree', description='data.categoryTree'),
}

async function getCategoryTreeWithOptions(request: GetCategoryTreeRequest, runtime: Util.RuntimeOptions): GetCategoryTreeResponse {
  Util.validateModel(request);
  return doRequest('GetCategoryTree', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCategoryTree(request: GetCategoryTreeRequest): GetCategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCategoryTreeWithOptions(request, runtime);
}

model GetCategoryListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model GetCategoryListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  categoryList: {
    category: [
      {
        cateId: string(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        parentId: string(name='ParentId', description='parentId'),
        level: string(name='Level', description='level'),
      }
    ](name='Category', description='Category'),
  }(name='CategoryList', description='data.categoryList'),
}

async function getCategoryListWithOptions(request: GetCategoryListRequest, runtime: Util.RuntimeOptions): GetCategoryListResponse {
  Util.validateModel(request);
  return doRequest('GetCategoryList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCategoryList(request: GetCategoryListRequest): GetCategoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCategoryListWithOptions(request, runtime);
}

model DeleteVideoTagRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  tag: string(name='Tag', description='tag'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model DeleteVideoTagResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaInfoDTO: {
    userId: long(name='UserId', description='userId'),
    mediaId: string(name='MediaId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
  }(name='MediaInfoDTO', description='data.mediaInfoDTO'),
}

async function deleteVideoTagWithOptions(request: DeleteVideoTagRequest, runtime: Util.RuntimeOptions): DeleteVideoTagResponse {
  Util.validateModel(request);
  return doRequest('DeleteVideoTag', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteVideoTag(request: DeleteVideoTagRequest): DeleteVideoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoTagWithOptions(request, runtime);
}

model DeleteVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIdStr'),
}

model DeleteVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteVideoWithOptions(request: DeleteVideoRequest, runtime: Util.RuntimeOptions): DeleteVideoResponse {
  Util.validateModel(request);
  return doRequest('DeleteVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoWithOptions(request, runtime);
}

model CreateUploadVideoRequest = {
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  description?: string(name='Description', description='description'),
  fileName: string(name='FileName', description='fileName'),
  fileSize?: long(name='FileSize', description='fileSize'),
  IP?: string(name='IP', description='createIp'),
  title: string(name='Title', description='title'),
  cateId?: long(name='CateId', description='cateId'),
  tags?: string(name='Tags', description='tags'),
  userData?: string(name='UserData', description='userData'),
  templateGroupId?: string(name='TemplateGroupId', description='templateGroupId'),
  workflowId?: string(name='WorkflowId', description='workflowId'),
  storageLocation?: string(name='StorageLocation', description='storageLocation'),
  appId?: string(name='AppId', description='appId'),
}

model CreateUploadVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoId: string(name='VideoId', description='data.mediaInfo.mediaId'),
  uploadAddress: string(name='UploadAddress', description='data.uploadAddress'),
  uploadAuth: string(name='UploadAuth', description='data.uploadAuth'),
}

async function createUploadVideoWithOptions(request: CreateUploadVideoRequest, runtime: Util.RuntimeOptions): CreateUploadVideoResponse {
  Util.validateModel(request);
  return doRequest('CreateUploadVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function createUploadVideo(request: CreateUploadVideoRequest): CreateUploadVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadVideoWithOptions(request, runtime);
}

model CheckVideoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIds'),
  checkStatus: string(name='CheckStatus', description='checkState'),
  checkReason?: string(name='CheckReason', description='checkReason'),
}

model CheckVideoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  failedList: {
    string: [ string ](name='String', description='String'),
  }(name='FailedList', description='checkFailed'),
}

async function checkVideoWithOptions(request: CheckVideoRequest, runtime: Util.RuntimeOptions): CheckVideoResponse {
  Util.validateModel(request);
  return doRequest('CheckVideo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function checkVideo(request: CheckVideoRequest): CheckVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkVideoWithOptions(request, runtime);
}

model AddVideoTagRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  tag: string(name='Tag', description='tag'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model AddVideoTagResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaInfoDTO: {
    userId: long(name='UserId', description='userId'),
    mediaId: string(name='MediaId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
  }(name='MediaInfoDTO', description='data.mediaInfoDTO'),
}

async function addVideoTagWithOptions(request: AddVideoTagRequest, runtime: Util.RuntimeOptions): AddVideoTagResponse {
  Util.validateModel(request);
  return doRequest('AddVideoTag', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addVideoTag(request: AddVideoTagRequest): AddVideoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return addVideoTagWithOptions(request, runtime);
}

model AddApiAuthRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  state?: integer(name='State', description='state'),
  playKey: string(name='PlayKey', description='apiKey'),
  expireTime?: string(name='ExpireTime', description='expireTime'),
  signVersion: string(name='SignVersion', description='signVersion'),
  channel: string(name='Channel', description='channel'),
  description: string(name='Description', description='description'),
  clientVersion: string(name='ClientVersion', description='clientVersion'),
  source: string(name='Source', description='source'),
}

model AddApiAuthResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addApiAuthWithOptions(request: AddApiAuthRequest, runtime: Util.RuntimeOptions): AddApiAuthResponse {
  Util.validateModel(request);
  return doRequest('AddApiAuth', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addApiAuth(request: AddApiAuthRequest): AddApiAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return addApiAuthWithOptions(request, runtime);
}

model GetPlayChannelKeyRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  signVersion: string(name='SignVersion', description='signVersion'),
  channel: string(name='Channel', description='channel'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetPlayChannelKeyResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playKey: string(name='PlayKey', description='data.apiAuth.apiKey'),
}

async function getPlayChannelKeyWithOptions(request: GetPlayChannelKeyRequest, runtime: Util.RuntimeOptions): GetPlayChannelKeyResponse {
  Util.validateModel(request);
  return doRequest('GetPlayChannelKey', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getPlayChannelKey(request: GetPlayChannelKeyRequest): GetPlayChannelKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayChannelKeyWithOptions(request, runtime);
}

model GetDomainListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model GetDomainListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  domainDTOList: {
    domainDTO: [
      {
        userId: long(name='UserId', description='userId'),
        domainName: string(name='DomainName', description='domainName'),
        domainType: string(name='DomainType', description='domainType'),
        domainCname: string(name='DomainCname', description='domainCname'),
        domainStatus: string(name='DomainStatus', description='domainStatus'),
        bucketName: string(name='BucketName', description='bucketName'),
        bucketEndpoint: string(name='BucketEndpoint', description='bucketEndpoint'),
        defaultPlay: boolean(name='DefaultPlay', description='defaultPlay'),
        sourceLocation: string(name='SourceLocation', description='sourceLocation'),
      }
    ](name='DomainDTO', description='DomainDTO'),
  }(name='DomainDTOList', description='data.domainDTOList'),
}

async function getDomainListWithOptions(request: GetDomainListRequest, runtime: Util.RuntimeOptions): GetDomainListResponse {
  Util.validateModel(request);
  return doRequest('GetDomainList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getDomainList(request: GetDomainListRequest): GetDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainListWithOptions(request, runtime);
}

model GetServiceStatusRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetServiceStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
  status: integer(name='status', description='data.status'),
  serviceState: integer(name='serviceState', description='data.serviceState'),
  instanceId: string(name='InstanceId', description='data.instanceId'),
  chargeType: integer(name='ChargeType', description='data.chargeType'),
  changingChargeType: string(name='ChangingChargeType', description='data.changingChargeType'),
  changingAfterTime: string(name='ChangingAfterTime', description='data.changingAfterTime'),
}

async function getServiceStatusWithOptions(request: GetServiceStatusRequest, runtime: Util.RuntimeOptions): GetServiceStatusResponse {
  Util.validateModel(request);
  return doRequest('GetServiceStatus', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getServiceStatus(request: GetServiceStatusRequest): GetServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceStatusWithOptions(request, runtime);
}

model NotifyProduceRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  data: string(name='data', description='data'),
}

model NotifyProduceResponse = {
  requestId: string(name='requestId', description='requestId'),
  success: boolean(name='success', description='success'),
  code: string(name='code', description='code'),
  message: string(name='message', description='message'),
  data: string(name='data', description='data'),
}

async function notifyProduceWithOptions(request: NotifyProduceRequest, runtime: Util.RuntimeOptions): NotifyProduceResponse {
  Util.validateModel(request);
  return doRequest('NotifyProduce', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function notifyProduce(request: NotifyProduceRequest): NotifyProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyProduceWithOptions(request, runtime);
}

model NotifyInitResourceRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model NotifyInitResourceResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function notifyInitResourceWithOptions(request: NotifyInitResourceRequest, runtime: Util.RuntimeOptions): NotifyInitResourceResponse {
  Util.validateModel(request);
  return doRequest('NotifyInitResource', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function notifyInitResource(request: NotifyInitResourceRequest): NotifyInitResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyInitResourceWithOptions(request, runtime);
}

model GetPlayChannelListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  state?: integer(name='State', description='state'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model GetPlayChannelListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  playKeyList: {
    playKey: [
      {
        channel: string(name='Channel', description='channel'),
        createTime: string(name='CreateTime', description='gmtCreate'),
        modifyTime: string(name='ModifyTime', description='gmtModified'),
        signVersion: string(name='SignVersion', description='signVersion'),
        description: string(name='Description', description='description'),
        clientVersion: string(name='ClientVersion', description='clientVersion'),
        status: string(name='Status', description='state'),
        source: string(name='Source', description='source'),
      }
    ](name='PlayKey', description='PlayKey'),
  }(name='PlayKeyList', description='data.apiAuthList'),
}

async function getPlayChannelListWithOptions(request: GetPlayChannelListRequest, runtime: Util.RuntimeOptions): GetPlayChannelListResponse {
  Util.validateModel(request);
  return doRequest('GetPlayChannelList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getPlayChannelList(request: GetPlayChannelListRequest): GetPlayChannelListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPlayChannelListWithOptions(request, runtime);
}

model UpdateApiAuthRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  state?: integer(name='State', description='state'),
  expireTime?: string(name='ExpireTime', description='expireTime'),
  signVersion: string(name='SignVersion', description='signVersion'),
  channel: string(name='Channel', description='channel'),
  description?: string(name='Description', description='description'),
  clientVersion?: string(name='ClientVersion', description='clientVersion'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model UpdateApiAuthResponse = {
  requestId: string(name='RequestId', description='requestId'),
  apiAuth: {
    createTime: string(name='CreateTime', description='gmtCreate'),
    modifyTime: string(name='ModifyTime', description='gmtModified'),
    status: integer(name='Status', description='state'),
    expireTime: string(name='ExpireTime', description='expireTime'),
    signVersion: string(name='SignVersion', description='signVersion'),
    channel: string(name='Channel', description='channel'),
    description: string(name='Description', description='description'),
    clientVersion: string(name='ClientVersion', description='clientVersion'),
  }(name='ApiAuth', description='data.apiAuthDto'),
}

async function updateApiAuthWithOptions(request: UpdateApiAuthRequest, runtime: Util.RuntimeOptions): UpdateApiAuthResponse {
  Util.validateModel(request);
  return doRequest('UpdateApiAuth', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateApiAuth(request: UpdateApiAuthRequest): UpdateApiAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApiAuthWithOptions(request, runtime);
}

model UserExistRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model UserExistResponse = {
  requestId: string(name='RequestId', description='requestId'),
  userState: integer(name='userState', description='data.userState'),
}

async function userExistWithOptions(request: UserExistRequest, runtime: Util.RuntimeOptions): UserExistResponse {
  Util.validateModel(request);
  return doRequest('UserExist', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function userExist(request: UserExistRequest): UserExistResponse {
  var runtime = new Util.RuntimeOptions{};
  return userExistWithOptions(request, runtime);
}

model AddMediaInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
  title: string(name='Title', description='title'),
  tags?: string(name='Tags', description='tags'),
  privilege?: integer(name='Privilege', description='publicType'),
  IP?: string(name='IP', description='createIp'),
  fileSize?: long(name='FileSize', description='fileSize'),
  duration?: long(name='Duration', description='duration'),
  fileName: string(name='FileName', description='fileName'),
  fileMd5?: string(name='FileMd5', description='fileMd5'),
  description?: string(name='Description', description='description'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  cateId?: integer(name='CateId', description='cateId'),
  mediaWorkflowId?: string(name='MediaWorkflowId', description='mediaWorkflowId'),
  mediaWorkflowUserData?: string(name='MediaWorkflowUserData', description='mediaWorkflowUserData'),
  mediaWorkflowRunId?: string(name='MediaWorkflowRunId', description='mediaWorkflowRunId'),
}

model AddMediaInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoId: string(name='VideoId', description='data.mediaInfo.mediaId'),
  uploadKey: string(name='UploadKey', description='data.uploadKey'),
  uploadAddress: {
    accessKeyId: string(name='AccessKeyId', description='accessKeyId'),
    accessKeySecret: string(name='AccessKeySecret', description='accessKeySecret'),
    bucket: string(name='Bucket', description='bucket'),
    endPoint: string(name='EndPoint', description='endpoint'),
    expiration: string(name='Expiration', description='expiration'),
    fileName: string(name='FileName', description='fileName'),
    securityToken: string(name='SecurityToken', description='securityToken'),
  }(name='UploadAddress', description='data.uploadAddressDO'),
}

async function addMediaInfoWithOptions(request: AddMediaInfoRequest, runtime: Util.RuntimeOptions): AddMediaInfoResponse {
  Util.validateModel(request);
  return doRequest('AddMediaInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addMediaInfo(request: AddMediaInfoRequest): AddMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaInfoWithOptions(request, runtime);
}

model AddCategoryRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  cateName: string(name='CateName', description='cateName'),
  parentId?: long(name='ParentId', description='parentId'),
  type?: string(name='Type', description='type'),
}

model AddCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  category: {
    cateId: long(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    parentId: long(name='ParentId', description='parentId'),
    level: long(name='Level', description='level'),
    type: string(name='Type', description='type'),
  }(name='Category', description='data.category'),
}

async function addCategoryWithOptions(request: AddCategoryRequest, runtime: Util.RuntimeOptions): AddCategoryResponse {
  Util.validateModel(request);
  return doRequest('AddCategory', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCategoryWithOptions(request, runtime);
}

model DeleteCategoryRequest = {
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  cateId: long(name='CateId', description='cateId'),
}

model DeleteCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: Util.RuntimeOptions): DeleteCategoryResponse {
  Util.validateModel(request);
  return doRequest('DeleteCategory', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCategoryWithOptions(request, runtime);
}

model UpdateMediaInfoStatusRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
  status: string(name='status', description='state'),
}

model UpdateMediaInfoStatusResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateMediaInfoStatusWithOptions(request: UpdateMediaInfoStatusRequest, runtime: Util.RuntimeOptions): UpdateMediaInfoStatusResponse {
  Util.validateModel(request);
  return doRequest('UpdateMediaInfoStatus', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateMediaInfoStatus(request: UpdateMediaInfoStatusRequest): UpdateMediaInfoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaInfoStatusWithOptions(request, runtime);
}

model CategoryTreeRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model CategoryTreeResponse = {
  requestId: string(name='RequestId', description='requestId'),
  categoryTree: string(name='CategoryTree', description='data.categoryTree'),
}

async function categoryTreeWithOptions(request: CategoryTreeRequest, runtime: Util.RuntimeOptions): CategoryTreeResponse {
  Util.validateModel(request);
  return doRequest('CategoryTree', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function categoryTree(request: CategoryTreeRequest): CategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return categoryTreeWithOptions(request, runtime);
}

model AddMediaTagRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  tag: string(name='Tag', description='tag'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model AddMediaTagResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaInfoDTO: {
    userId: long(name='UserId', description='userId'),
    mediaId: string(name='MediaId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
  }(name='MediaInfoDTO', description='data.mediaInfoDTO'),
}

async function addMediaTagWithOptions(request: AddMediaTagRequest, runtime: Util.RuntimeOptions): AddMediaTagResponse {
  Util.validateModel(request);
  return doRequest('AddMediaTag', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addMediaTag(request: AddMediaTagRequest): AddMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaTagWithOptions(request, runtime);
}

model GetCDNStatisSumRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
  startTimeUTC?: string(name='StartTimeUTC', description='startTimeUTC'),
  endTimeUTC?: string(name='EndTimeUTC', description='endTimeUTC'),
  level?: string(name='Level', description='level'),
  levelRule?: string(name='LevelRule', description='levelRule'),
  domainName?: string(name='DomainName', description='domainName'),
}

model GetCDNStatisSumResponse = {
  requestId: string(name='RequestId', description='requestId'),
  sumFlowDataValue: long(name='SumFlowDataValue', description='data.sumFlowDataValue'),
  maxBpsDataValue: long(name='MaxBpsDataValue', description='data.maxBpsDataValue'),
  current95BpsDataValue: long(name='Current95BpsDataValue', description='data.current95BpsDataValue'),
  level: string(name='Level', description='data.level'),
  CDNStatisList: {
    CDNMetric: [
      {
        statTime: string(name='StatTime', description='statTimeStr'),
        statTimeUTC: string(name='StatTimeUTC', description='statTimeUTC'),
        flowDataDomesticValue: long(name='FlowDataDomesticValue', description='flowDataDomesticValue'),
        flowDataOverseasValue: long(name='FlowDataOverseasValue', description='flowDataOverseasValue'),
        flowDataValue: long(name='FlowDataValue', description='flowDataValue'),
        bpsDataDomesticValue: long(name='BpsDataDomesticValue', description='bpsDataDomesticValue'),
        bpsDataOverseasValue: long(name='BpsDataOverseasValue', description='bpsDataOverseasValue'),
        bpsDataValue: long(name='BpsDataValue', description='bpsDataValue'),
      }
    ](name='CDNMetric', description='CDNMetric'),
  }(name='CDNStatisList', description='data.cdnStatisList'),
}

async function getCDNStatisSumWithOptions(request: GetCDNStatisSumRequest, runtime: Util.RuntimeOptions): GetCDNStatisSumResponse {
  Util.validateModel(request);
  return doRequest('GetCDNStatisSum', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCDNStatisSum(request: GetCDNStatisSumRequest): GetCDNStatisSumResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCDNStatisSumWithOptions(request, runtime);
}

model GetCDNStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime: long(name='StartTime', description='startTime'),
  endTime: long(name='EndTime', description='endTime'),
  level?: string(name='Level', description='level'),
}

model GetCDNStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  sumFlowDataValue: long(name='SumFlowDataValue', description='data.sumFlowDataValue'),
  maxBpsDataValue: long(name='MaxBpsDataValue', description='data.maxBpsDataValue'),
  current95BpsDataValue: long(name='Current95BpsDataValue', description='data.current95BpsDataValue'),
  CDNStatisList: {
    CDNMetric: [
      {
        cdnDomain: string(name='CdnDomain', description='cdnDomain'),
        statTime: string(name='StatTime', description='statTimeStr'),
        flowDataDomesticValue: long(name='FlowDataDomesticValue', description='flowDataDomesticValue'),
        flowDataOverseasValue: long(name='FlowDataOverseasValue', description='flowDataOverseasValue'),
        flowDataValue: long(name='FlowDataValue', description='flowDataValue'),
        bpsDataDomesticValue: long(name='BpsDataDomesticValue', description='bpsDataDomesticValue'),
        bpsDataOverseasValue: long(name='BpsDataOverseasValue', description='bpsDataOverseasValue'),
        bpsDataValue: long(name='BpsDataValue', description='bpsDataValue'),
      }
    ](name='CDNMetric', description='CDNMetric'),
  }(name='CDNStatisList', description='data.cdnStatisList'),
}

async function getCDNStatisWithOptions(request: GetCDNStatisRequest, runtime: Util.RuntimeOptions): GetCDNStatisResponse {
  Util.validateModel(request);
  return doRequest('GetCDNStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCDNStatis(request: GetCDNStatisRequest): GetCDNStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCDNStatisWithOptions(request, runtime);
}

model DeleteMediaTagRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  tag: string(name='Tag', description='tag'),
  mediaId: string(name='MediaId', description='mediaId'),
}

model DeleteMediaTagResponse = {
  requestId: string(name='RequestId', description='requestId'),
  mediaInfoDTO: {
    userId: long(name='UserId', description='userId'),
    mediaId: string(name='MediaId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
  }(name='MediaInfoDTO', description='data.mediaInfoDTO'),
}

async function deleteMediaTagWithOptions(request: DeleteMediaTagRequest, runtime: Util.RuntimeOptions): DeleteMediaTagResponse {
  Util.validateModel(request);
  return doRequest('DeleteMediaTag', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteMediaTag(request: DeleteMediaTagRequest): DeleteMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaTagWithOptions(request, runtime);
}

model DeleteMediaInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoIds: string(name='VideoIds', description='mediaIdStr'),
}

model DeleteMediaInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteMediaInfoWithOptions(request: DeleteMediaInfoRequest, runtime: Util.RuntimeOptions): DeleteMediaInfoResponse {
  Util.validateModel(request);
  return doRequest('DeleteMediaInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteMediaInfo(request: DeleteMediaInfoRequest): DeleteMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaInfoWithOptions(request, runtime);
}

model GetOSSStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  startTime?: long(name='StartTime', description='startTime'),
  endTime?: long(name='EndTime', description='endTime'),
  startTimeUTC?: string(name='StartTimeUTC', description='startTimeUTC'),
  endTimeUTC?: string(name='EndTimeUTC', description='endTimeUTC'),
  level?: string(name='Level', description='level'),
  division?: string(name='Division', description='division'),
}

model GetOSSStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  maxStorageUtilization: long(name='MaxStorageUtilization', description='data.maxStorageUtilization'),
  ossStatisList: {
    OSSMetric: [
      {
        statTime: string(name='StatTime', description='statTimeStr'),
        statTimeUTC: string(name='StatTimeUTC', description='statTimeUTC'),
        storageUtilization: long(name='StorageUtilization', description='storageUtilization'),
      }
    ](name='OSSMetric', description='OSSMetric'),
  }(name='OssStatisList', description='data.ossStatisList'),
}

async function getOSSStatisWithOptions(request: GetOSSStatisRequest, runtime: Util.RuntimeOptions): GetOSSStatisResponse {
  Util.validateModel(request);
  return doRequest('GetOSSStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getOSSStatis(request: GetOSSStatisRequest): GetOSSStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOSSStatisWithOptions(request, runtime);
}

model GetVideoPlayInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  channel: string(name='Channel', description='channel'),
  clientTS: long(name='ClientTS', description='clientTS'),
  clientVersion: string(name='ClientVersion', description='clientVersion'),
  playSign: string(name='PlaySign', description='playSign'),
  signVersion: string(name='SignVersion', description='signVersion'),
  videoId: string(name='VideoId', description='mediaId'),
}

model GetVideoPlayInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  playInfo: {
    accessKeyId: string(name='AccessKeyId', description='accessKeyId'),
    accessKeySecret: string(name='AccessKeySecret', description='accessKeySecret'),
    authInfo: string(name='AuthInfo', description='authInfo'),
    securityToken: string(name='SecurityToken', description='securityToken'),
    region: string(name='Region', description='region'),
    playDomain: string(name='PlayDomain', description='playDomain'),
  }(name='PlayInfo', description='data.playInfo'),
  videoInfo: {
    coverURL: string(name='CoverURL', description='coverURL'),
    customerId: long(name='CustomerId', description='userId'),
    duration: float(name='Duration', description='duration'),
    status: string(name='Status', description='status'),
    title: string(name='Title', description='title'),
    videoId: string(name='VideoId', description='mediaId'),
  }(name='VideoInfo', description='data.videoInfo'),
}

async function getVideoPlayInfoWithOptions(request: GetVideoPlayInfoRequest, runtime: Util.RuntimeOptions): GetVideoPlayInfoResponse {
  Util.validateModel(request);
  return doRequest('GetVideoPlayInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getVideoPlayInfo(request: GetVideoPlayInfoRequest): GetVideoPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoPlayInfoWithOptions(request, runtime);
}

model GetMediaInfoListRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  cateId?: integer(name='CateId', description='cateId'),
  status?: string(name='Status', description='status'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
}

model GetMediaInfoListResponse = {
  requestId: string(name='RequestId', description='requestId'),
  videoList: {
    mediaInfo: [
      {
        videoId: string(name='VideoId', description='mediaId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        privilege: integer(name='Privilege', description='publicType'),
        duration: long(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreate'),
        modifyTime: string(name='ModifyTime', description='gmtModified'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshots'),
      }
    ](name='MediaInfo', description='MediaInfo'),
  }(name='VideoList', description='data.aMediaList'),
}

async function getMediaInfoListWithOptions(request: GetMediaInfoListRequest, runtime: Util.RuntimeOptions): GetMediaInfoListResponse {
  Util.validateModel(request);
  return doRequest('GetMediaInfoList', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaInfoList(request: GetMediaInfoListRequest): GetMediaInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaInfoListWithOptions(request, runtime);
}

model GetMediaInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
}

model GetMediaInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  video: {
    videoId: string(name='VideoId', description='mediaId'),
    title: string(name='Title', description='title'),
    tags: string(name='Tags', description='tags'),
    status: string(name='Status', description='state'),
    size: long(name='Size', description='fileSize'),
    privilege: integer(name='Privilege', description='publicType'),
    duration: long(name='Duration', description='duration'),
    description: string(name='Description', description='description'),
    customerId: long(name='CustomerId', description='userId'),
    createTime: string(name='CreateTime', description='gmtCreate'),
    modifyTime: string(name='ModifyTime', description='gmtModified'),
    coverURL: string(name='CoverURL', description='coverUrl'),
    cateId: integer(name='CateId', description='cateId'),
    snapshots: {
      snapshot: [ string ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshots'),
  }(name='Video', description='data.mediaInfo'),
}

async function getMediaInfoWithOptions(request: GetMediaInfoRequest, runtime: Util.RuntimeOptions): GetMediaInfoResponse {
  Util.validateModel(request);
  return doRequest('GetMediaInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getMediaInfo(request: GetMediaInfoRequest): GetMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaInfoWithOptions(request, runtime);
}

model SearchMediaInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  cateId?: integer(name='CateId', description='cateId'),
  title?: string(name='Title', description='title'),
  keyWord?: string(name='KeyWord', description='keyWord'),
  startTime?: string(name='StartTime', description='startTime'),
  endTime?: string(name='EndTime', description='endTime'),
  pageNo?: integer(name='PageNo', description='pageNo'),
  pageSize?: integer(name='PageSize', description='pageSize'),
  sortBy?: string(name='SortBy', description='sortBy'),
  status?: string(name='Status', description='state'),
}

model SearchMediaInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
  total: integer(name='Total', description='data.total'),
  videoList: {
    mediaInfo: [
      {
        videoId: string(name='VideoId', description='mediaId'),
        title: string(name='Title', description='title'),
        tags: string(name='Tags', description='tags'),
        status: string(name='Status', description='state'),
        size: long(name='Size', description='fileSize'),
        privilege: integer(name='Privilege', description='publicType'),
        duration: long(name='Duration', description='duration'),
        description: string(name='Description', description='description'),
        customerId: long(name='CustomerId', description='userId'),
        createTime: string(name='CreateTime', description='gmtCreate'),
        modifyTime: string(name='ModifyTime', description='gmtModified'),
        coverURL: string(name='CoverURL', description='coverUrl'),
        cateId: integer(name='CateId', description='cateId'),
        snapshots: {
          snapshot: [ string ](name='Snapshot', description='Snapshot'),
        }(name='Snapshots', description='snapshots'),
      }
    ](name='MediaInfo', description='MediaInfo'),
  }(name='VideoList', description='data.aMediaList'),
}

async function searchMediaInfoWithOptions(request: SearchMediaInfoRequest, runtime: Util.RuntimeOptions): SearchMediaInfoResponse {
  Util.validateModel(request);
  return doRequest('SearchMediaInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function searchMediaInfo(request: SearchMediaInfoRequest): SearchMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaInfoWithOptions(request, runtime);
}

model RefreshUploadTokenRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  videoId: string(name='VideoId', description='mediaId'),
}

model RefreshUploadTokenResponse = {
  requestId: string(name='RequestId', description='requestId'),
  uploadKey: string(name='UploadKey', description='data.uploadKey'),
  uploadAddress: {
    accessKeyId: string(name='AccessKeyId', description='accessKeyId'),
    accessKeySecret: string(name='AccessKeySecret', description='accessKeySecret'),
    expiration: string(name='Expiration', description='expiration'),
    securityToken: string(name='SecurityToken', description='securityToken'),
  }(name='UploadAddress', description='data.uploadAddressDO'),
}

async function refreshUploadTokenWithOptions(request: RefreshUploadTokenRequest, runtime: Util.RuntimeOptions): RefreshUploadTokenResponse {
  Util.validateModel(request);
  return doRequest('RefreshUploadToken', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function refreshUploadToken(request: RefreshUploadTokenRequest): RefreshUploadTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshUploadTokenWithOptions(request, runtime);
}

model ListAllCategoryRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model ListAllCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  categoryList: {
    category: [
      {
        cateId: string(name='CateId', description='cateId'),
        cateName: string(name='CateName', description='cateName'),
        parentId: string(name='ParentId', description='parentId'),
        level: string(name='Level', description='level'),
      }
    ](name='Category', description='Category'),
  }(name='CategoryList', description='data.categoryList'),
}

async function listAllCategoryWithOptions(request: ListAllCategoryRequest, runtime: Util.RuntimeOptions): ListAllCategoryResponse {
  Util.validateModel(request);
  return doRequest('ListAllCategory', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function listAllCategory(request: ListAllCategoryRequest): ListAllCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllCategoryWithOptions(request, runtime);
}

model GetTotalStatisRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
}

model GetTotalStatisResponse = {
  requestId: string(name='RequestId', description='requestId'),
  transcodeDuration: long(name='TranscodeDuration', description='data.transcodeDuration'),
  storageUtilization: long(name='StorageUtilization', description='data.storageUtilization'),
  networkOut: long(name='NetworkOut', description='data.networkOut'),
}

async function getTotalStatisWithOptions(request: GetTotalStatisRequest, runtime: Util.RuntimeOptions): GetTotalStatisResponse {
  Util.validateModel(request);
  return doRequest('GetTotalStatis', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getTotalStatis(request: GetTotalStatisRequest): GetTotalStatisResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTotalStatisWithOptions(request, runtime);
}

model UpdateMediaInfoRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
  videoId: string(name='VideoId', description='mediaId'),
  title?: string(name='Title', description='title'),
  tags?: string(name='Tags', description='tags'),
  privilege?: integer(name='Privilege', description='publicType'),
  password?: string(name='Password', description='password'),
  description?: string(name='Description', description='description'),
  coverURL?: string(name='CoverURL', description='coverUrl'),
  cateId?: integer(name='CateId', description='cateId'),
  duration?: long(name='Duration', description='duration'),
  mediaWorkflowId?: string(name='MediaWorkflowId', description='mediaWorkflowId'),
  mediaWorkflowUserData?: string(name='MediaWorkflowUserData', description='mediaWorkflowUserData'),
  mediaWorkflowRunId?: string(name='MediaWorkflowRunId', description='mediaWorkflowRunId'),
}

model UpdateMediaInfoResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateMediaInfoWithOptions(request: UpdateMediaInfoRequest, runtime: Util.RuntimeOptions): UpdateMediaInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateMediaInfo', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateMediaInfo(request: UpdateMediaInfoRequest): UpdateMediaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaInfoWithOptions(request, runtime);
}

model UpdateMediaCategoryRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  mediaId: string(name='MediaId', description='mediaId'),
  cateId: string(name='CateId', description='cateId'),
}

model UpdateMediaCategoryResponse = {
  requestId: string(name='RequestId', description='requestId'),
  media: {
    mediaId: string(name='MediaId', description='mediaId'),
    title: string(name='Title', description='title'),
    description: string(name='Description', description='description'),
    coverUrl: string(name='CoverUrl', description='coverUrl'),
    cateId: long(name='CateId', description='cateId'),
    tags: string(name='Tags', description='tags'),
    duration: string(name='Duration', description='duration'),
    fileSize: string(name='FileSize', description='fileSize'),
    state: integer(name='State', description='state'),
    mediaWorkflowRunId: string(name='MediaWorkflowRunId', description='mediaWorkflowRunId'),
    createTime: string(name='CreateTime', description='createTime'),
    createIp: string(name='CreateIp', description='createIp'),
    mediaWorkflowId: string(name='MediaWorkflowId', description='mediaWorkflowId'),
    publicType: integer(name='PublicType', description='publicType'),
    snapshots: {
      snapshot: [ string ](name='Snapshot', description='Snapshot'),
    }(name='Snapshots', description='snapshots'),
  }(name='Media', description='data.mediaInfoDTO'),
}

async function updateMediaCategoryWithOptions(request: UpdateMediaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMediaCategoryResponse {
  Util.validateModel(request);
  return doRequest('UpdateMediaCategory', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateMediaCategory(request: UpdateMediaCategoryRequest): UpdateMediaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCategoryWithOptions(request, runtime);
}

model UpdateCategoryNameRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: string(name='OwnerId', description='ownerId'),
  resourceOwnerId?: string(name='ResourceOwnerId', description='resourceOwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  ownerAccount?: string(name='OwnerAccount', description='ownerAccount'),
  cateName: string(name='CateName', description='cateName'),
  cateId: string(name='CateId', description='cateId'),
}

model UpdateCategoryNameResponse = {
  requestId: string(name='RequestId', description='requestId'),
  category: {
    cateId: string(name='CateId', description='cateId'),
    cateName: string(name='CateName', description='cateName'),
    parentId: string(name='ParentId', description='parentId'),
    level: string(name='Level', description='level'),
  }(name='Category', description='data.category'),
}

async function updateCategoryNameWithOptions(request: UpdateCategoryNameRequest, runtime: Util.RuntimeOptions): UpdateCategoryNameResponse {
  Util.validateModel(request);
  return doRequest('UpdateCategoryName', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateCategoryName(request: UpdateCategoryNameRequest): UpdateCategoryNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryNameWithOptions(request, runtime);
}

model AddWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  horizontalOffet?: string(name='HorizontalOffet', description='horizontalOffet'),
  horizontalOffset?: string(name='HorizontalOffset', description='horizontalOffset'),
  verticalOffset?: string(name='VerticalOffset', description='verticalOffset'),
  position?: string(name='Position', description='position'),
  type?: string(name='Type', description='type'),
  bucket?: string(name='Bucket', description='bucket'),
  object?: string(name='Object', description='object'),
  name: string(name='Name', description='name'),
  width?: string(name='Width', description='width'),
  height?: string(name='Height', description='height'),
  active?: string(name='Active', description='active'),
  screenMode?: string(name='ScreenMode', description='screenMode'),
  videoWidth?: integer(name='VideoWidth', description='videoWidth'),
  videoHeight?: integer(name='VideoHeight', description='videoHeight'),
  watermarkConfig?: string(name='WatermarkConfig', description='watermarkConfig'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
  screenWidth?: integer(name='ScreenWidth', description='screenWidth'),
  screenHeight?: integer(name='ScreenHeight', description='screenHeight'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model AddWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermark: {
    createTime: integer(name='CreateTime', description='createTime'),
    horizontalOffset: string(name='HorizontalOffset', description='dx'),
    isDefault: string(name='IsDefault', description='isDefault'),
    position: string(name='Position', description='referpos'),
    watermarkId: string(name='WatermarkId', description='watertempId'),
    verticalOffset: string(name='VerticalOffset', description='dy'),
    name: string(name='Name', description='name'),
    width: string(name='Width', description='width'),
    height: string(name='Height', description='height'),
    url: string(name='Url', description='url'),
    videoHeight: integer(name='VideoHeight', description='videoHeight'),
    videoWidth: integer(name='VideoWidth', description='videoWidth'),
    screenMode: string(name='ScreenMode', description='externalScreenMode'),
  }(name='Watermark', description='data.waterMarkDto'),
  watermarkInfo: {
    creationTime: string(name='CreationTime', description='creationTime'),
    type: string(name='Type', description='type'),
    isDefault: string(name='IsDefault', description='isDefault'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    screenWidth: integer(name='ScreenWidth', description='screenWidth'),
    screenHeight: integer(name='ScreenHeight', description='screenHeight'),
    name: string(name='Name', description='name'),
    fileUrl: string(name='FileUrl', description='fileUrl'),
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  }(name='WatermarkInfo', description='data.watermarkDto'),
}

async function addWatermarkWithOptions(request: AddWatermarkRequest, runtime: Util.RuntimeOptions): AddWatermarkResponse {
  Util.validateModel(request);
  return doRequest('AddWatermark', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addWatermark(request: AddWatermarkRequest): AddWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWatermarkWithOptions(request, runtime);
}

model AddTranscodeTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  muxer: string(name='Muxer', description='muxer'),
  resolution: string(name='Resolution', description='resolution'),
  detail: string(name='Detail', description='detail'),
  name: string(name='Name', description='name'),
  videoBitrate: string(name='VideoBitrate', description='videoBitrate'),
  videoCodec: string(name='VideoCodec', description='videoCodec'),
  audioBitrate: string(name='AudioBitrate', description='audioBitrate'),
  audioCodec: string(name='AudioCodec', description='audioCodec'),
}

model AddTranscodeTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addTranscodeTemplateWithOptions(request: AddTranscodeTemplateRequest, runtime: Util.RuntimeOptions): AddTranscodeTemplateResponse {
  Util.validateModel(request);
  return doRequest('AddTranscodeTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addTranscodeTemplate(request: AddTranscodeTemplateRequest): AddTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTranscodeTemplateWithOptions(request, runtime);
}

model AddSnapshotRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  time: string(name='Time', description='time'),
  height: string(name='Height', description='height'),
  width: string(name='Width', description='width'),
  number: string(name='Number', description='num'),
}

model AddSnapshotResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function addSnapshotWithOptions(request: AddSnapshotRequest, runtime: Util.RuntimeOptions): AddSnapshotResponse {
  Util.validateModel(request);
  return doRequest('AddSnapshot', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function addSnapshot(request: AddSnapshotRequest): AddSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSnapshotWithOptions(request, runtime);
}

model GetCustomerTranscodeConfRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model GetCustomerTranscodeConfResponse = {
  requestId: string(name='RequestId', description='requestId'),
  templates: {
    template: [
      {
        id: string(name='Id', description='id'),
        customerId: string(name='CustomerId', description='customerId'),
        templateId: string(name='TemplateId', description='templateId'),
        mtstemplateId: string(name='MtstemplateId', description='mtstemplateId'),
        status: string(name='Status', description='status'),
        name: string(name='Name', description='name'),
        encrypt: string(name='Encrypt', description='encrypt'),
      }
    ](name='Template', description='Template'),
  }(name='Templates', description='data.templates'),
}

async function getCustomerTranscodeConfWithOptions(request: GetCustomerTranscodeConfRequest, runtime: Util.RuntimeOptions): GetCustomerTranscodeConfResponse {
  Util.validateModel(request);
  return doRequest('GetCustomerTranscodeConf', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getCustomerTranscodeConf(request: GetCustomerTranscodeConfRequest): GetCustomerTranscodeConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomerTranscodeConfWithOptions(request, runtime);
}

model DeleteWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
}

model DeleteWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function deleteWatermarkWithOptions(request: DeleteWatermarkRequest, runtime: Util.RuntimeOptions): DeleteWatermarkResponse {
  Util.validateModel(request);
  return doRequest('DeleteWatermark', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function deleteWatermark(request: DeleteWatermarkRequest): DeleteWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatermarkWithOptions(request, runtime);
}

model GetWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
}

model GetWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermark: {
    createTime: integer(name='CreateTime', description='createTime'),
    horizontalOffset: string(name='HorizontalOffset', description='dx'),
    isDefault: string(name='IsDefault', description='isDefault'),
    position: string(name='Position', description='referpos'),
    watermarkId: string(name='WatermarkId', description='watertempId'),
    verticalOffset: string(name='VerticalOffset', description='dy'),
    width: string(name='Width', description='width'),
    height: string(name='Height', description='height'),
    active: string(name='Active', description='isOpen'),
    url: string(name='Url', description='url'),
    name: string(name='Name', description='name'),
    videoHeight: integer(name='VideoHeight', description='videoHeight'),
    videoWidth: integer(name='VideoWidth', description='videoWidth'),
    screenMode: string(name='ScreenMode', description='externalScreenMode'),
  }(name='Watermark', description='data.waterMarkDto'),
  watermarkInfo: {
    creationTime: string(name='CreationTime', description='creationTime'),
    type: string(name='Type', description='type'),
    isDefault: string(name='IsDefault', description='isDefault'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    screenWidth: integer(name='ScreenWidth', description='screenWidth'),
    screenHeight: integer(name='ScreenHeight', description='screenHeight'),
    name: string(name='Name', description='name'),
    fileUrl: string(name='FileUrl', description='fileUrl'),
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  }(name='WatermarkInfo', description='data.watermarkDto'),
}

async function getWatermarkWithOptions(request: GetWatermarkRequest, runtime: Util.RuntimeOptions): GetWatermarkResponse {
  Util.validateModel(request);
  return doRequest('GetWatermark', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getWatermark(request: GetWatermarkRequest): GetWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkWithOptions(request, runtime);
}

model GetWatermarksRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model GetWatermarksResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermarks: {
    watermark: [
      {
        createTime: integer(name='CreateTime', description='createTime'),
        horizontalOffset: string(name='HorizontalOffset', description='dx'),
        isDefault: string(name='IsDefault', description='isDefault'),
        position: string(name='Position', description='referpos'),
        watermarkId: string(name='WatermarkId', description='watertempId'),
        verticalOffset: string(name='VerticalOffset', description='dy'),
        width: string(name='Width', description='width'),
        height: string(name='Height', description='height'),
        active: string(name='Active', description='isOpen'),
        url: string(name='Url', description='url'),
        name: string(name='Name', description='name'),
        videoHeight: integer(name='VideoHeight', description='videoHeight'),
        videoWidth: integer(name='VideoWidth', description='videoWidth'),
        screenMode: string(name='ScreenMode', description='externalScreenMode'),
      }
    ](name='Watermark', description='Watermark'),
  }(name='Watermarks', description='data.waterMarkDtos'),
  watermarkInfos: {
    watermarkInfo: [
      {
        creationTime: string(name='CreationTime', description='creationTime'),
        type: string(name='Type', description='type'),
        isDefault: string(name='IsDefault', description='isDefault'),
        watermarkId: string(name='WatermarkId', description='watermarkId'),
        screenWidth: integer(name='ScreenWidth', description='screenWidth'),
        screenHeight: integer(name='ScreenHeight', description='screenHeight'),
        name: string(name='Name', description='name'),
        fileUrl: string(name='FileUrl', description='fileUrl'),
        watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
      }
    ](name='WatermarkInfo', description='WatermarkInfo'),
  }(name='WatermarkInfos', description='data.watermarkDtos'),
}

async function getWatermarksWithOptions(request: GetWatermarksRequest, runtime: Util.RuntimeOptions): GetWatermarksResponse {
  Util.validateModel(request);
  return doRequest('GetWatermarks', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getWatermarks(request: GetWatermarksRequest): GetWatermarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarksWithOptions(request, runtime);
}

model SwitchWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  status: string(name='Status', description='isOpen'),
}

model SwitchWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function switchWatermarkWithOptions(request: SwitchWatermarkRequest, runtime: Util.RuntimeOptions): SwitchWatermarkResponse {
  Util.validateModel(request);
  return doRequest('SwitchWatermark', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function switchWatermark(request: SwitchWatermarkRequest): SwitchWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchWatermarkWithOptions(request, runtime);
}

model GetWatermarkSwitchRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
}

model GetWatermarkSwitchResponse = {
  requestId: string(name='RequestId', description='requestId'),
  waterMarkSwitch: {
    createTime: integer(name='CreateTime', description='createTime'),
    updateTime: integer(name='UpdateTime', description='updateTime'),
    active: string(name='Active', description='isOpen'),
    customerId: string(name='CustomerId', description='customerId'),
  }(name='WaterMarkSwitch', description='data.waterMarkSwitchDto'),
}

async function getWatermarkSwitchWithOptions(request: GetWatermarkSwitchRequest, runtime: Util.RuntimeOptions): GetWatermarkSwitchResponse {
  Util.validateModel(request);
  return doRequest('GetWatermarkSwitch', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function getWatermarkSwitch(request: GetWatermarkSwitchRequest): GetWatermarkSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkSwitchWithOptions(request, runtime);
}

model SetDefaultWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  watermarkId: string(name='WatermarkId', description='watertempId'),
}

model SetDefaultWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function setDefaultWatermarkWithOptions(request: SetDefaultWatermarkRequest, runtime: Util.RuntimeOptions): SetDefaultWatermarkResponse {
  Util.validateModel(request);
  return doRequest('SetDefaultWatermark', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function setDefaultWatermark(request: SetDefaultWatermarkRequest): SetDefaultWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultWatermarkWithOptions(request, runtime);
}

model UpdateTranscodeTemplateRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  muxer?: string(name='Muxer', description='muxer'),
  resolution?: string(name='Resolution', description='resolution'),
  detail?: string(name='Detail', description='detail'),
  name?: string(name='Name', description='name'),
  videoBitrate?: string(name='VideoBitrate', description='videoBitrate'),
  videoCodec?: string(name='VideoCodec', description='videoCodec'),
  audioBitrate?: string(name='AudioBitrate', description='audioBitrate'),
  audioCodec?: string(name='AudioCodec', description='audioCodec'),
}

model UpdateTranscodeTemplateResponse = {
  requestId: string(name='RequestId', description='requestId'),
}

async function updateTranscodeTemplateWithOptions(request: UpdateTranscodeTemplateRequest, runtime: Util.RuntimeOptions): UpdateTranscodeTemplateResponse {
  Util.validateModel(request);
  return doRequest('UpdateTranscodeTemplate', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateTranscodeTemplate(request: UpdateTranscodeTemplateRequest): UpdateTranscodeTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTranscodeTemplateWithOptions(request, runtime);
}

model UpdateTranscodeConfRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  ids: string(name='ids', description='ids'),
  encryptTemplayeIds?: string(name='EncryptTemplayeIds', description='encryptIds'),
}

model UpdateTranscodeConfResponse = {
  requestId: string(name='RequestId', description='requestId'),
  ret: boolean(name='Ret', description='data.ret'),
}

async function updateTranscodeConfWithOptions(request: UpdateTranscodeConfRequest, runtime: Util.RuntimeOptions): UpdateTranscodeConfResponse {
  Util.validateModel(request);
  return doRequest('UpdateTranscodeConf', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateTranscodeConf(request: UpdateTranscodeConfRequest): UpdateTranscodeConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTranscodeConfWithOptions(request, runtime);
}

model UpdateWatermarkRequest = {
  accessKeyId?: string(name='AccessKeyId', description='appKey'),
  ownerId?: long(name='OwnerId', description='ownerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', description='resourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId', description='resourceOwnerId'),
  horizontalOffet?: string(name='HorizontalOffet', description='horizontalOffet'),
  horizontalOffset?: string(name='HorizontalOffset', description='horizontalOffset'),
  verticalOffset?: string(name='VerticalOffset', description='verticalOffset'),
  position?: string(name='Position', description='position'),
  type?: string(name='Type', description='type'),
  bucket?: string(name='Bucket', description='bucket'),
  object?: string(name='Object', description='object'),
  name?: string(name='Name', description='name'),
  width?: string(name='Width', description='width'),
  height?: string(name='Height', description='height'),
  watermarkId?: string(name='WatermarkId', description='watertempId'),
  screenMode?: string(name='ScreenMode', description='screenMode'),
  videoWidth?: integer(name='VideoWidth', description='videoWidth'),
  videoHeight?: integer(name='VideoHeight', description='videoHeight'),
  watermarkConfig?: string(name='WatermarkConfig', description='watermarkConfig'),
  fileUrl?: string(name='FileUrl', description='fileUrl'),
  screenWidth?: integer(name='ScreenWidth', description='screenWidth'),
  screenHeight?: integer(name='ScreenHeight', description='screenHeight'),
  resourceRealOwnerId?: long(name='ResourceRealOwnerId', description='resourceRealOwnerId'),
}

model UpdateWatermarkResponse = {
  requestId: string(name='RequestId', description='requestId'),
  watermark: {
    createTime: integer(name='CreateTime', description='createTime'),
    horizontalOffset: string(name='HorizontalOffset', description='dx'),
    isDefault: string(name='IsDefault', description='isDefault'),
    position: string(name='Position', description='referpos'),
    watermarkId: string(name='WatermarkId', description='watertempId'),
    verticalOffset: string(name='VerticalOffset', description='dy'),
    width: string(name='Width', description='width'),
    height: string(name='Height', description='height'),
    url: string(name='Url', description='url'),
    videoHeight: integer(name='VideoHeight', description='videoHeight'),
    videoWidth: integer(name='VideoWidth', description='videoWidth'),
    screenMode: string(name='ScreenMode', description='externalScreenMode'),
    name: string(name='Name', description='name'),
  }(name='Watermark', description='data.waterMarkDto'),
  watermarkInfo: {
    creationTime: string(name='CreationTime', description='creationTime'),
    type: string(name='Type', description='type'),
    isDefault: string(name='IsDefault', description='isDefault'),
    watermarkId: string(name='WatermarkId', description='watermarkId'),
    screenWidth: integer(name='ScreenWidth', description='screenWidth'),
    screenHeight: integer(name='ScreenHeight', description='screenHeight'),
    name: string(name='Name', description='name'),
    fileUrl: string(name='FileUrl', description='fileUrl'),
    watermarkConfig: string(name='WatermarkConfig', description='watermarkConfig'),
  }(name='WatermarkInfo', description='data.watermarkDto'),
}

async function updateWatermarkWithOptions(request: UpdateWatermarkRequest, runtime: Util.RuntimeOptions): UpdateWatermarkResponse {
  Util.validateModel(request);
  return doRequest('UpdateWatermark', 'HTTPS', 'POST', '2017-03-14', 'AK', request, null, runtime);
}

async function updateWatermark(request: UpdateWatermarkRequest): UpdateWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatermarkWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
